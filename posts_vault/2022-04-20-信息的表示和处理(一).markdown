---
layout: post
title: 信息的表示和处理(一)
date: 2022-04-20 16:45:30.000000000 +09:00
tag: CSAPP
---

### 三个最重要的数字表示
* 无符号 unsigned 编码基于传统的二进制表示法，表示大于或等于零的数字。
* 补码 two's-complement 编码是表示有符号整数的最常见的方式，有符号就是可以为正或为负。
* 浮点数 floating-point 编码是表示实数的科学计数法以 2 为基础的版本。

计算机表示法用有限的数量的位表示一个数字的编码，当结果太大以至不能表示时，就会溢出


整数运算和浮点数运算会有不同的数学属性时因为他们处理数字表示有限性的方式不同，即整数表示虽然只能编码一个较小的范围，但这种表示是精确的。而浮点数虽然编码一个较大的范围，但是它只是近似的。

{% highlight ruby %}
大量计算机安全漏洞都是由于计算机算术运行的微妙细节引发的
{% endhighlight %}

GUN 编译器套装 GNU Compiler Collection，GCC


{% highlight ruby %}
linux 上用 gdb。mac os 上 用 lldb。
{% endhighlight %}

### 信息的存储
大多数计算机使用 8 位的块，或者字节 byte 作为最小的可寻的内存单位，而不是访问内存中单独的位。
{% highlight ruby %}
机器级程序将内存视为一个非常大的字节数组称为虚拟内存 virtual memory。
内存的每个字节都由一个唯一的数字来标识，称为它的地址，所有可能地址的集合称为虚拟地址空间。
C 语言中一个指针的值都是某存储块的第一个字节的虚拟地址。
C 指针包括两个方面：值和类型，值表示某个对象的位置，类型表示那个位置上所存储对象的类型
{% endhighlight %}

#### 十六进制表示法 hexadecimal 缩写 hex
使用 0-9 A-F表示 16 个可能的值，C 语言中 以 0x 或 0X 开头的数字表示十六进制
{% highlight ruby %}
一个字节的值域 00~FF
{% endhighlight %}

#### 十进制转换为十六进制 
{% highlight ruby %}
一个字节的值域 00~FF
公式 x = q×16 + r
十进制和十六进制表示之间的转换需要使用乘法或者除法来处理一般情况。将一个十进制数字 x 转换为十六进制，
可以反复地用 16 除 x，得到一个商 q 和一个余数 r，
也就是 x = q×16 + r。 然后，我们用十六进制数字表示的 r 作为最低位数字，并且通过对 q 反复进行这个过程得到剩下的数字。
例如，考虑十进制 314156 的转换 :
314156 = 19634 × 16 + 12  (C)
19634  = 1227  × 16 + 2   (2)
1227   = 76    × 16 + 11  (B)
76     = 4     × 16 + 12  (C)
4      = 0     × 16 + 4   (4)
从这里，我们能读出十六进制表示为 0x4CB2C。
{% endhighlight %}

#### 十六进制转换十进制
{% highlight ruby %}
反过来，将一个十六进制数字转换为十进制数字，我们可以用相应的 16 的幂乘以每个十六进制数字。
比如，给定数字 0x7AF，我们计算它对应的十进制值为 
7 × 16^2 + 10 × 16^1 + 15 x 16^0 = 7 × 256 + 10 × 16 + 15 = 1792 + 160 + 15 = 1967。
{% endhighlight %}

#### 十六进制例子
{% highlight ruby %}
当值 x 是 2 的非负整数 n 次幂时，也就是 x = 2^n，我们可以很容易地将 x 写成十六进制形式，
只要记住 x 的二进制表示就是 1 后面跟 n 个 0。
十六进制数字 0 代表 4 个二进制 0。所以，当 n 表 示 成 i + 4 j 的 形 式 ， 其 中 0 ≤ i ≤ 3 时 ， 
我 们 可 以 把 x 写 成 开 头 的 十 六 进 制 数 字 为 1( i = 0 )、2( i = 1 )、 4(i=2)或者 8(i=3)，
后面跟随着 j 个十六进制的 0。
比如，x=2048=2^11，我们有 n=11 = 3 + 4×2，从而得到十六进制表示 0x(2^3)00 = 0x800。
 
n = i + 4j
公式：十六进制值 0x(2^i)(j 个 0)

例 2^19 的十六进制 19 = 3 + 4 * 4， i = 3，j = 4 所以最后为 0x80000
{% endhighlight %}


### 字数据大小
每个计算机都有一个字长，指明指针数据的标称大小, 因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。
{% highlight ruby %}
对一个字长为 w 位的机器而言，虚拟地址的范围为 0~2^w - 1，程序最多访问 2^w 个字节
{% endhighlight %}

32 位字长限制虚拟地址空间为 4 GB

#### 程序取决于如何编译
{% highlight ruby %}
linux> gcc -m32 prog.c 能在 32 bit 或 64 bit 系统上运行
linux> gcc -m64 prog.c 只能再 64 bit 系统上运行
{% endhighlight %}
因此我们称 32 bit，还是 64 bit 程序，区别在于是如何编译的，而不是其运行机器类型。许多机器都有处理单个字节的指令，也有处理 2 字节、4 字节或 8 字节的整数指令，还有些指令支持 4、8 字节浮点数指令。


#### 寻址和字节顺序
跨越多字节的程序对象 我们比较建立两个规则 
1. 这个对象的地址是什么 
2. 内存中如何排列这些对象

{% highlight ruby %}
多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。
{% endhighlight %}

最低有效字节在最前面的方式称小端法(little endian)， 最高有效字节在最前面的方式称为大端法(big endian)
{% highlight ruby %}
安卓和 iOS 手机是小端法。
{% endhighlight %}


#### 字节顺序变得重要三个原因
1. 一个问题是当小端模式机器产生的数据发送到大端模式机器或反过来，接收程序会发现字里的字节成了反序的。
为了避免找各种冲突网络应用程序比较遵守已建立的关于字节顺序的规则，以确保发送方将它内部表示转换成网络标准，而接收方机器则将网络标准转换成它内部表示。
2. 当阅读表示整数数据的字节序列时字节顺序也很重要，这通常发生在检查机器级程序时。
- 4004d3: 01 05 43 0b 20 00  add   %eax,0x200b43(%rip) 把一个字长数据加上一个值，该值地址通过 = rip0x200b43 + 下一条要执行指令的地址。
3. 当编写规避正常的类型系统的程序时，在 C 语言中可以通过强制类型转换或联合来允许以一种数据类型引用一个对象。

{% highlight ruby %}
数据类型 void * 是一种特殊类型的指针，没有相关联的类型信息
命令 man ascii 来获得一张 ASCII 字符码表
{% endhighlight %}

对数 12345 编码，整数为 0x00003039，浮点数为 0x4640e400，整数和浮点数编码方式是不同的。

#### 表示字符串
在 C 语言中字符串被编码为一个以 null(其值为0)字符结尾的字符数组，终止字符十六进制为 0x00。'a'~'z' ASCII 码为 0x61~0x7A。
基本编码 Unicode 称为统一字符集使用 32 bit 来表示字符

{% highlight ruby %}
UTF-8 表示将每个字符编码为一个字节序列 这也就意味着所以 ASCII 码表示和用 UTF-8 表示是一样的
{% endhighlight %}


### 布尔代数简介
* ~ 为 NOT 取反
* ^ 为 亦或
* & 为 AND
* \|   为 OR

{% highlight ruby %}
~ & ^ | 能运用到任何“整型”数据类型上

a ^ a = 0，(a ^ b) ^ a = b，a ^ 0 = a

a & (b | c) = a & b | a & c

a | (b & c) = (a | b) & (a | c)

使用 ^ 进行 swap 并没有性能上的优势
{% endhighlight %}



#### C 语言中的位级运算
* 赋值 a \|= b        A OR B
* 取消赋值 a &= ~b   A & ~B
* if a & b 说明 a 包含 b
* a ^ b = (a & ~b) \| (~a & b)

{% highlight ruby %}
x = 0x87654321
x & 0xFF  = 0x00000021   & 取某位中的内容
x ^ ~0xFF = 0x789ABC21
x | 0xFF  = 0x876543FF   | 设置某位中的内容
{% endhighlight %}

#### 逻辑运算
非零为 TRUE

#### C 语言中的位移操作
* 左移: 左移 k 位，即向左移动 k 位，丢弃最高的 k 位
* 右移: 丢弃低位
1. 逻辑右移，在左端补 k 个 0
2. 算术右移，在左端补 k 个最高有效位, 原最高有效位为 1 补 1，为 0 补 0
{% highlight ruby %}
对于无符号，右移必须是逻辑的。
{% endhighlight %}
