---
layout: post
title: BTC-05-挖矿难度和挖矿
date: 2022-07-29 16:45:30.000000000 +09:00
tag: 区块链
---

## 0x01 挖矿难度

挖矿即 Hash（block header）<= target；Hash（block header（ nonce））<= target

{% highlight ruby %}
公式  difficulty = difficulty_1_target / target (表示 target=1 时的挖矿难度)
difficulty  = previous_difficulty * (2 weeks) / ( time to mine last 2016 block )
挖矿难度最小就是 1，
{% endhighlight %}

target 越小挖矿难度越大，挖矿难度与 target 成反比。调整挖矿难度就是调整输出空间在整体范围内的比率
比特币使用 SHA-256 ，所以哈希值是 256 位，输出范围是 2^256。

### 出块时间太短有什么问题？
同时挖到矿会产生分叉，可能是多个分叉（比如 10个人都挖到了，10 分叉），分叉多了对整个系统达成共识是没有好处的，比特币系统认为大部分好算力掌握在诚实的矿工手里。
假如前边 A 转给 B 一大笔 BTC，然后之后分 10 个叉，这时 A 又转钱给自己，由于出块速度太快，分叉导致算力不集中，但攻击者 A 可以专心维护自己的分叉，很容易导致 A 转钱给自己成为最长合法链，所以出块时间不是越短越好。

以太坊出块是 15 秒，以太坊通过 ghost 共识协议，产生的分叉叫 orphan block，分叉也要给奖励叫 uncle reward，
以太坊也要设置挖矿难度，保证出块时间。保证稳定。

{% highlight ruby %}
调整挖矿难度，是为了维持出块稳定， 出块时间要有个范围不能无限的减少下去。
{% endhighlight %}


### 如何调整挖矿难度
比特币每隔 2016 个区块要调整一下挖矿的阈值，大约是每两周调整一下。

2016 * 10 分钟 / 60分钟 * 24 小时 = 14 天

实际比特币代码用的是这个公式

{% highlight ruby %}
调整阈值公式：target = target * actual time / expected time
expected time = 2016 * 10 分钟
actual time 系统中产生 2016 个区块实际花费的时间

实际 target 最大增大不会超过原来的4倍，减小不会小于 1/4

{% endhighlight %}

计算调整 target 代码是写在 BTC 系统里的，达到每个节点都会调整。


### 如果有恶意节点在2016个块后不调整 target 呢？
* nBits 在 header 里有 4 个字节，如果不调整合法性通不过
* 以太坊没出一个块都有可能触发调整 target，比比特币系统的调整要复杂的多


{% highlight ruby %}
Hash Rate 算力
比特币出块时间 10 分钟左右
一个区块最大 1 M 字节
2016 个区块调整一次难度
{% endhighlight %}


## 0x02 挖矿

### 全节点
* 一直在线
* 在本地硬盘上维护完整的区块链信息
* 在内存里维护 UTXO 集合，以便快速检验交易的正确性
* 监听比特币网络上的交易信息，验证每个交易的合法性（是否有合法的签名，是否双花）
* 决定哪个交易会被打包到区块里
* 监听别的矿工挖出来的区块，验证其合法性：
1. 每个交易都要合法，包括铸币的 coinbase 交易，比如有没有篡改出块奖励，发布的区块是否复合难度要求（即检测哈希前边必要的 0 个数）等
2. 检测挖矿难度是否正确，然后每两周按比特币协议要求调整难度
3. 是否延伸的是最长合法链
* 挖矿
1. 决定沿着哪条链挖下去？应该沿着最长合法链
2. 当出现等长的分叉时候，选择哪一个分叉？默认选择先听到的分叉


### 轻节点
* 不是一直在线
* 不用保存整个区块链，只有保存每个区块的块头（存整个区块跟块头大小差 1000 倍左右）
* 不用保存全部交易，只保存与自己相关的交易
* 无法检验大多数交易的合法性，只能检验与自己相关的那些交易的合法性（无法检测双花）
* 无法检测网上发布的区块的正确性
* 可以验证挖矿的难度，因为有块头
* 只能检测哪个是最长链，不知道哪个是最长合法链（因为无法验证交易合法性）
* 轻节点假设矿工是有理智的，不会沿着不合法的链挖下去


如果挖矿过程中收到了最长合法连新区块，这时需要整理自己数据，重新组装一个候选区块，重新挖矿，因为之前挖的包含的交易可能已经打包在了新区块中。
这样并不可惜。因为挖矿时无记忆性的，导致成功的概率是一样的。


{% highlight ruby %}
大部分都是轻节点，如果只需要转账不挖矿，轻节点就够了。
{% endhighlight %}

### 比特币如何保证安全性
1. 密码学：别人没有你的私钥就无法伪造你的签名转走你的钱，这个的前提是系统中大多数矿工是好的，不会接收没有合法签名的交易
2. 共识机制

### 挖矿趋势
* 第一代使用 CPU 但性价比低，内存等使用率低
* 第二代使用 GPU ，虽然比 CPU 效率有很大提升，挖矿只是整数计算，因此性价比也不高，但现在挖矿已经超出了 GPU 的算力
* 现在一般用 ASIC(Application Specific Integrated Circuit，专门用于挖矿)芯片，有些新币发行，为了解决冷启动问题，会用已有的 mining puzzle（比如用比特币的 mining puzzle）这种叫 merge mining 来吸引用户。否则一般一个芯片对应一个币的挖矿。

趋势从通用向专用转变，ASIC 芯片框架生产出来大约 1~2 月能通过算力赚取比特币，这时有些厂商可能会找借口不发货给买家。

有些新加密货币设计了 Alternative mining puzzle 为了 ASIC resistance ，抵抗 ASIC 芯片挖矿，目的是用通用设备挖矿也可行。

虽然比特币系统所有矿工平均 10 分钟出块，平均收益上看是有利可图的，但很不稳定。单个矿工成本其实不小，用 ASIC 矿机大约 1~2 年才能出一个块，没有出块电费就白白交上去了。
而且单个矿工还要承担全节点的其他责任，所以就需要有矿池（pool manager）。

矿池就是把矿工组织起来成为一个整体，一般架构是一个全节点会有很多矿工，矿工只负责计算哈希值，其他职责由 pool manager（矿主） 负责，比如监听网上交易，打包候选区块等。ASIC 芯片只能计算哈希值，矿池也是为了解决收益不稳定的问题，大家一起干一起分利。

### 矿池组织形式
1. 矿工和矿主属于同一个组织
2. 分布式：矿工和矿主属于不同组织，矿主给矿工分配任务，矿工根据矿主的通信协议进行计算，计算完哈希值再发给矿主。所以这里同样需要 PoW 证明矿工的工作量。
这里需要降低难度挖矿，这样挖到的叫一个 Share（almost valid block），矿工把 Share 提交给矿主，作为矿工的工作量，之后挖到后再按照 Share 作为收益如何分配依据。

#### 是否会出现矿工提供 Share，但挖到矿时自己出块偷取奖励？
这是不可能的，原因如下
1. 由矿主组装区块，分配给 nonce 给矿工计算
2. 矿工提交地址是矿主的地址（即挖矿调整阈 cooinbase transaction 地址），所以即使自己出块也取不出钱
3. 如果矿工自己不按照矿主协议，那么矿主是不认的（这种属于矿工自己单干与矿池没有关系）

#### 矿工是否会捣乱？比如还是正常提交 Share，但挖到块把块扔掉？
有可能，因为矿池是有竞争关系的，可能打击对手，故意派些矿工到别人的矿池

![](/assets/images/btc/suanli1.png)

#### GHash.IO
2014-6-12，GHash.IO 这个矿池算力达到了 51% 当时造成了恐慌，之后 GHash.IO 自动降低自己的算力
![](/assets/images/btc/suanli2.png)

![](/assets/images/btc/suanli3.png)



#### 矿池的好处
1. 减轻矿工的负担，矿工只计算哈希值就行
2. 收入更加稳定

#### 矿池的危害
* 使 51% 的攻击更加容易了，可以通过减少手续费、管理费的手段吸引矿工的加入，之后发动攻击
* 矿工加入矿池是很容易的。就是按照那个矿主的通信协议。所以多个矿池可能属于一个组织，这样这个组织总算力在 51% 想发动攻击时就能发动

#### 矿池的攻击
有 51% 算力后有些攻击更容易，因为矿工只负责计算并不知道矿主在干什么

1. 分叉攻击
2. Boycott (封锁某账户)，比如不喜欢某账户，所有跟这个账户相关的交易都不让上链（马上分叉），Boycott 不需要等最长合法链确认，即某账户交易出块就分叉

有没有可能攻击者掌握了 51% 算力，把别人账上的钱转走？这是不可能的，因为攻击者没有那个人的私钥

#### 矿池的优势
云计算里有个概念叫 on demand computing，平时自己不必有太多的集群，但用的时候可以获得。对应到矿池叫 on demand mining。



