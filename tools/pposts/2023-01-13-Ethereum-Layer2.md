---
layout: post
title: 以太坊和 Layer2
date: 2023-01-13 16:45:30.000000000 +09:00
categories: [区块链, Ethereum]
tags: [区块链, Ethereum]
---

# 前言
以太坊扩容通过分片等技术，提高 TPS，降低交易费用。很多的 Layer2 解决方案是把之前一些链上处理的操作放到链下处理，通过 L2 协议把大部分交易放到链下处理，然后再把交易的处理结果汇总返回到链上大大降低链上的工作量。

那么那些方案属于 Layer2 ？业界的观点是 Layer2 要继承 Layer1 的安全性。
所以侧链不属于 Layer2，因为侧链独立运行，并且有自己的共识协议和验证者。侧链与主链是脱节的。

# Rollup（本意可以叫卷起，Web3 这里是打包的意思）
Rollup 扩容的方式，可理解为就是把上千个交易捆绑在一起处理再把压缩后的数据上传到以太坊主网，大幅提高交易的处理效率

![image](/assets/images/eth/layer2-1.png)

## Rollup 工作原理
![image](/assets/images/eth/layer2-2.png)

首先在以太坊部署一个智能合约来记录状态（账户的状态和交易的状态），这个通过 Merkle 树根的哈希值表示（即上图的 state root），
Merkle 树中的叶子节点是 Rollup 中的账户状态信息，Rollup 把多个交易卷起来打包依批次向以太坊发送一个交易，这个交易的计算是在链下完成的，
执行交易会改变账户的状态信息也会改变 state root 的哈希值，但这个更新不需要实时的发布到链上。可以将交易批量打包进行压缩然后让这一个批次所包含的
压缩后的数据以及状态更新统一提交给主链上的智能合约。完成一次 Rollup 类的状态转移确认。这样做的好处是可以一次性的验证很多个交易，大大提高效率同时继承了
以太坊的安全性。即在不牺牲安全性的情况下，把 TPS 提高成百上千甚至更高。`即交易不需要在 Layer1 上执行，在 Layer2 执行交易后把压缩后的数据上传回主链`。
这些交易数据时放在 `CoreData` 里的，Solidity 中以 `CoreData` 形式传递的参数是不会被解析的也不会被执行，
Solidity 就把它当成是一组字节存储在区块链的历史日志里，不同的 Layer2 方案在数据可用性上也存在差别，比如有的把数据放在链上，有的会把数据放在链下，
数据放在链下可以进一步的提高 TPS 但是付出的代价是安全性。另一个问题是不在链上存数据，将来要用找不到怎么办？

### 那么既然交易在链下由 Rollup 完成，怎么保证 Rollup 对状态的更新是正确的呢？
Rollup 把状态更新提交到主链的智能合约后，智能合约在验证过程中并不需要执行压缩包中的交易（如果再执行一遍相当于 Rollup 就没有用了），
那么不执行压缩的交易怎么知道结果是正确的呢，如果 state root 可以被随便改，肯定是不行的，为了解决这个问题目前有两个方案

1. Optimistic Rollups：采用欺诈证明，缺省情况下假如 Rollup 对 state root 的更新是正确的。
如果有人发现不对，可以发布一个证明到链上证明这个批次的 Rollup 计算错误。
智能合约会验证，如果验证后发现确实是错误的，会把状态恢复到那个批次之前的状态并且对提交这个 Rollup 的欺诈者进行处罚，对举报者进行奖励。
Optimistic Rollups 的不足是需要较长的退出挑战期，因为要给举报者留有一定的举报时间。
代表是 OPTIMISM（简单一些） 和 ARBITRUM

2. zk-Rollups：采用有效性证明，每个 Rollup 在提交的时候都包含一个密码学的证明，
证明新的 state root 是执行交易后的正确结果，无论计算量多大这个计算过程都可以在链上快速验证。
zk-Rollups 的安全比 Optimistic Rollups 更高，当场就可以验证正确性，不存在秋后算账的问题，使得转账交易的提款时间缩短了很多。
不足之处是所依赖的密码学证明十分复杂，目前还无法做的和 EVM 完全兼容

> Layer2 方案依赖于 Layer1，如果以太坊 Layer1 出现问题，那么 Layer2 也就无法使用。但如果 Layer2 出现问题，用户还是可以使用 Layer1 的主链，
只是没有了 Layer2 的加速。
{: .prompt-info }

# Optimistic Rollups

## Optimistic Rollups 优缺点
* 优点：技术成熟，易于实现，在市场上得到广泛应用
* 缺点：
1. 挑战期过长（一般比较安全的是 1~2 周），挑战期结束前没有那个交易能被认为是确定的，比如转账交易要一周后才能拿到钱，这样用户体验就很差。
2. 假设要求社区里有足够多的挑战者来验证 Rollup 区块的合法性并且能在挑战期结束前及时提交欺诈证明。如果长时间验证者没有发现欺诈行为，
那么验证者可能受到一定打击，所以激励验证者验证交易也是一个问题。

另外 Layer2 区块里的交易可以不受 gasLimit 限制，但如果收到举报后需要在主链验证，所以还是要受到 gasLimit 限制，ARBITRUM 就是针对这一点进行了优化

## OPTIMISM
1. 乐观的认为 Rollup 发布到以太坊主网的数据时正确的
2. 引入了争议时间延迟机制（Dispute Time Delay，DTD）
3. 使用挑战期保护数据正确性。发布数据的时候要质押一定的保证金。如果有人对 Rollup 发布的信息有争议的话，
可以在挑战期发起挑战，向这个 Rollup 的合约提交证明，证明这个批次提交错误，Rollup 协议将在主链上重新计算该区块中的所有交易来判断对错，
如果发现确实存在欺诈行为，那么该批次以及以后关联的交易的执行结果都需要回滚并且罚没质押的保证金奖励给挑战者，发起挑战时也需要质押保证金，
这是为了防止 DDoS 攻击，否则有恶意的节点可以对没有 Rollup 区块都发起挑战，迫使所有的交易在主链都重新交易一遍，那么的话 Rollups 就没有意义了。


## ARBITRUM
采用了 Layer2 上多轮交互式欺诈证明和 Layer1 一步式证明，验证人和挑战者在链下通过二分法不断拆分存在争议的步骤直到将争议范围拆分到最小的不可再分的单位，
再把这个单位放到 Layer1 上进行判定，以此实现高效的争端解决。

![image](/assets/images/eth/layer2-4.png)


Challenger 提出争议后，Asserter 会将争议二等分，然后由 Challenger 继续选择挑战的范围，之后再由 Asserter 将争议二等分，如此循环直到直到将争议范围拆分到最小的不可再分的单位，发送给 Layer1 上的智能合约，再由 Layer1 上的智能合约执行，最后决定争议的胜诉方。
这样设计是为了尽可能多的工作放到链下进行，降低链上的处理成本，同时 ARBITRUM 可以支持复杂的智能合约，合约的规模不受以太坊的限制，
也就是说 Rollup 消耗的 gas 可以比以太坊的上限还要高，出现争议时只需要很小一部分代码到链上执行，以解决 OPTIMISM 受到以太坊 gas Limit 的问题，
同时可以更好的支持智能合约的可组合性，DeFi 的合约往往涉及多个合约的调用，可组合性是很重要的。

发生在兼容 EVM 的 Layer2 的交易也将日益复杂，对应的交易争议处理要求也越来越高，通过多轮交互式设计 ARBITRUM 可以实现当存在争议时，
以较低的成本在链上解决争议，在争议期间其他验证者可以自行撰定争议的结果，这就意味着会发生 soft fork，验证者可以在正确的分叉上继续提交区块。
实际操作中 ARBITRUM 使用一些的优化手段更快的解决挑战，比如每次不是对半分而是分成 200 份（二分法是以 2 为底的对数，这样是以 200 为底的对数），
这样分割可以迅速降低分歧的规模缩争议范围，但是并没有改变复杂度，这个分割是在链下进行（或者说是在 Layer2 进行的），最后分割的结果在放到链上进行判定。

这种交互式证明的缺点
* 由于增加了交互次数，对应的窗口争议期相对于单轮的交互式证明更长了，在这期间需要原始提款人在线配合
* OPTIMISM 属于单轮的交互式证明，只需要一轮，所以交互时间较短


ARBITRUM 未来可能会转向 ZK-Rollups（零知识证明 Rollups）

# ZK-Rollups
* ZK-Rollup 采用有效性证明，利用零知识证明（ZKP，zero-knowledge proof）保障交易的有效性。
在数据上链前就通过零知识证明对数据进行验证，先证明交易没有问题，然后再把更新后的状态对交易的证明以及压缩后的交易数据传到主链上，
以此确保对应数据在链上的有效性和资金的安全性。
* ZK-Rollup 的安全性依赖于密码学原理，它的一个主要优点在于不需要挑战期，提取资金相比 Optimistic Rollup 的 1~2 周的挑战期 ZK-Rollup 只需要几分钟。
* 目前 ZK-Rollup 的通用计算能力较差，已经上线的版本大多只能实现转账和特定的应用场景对开发人员不友好。
现在有些最新的 ZK-Rollup 方案有与通用 EVM 兼容的 Layer2 方案，如果能成功的话意义很大，从情怀上讲 ZK-Rollup 基于密码学原理来证明交易的正确性更符合加密事件的调性


# 零知识证明基础
* 零知识证明是密码学概念，由证明者和验证者组成
* 零知识证明是指一方（证明者）向另一方（验证者）证明一个陈述是正确的，而无需透露除该陈述是正确的之外的其他信息
* 证明者（prover）负责计算交易并且把这些交易聚合成零知识证明，证明者需要运行在专门的硬件上是去信任化的（即系统的安全性不需要假设证明者是值得信任的，或者说他们所运行的硬件是值得信任的，因为数学上无法伪造假的零知识证明）
* 验证者（validator 或 verifier）负责验证证明者提交的零知识证明的有效性，验证者不需要专门的硬件，任何节点都可以运行。通俗的说证明者从其系统中创建证明，验证者检查确认证明者上传的是真实的计算结果而不需要重新再计算一次

# ZK-SNARK（Zero-Knowledge Succinct Non-Interactive Argument of Knowledge）

区块链中用的比较多的是 ZK-SNARK，它是一种特殊的零知识证明，他有两个要求
1. 非交互性：证明者向验证者一次性发送一个消息，两者无需进行交互。对于区块链场景证明者把交易发布到链上，所有节点都可以验证，不需要与证明者交互，
这种验证者叫 public verifier
2. 简洁性：验证速度快（毫秒级），存储空间小（几百个字节，即使原始输入很大生成证明也是很小的）。这是它的优点，但代价是证明者产生证明的工作量是很大的，
比如一个匿名转账交易的时间需要几秒，而验证这个交易的合法性只需要几毫秒

ZK-SNARK 需要进行信任设置，要求初始化时随机产生一组所有成员共享的公共参数，初始化时用到的随机源必须要销毁掉，如果泄露的话其安全体系就崩溃了，
有恶意的攻击者可以制造出假的证明，为了避免这个风险 ZK-SNARK 初始化过程是多方参与的只要任何一方销毁了初始化时用的随机源这个系统就是安全的

## 优点
生成的证明很短，节省网络带宽，验证速度快

## ZK-SNARK 在区块链中的应用

### Zcash
Zcash 是 ZK-SNARK 第一个广泛的应用。Zcash 用 ZK-SNARK 来隐藏交易信息（交易双方的身份或地址，交易金额）。
ZK-SNARK 可以在不知道 sendAddress、receiveAddress、InputValue、outputValue 的情况下验证交易的合法性。这和比特币是不同的，
比特币每笔交易都要说明交易的来源。
对应 Zcash 来说只要通过数学的方法证明你花掉的币是当前系统中合法的币就行，不用说明具体是那一个币，这样就没法追踪币的来源。

### Filecoin
Filecoin 是目前最大的 ZK-SNARK 网络，每天生成几百万个零知识证明，Filecoin 的矿工通过存储数据来获得出块奖励，需要定期证明他们在存储所承诺的数据，
这些矿工是 ZK-SNARK 协议里的证明者需要提供两类证明，复制证明和时空证明
1. 复制证明：只有一次，当用户和存储提供者最初达成存储交易时，存储提供者需要证明他们确实存储了用户的数据，用户验证提供者存储了数据
2. 时空证明：定期提供，用于证明随着时间的推移存储提供者依然继续存储着原始数据

存储提供商首次同意为用户存储数据时，需要质押相应的代币，如果在协议期间，存储提供商未能提供时空证明将会受到处罚，可能失去质押的代币。
Filecoin 并没有实现真正意义下的隐私计算，ZK-SNARK 协议只是用于 Filecoin 的共识机制，并没有用于用户数据。目前 ZK-SNARK 都是专用集成电路，
也就是针对不同的应用进行定制不同的零知识证明电路。以太坊是图灵完备的，目前 ZK-SNARK 技术还无法实现通用智能合约。


# ZK-Rollups 代表项目
## 1 zkSync
* 基于 ZK-SNARK 实现
* 安全性依赖于初始化信任设置（Multi-part Computation Ceremony），由包括 V 神在内一些参与者一起制定一个随机数，要求至少有一个参与者是诚实的，这个系统才可以被证明是安全的，否则生成的是虚假证明
* 在 EVM 兼容方面 zkSync 有一个编译器，可以把智能合约转换成 zk-evm 支持的操作码来实现 Solidity 兼容

![image](/assets/images/eth/layer2-5.png)

### zkSync 数据可用性（两种方案）
1. 链上存储：安全性高，需要支付比链下存储高一些的 gas 费
2. 链下存储：节省 gas 费，牺牲一定安全性和去中心化。比如存在 IPFS 上，IPFS 不保证不可篡改性

![image](/assets/images/eth/layer2-6.png)

## 2 STARKWARE
* 基于 zk-STARK 技术（由 StarkWare 团队发明），全称 Scalable Transparent Arguments of Knowledge
* 可以认为 zk-STARK 是 zk-SNARK 的升级版，有更强的可扩展性
* 使用 zk-STARK 的区块链底层允许开发人员将链上的交易数据以及部分数据的存储转移到链下来解决，链下批量处理后的数据可以打包生成一个 STARK 证明，
将证明发送到链上后可以供任何利益相关方验证真伪

### 相比 zk-SNARK 而言，zk-STARK 具有一下优势
1. 透明性（transparency）：zk-STARK 无需信任设置，通过随机公共验证防止任何一方修改或破坏参数。（老师说意义不大 😂）
2. 扩展性（Scalability）：声称 zk-STARK 降低了计算复杂度，生成证明速度比 zk-SNARK 更快。（这点有些争议）
3. 抗量子攻击：zk-STARK 使用抗冲突的哈希函数提高了抵御量子攻击的能力。（老师说意义不大 😂）

![image](/assets/images/eth/layer2-7.png)

### zk-STARK 的缺点
技术成熟度、普及度低，社区、生态发展还处于起步阶段

### zk-STARK 与 EVM 的兼容性
zk-STARK 的另一个问题在于 EVM 的兼容性，zk-STARK 要实现图灵完备就很难与 EVM 兼容。Solidity 要转成 zk-STARK 兼容的格式是很复杂的，
为此设计了编程语言 Cairo。Cairo 目前比较新，会的人少，学习成本高，也不兼容 EVM

![image](/assets/images/eth/layer2-8.png)

### 数据可用性
STARKWARE 提供两种数据可用性方案，有一个叫 Volition 的系统，允许用户自主选择每笔交易是用链上数据可用的 Rollup 方案还是使用链下数据可用的 Validium 方案。
链下数据可用性是由一个中心化的`数据可用性委员会`提供安全保证。`数据可用性委员会`由一些有声望的加密实体组成

![image](/assets/images/eth/layer2-9.png)

# Polygon
Polygon 使用 PoS

## Matic
Polygon 最早叫 Matic
1. 采用 Plasma 扩容方案，Plasma 是以太坊历史上一个流行的方案
2. Plasma 缺点是
* 资金退出异常复杂
* 不兼容 DeFi 智能合约

以太坊扩容方案各有优劣，并不是一家独大，不同的 Rollup 有各自的底层设计和各自的优势，应用场景存在差异性，发展路线和生态部署也各不相同。
而以太坊也是希望各种 Layer2 百花齐放。V 神就公开投了多个 Rollup 项目，这样流动性割裂，不同 Rollup 里的资金怎么做到互联互通？

## Polygon 现在的定位
多种 Layer2 扩容方案的聚合器，提供一个可复操作的网络，为以太坊建设一个模块化通用灵活的扩容框架，允许开发人员利用以太坊安全性创建定制的专注应用程序的链。




