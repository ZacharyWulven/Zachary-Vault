---
layout: post
title: ETH-05-智能合约
date: 2022-08-10 16:45:30.000000000 +09:00
tag: 区块链
---

## 0x01 智能合约状态
智能合约是运行在区块链上的一段代码，代码的逻辑定义了合约的内容

合约账户保存了合约当前的状态
* balance 当前余额
* nonce 交易次数
* code 合约代码
* storage 存储，数据结构是一棵 MPT



## 0x02 Solidity

![](/assets/images/eth/sol.png)

* solidity 是面向对象的是强类型语言
* address 类型是 solidity 特有的
* event 事件是用来打 log 的
* solidity 中哈希表不支持遍历，如果想遍历需要自己记录，比如用一个数组记录
* 数组可以是固定长度也可以是动态改变长度的
* address[1024] 这是一个固定长度为 1024 的数组
* 构造函数仅在合约创建时候调用一次
* payable 表示支持向合约转账，即对于能接收以太币的函数，关键字 payable 是必须的
* 以太坊凡事要接受外部转账的函数都要 什么 payable，否则没有 payable 转钱的话会发生异常
* solidity 哈希表如果 key 值不存在，默认返回 0

## 0x03 合约调用
### 外部账户调用合约

![](/assets/images/eth/sol1.png)

* 给合约转账即对合约的调用，调用的函数在 data 域中说明
* 中间那行是调用参数
* gas used 是交了多少 gas
* gas price 是 gas 单价
* gas limit 是原因花多少 gas 

### 合约直接调用合约 

![](/assets/images/eth/sol2.png)

* 一个交易只能由外部账户发起

### 使用 address 类型的 call 函数调用合约
 
![](/assets/images/eth/addr.png)

{% highlight ruby %}
使用 call 这种调用方式与上边合约直接调用方式错误处理不同，如果调用中出现错误，
1 直接调用合约会回滚追溯到交易发起方，即回滚到最早的函数调用
2 call 方式，只是返回 false 表示当前调用失败，之前的函数不会出现错误，之后的代码可以继续执行
{% endhighlight %}


### 代理调用 delegatecall()
与 call 基本相同，区别是 delegatecall 不需要切换到被调用的合约环境中执行，而是可以在当前合约环境中执行，使用当前合约的余额和存储等

![](/assets/images/eth/delegate.png)


### fallback() 函数

![](/assets/images/eth/fallback.png)

* 也可以认为是一个兜底的函数
* 如果 fallback 函数需要有接收转账的能力的话也需要 payable 

{% highlight ruby %}
如果一个合约所有函数没有带 payable 的说明这个合约没有接收货币的能力，如果调用时候发送钱那么会出现异常
{% endhighlight %}

## 0x04 合约的创建
* 合约写完后需要编译成 bytecode
* 创建发布合约：外部账户发起一个转账交易为 0 的交易到 0x0 的地址
1. 转账金额是 0，但是要支付 gas 费
2. 合约的代码放在 data 域中
* 智能合约运行在 EVM 上，（EVM 寻址空间是 256 位）
* 以太坊是一个交易驱动的状态机：调用智能合约的交易发布到区块链上后，每个矿工都会执行这个交易，从当前状态确定性的转移到下一个状态

## 0x05 错误处理
* 以太坊交易执行具有原子性，一个交易要么全执行，要么不执行，不会只执行一部分
* 为什么到达汽油费上限时候，还没执行完交易，导致回滚汽油费不退？
1. 如果退汽油费的话，可能有 DDoS 攻击，不停的设置低汽油费，反正汽油费会退回，这样对矿工是不友好的

![](/assets/images/eth/error.png)

* assert 用于判断内部条件
* require 用于判断外部条件
* revert()：终止运行并回滚状态变动；无条件的会抛出异常然后回滚；早期版本用的是 throw

* solidity 语言没有 try catch

### 嵌套调用
嵌套调用出现异常时是否有连锁回滚？
* 取决于调用方式，如果是直接调用两一个合约则连锁回滚
* 如果是通过 call 方式调用则不会发生连锁回滚，比如用 call.value 进行转账

另外
* 一个合约直接向另一个合约账户转账，没有指明调用哪个函数，仍然会引起嵌套调用，比如 fallback 函数


## 0x06 汽油费（gas fee）
EVM 中不同指令消耗汽油费是不同的
* 简单指令很便宜，复杂的或需要存储状态的指令就很贵，比如取哈希
* 读取是免费的

![](/assets/images/eth/gas.png)

* accountNonce 就是交易的序号，用于防止 replay attack
* gaslimit 这个交易愿意支付的最大金额
* gasprice 是 gas 单价
这个交易可能消耗的最大汽油费 = gaslimit * gasprice 
* recipient 是收款人的地址
* amount 是转账金额
* payload 就是 data 域，用于存放调用哪个函数，参数等
* 当一个全节点收到对一个合约的调用时，先按交易中给出的 gaslimit 算出可能最大 gas 量，然后一次性从发起交易的账户中扣除掉，
然后在根据实际情况，看实际花了多少汽油费，剩余部分再退给交易发起者，如果汽油费不够则交易回滚，回滚时已经消耗的汽油费不退
* block header 里的 GasLimit 和 GasUsed
1. GasLimit： 跟 gas 相关，即这个区块里所有交易能消耗 gas 的上限，避免发布一个对资源消耗很大的区块
2. GasUsed：跟 gas 相关，即这个区块内所有交易消耗的 gas fee 的合
3. 发布区块时，矿工可根据上一个区块的 GasLimit 进行上下微调 1/1024，虽然看起来小，但以太坊出块速度快，很容易翻翻。
所以这种机制求出的 GasLimit 是所有矿工认为比较合理的 GasLimit 的平均值

## 0x07 问题
1. 如何扣 gas ？即当一个全节点收到对一个合约的调用时，先按交易中给出的 gaslimit 算出可能最大 gas 量，然后一次性从发起交易的账户中扣除掉
* 首先状态树、交易树、收据树都是全节点在本地维护的树
* 全节点收到交易后，在状态树把交易发起方账户里余额减去 gas fee 就行了
* 如果多个全节点收到只不过在全节点本地扣一下而已，之后上链达成共识还是扣一次
* 执行合约执行过程中都是全节点在改本地的数据，只有执行完发布到链上后本地的修改才变成外部可见，才需要外部去共识

2. 先挖矿还是先执行合约的交易？
* 答案是先执行交易
* 因为执行交易完才能得到 block header 中三棵树的根哈希值，然后 block header 内容才能确定，然后才能尝试 nonce

3. 如果先执行交易再挖矿，浪费了我的算力，最后我没有挖到那么，我最后能得到什么?
* 汽油费是不可能了，因为汽油费只给出块的矿工
* 以太坊中没有任何补偿🤣
* 所以挖矿慢的矿工就很吃亏

4. 会不会有的矿工得不到汽油费就不验证交易了？
* 后果是危害区块链系统的安全
* 这个无法跳过验证这个步骤，因为如果不作为。本地数据都是错误的，那以后自己想挖了沿着哪个链挖？再有就是即使挖矿出块，其他全节点是不认的。
只有更新状态才能同步交易信息等，因为出块块头只有那三棵树的根哈希值，没有区块的全部内容，所以需要同步更新状态。
出块时不会把所有内容都发布，因为状态可能是有冗余的，所以以太坊必须同步更新其安全性是有保障的


5. 发布到链上的交易是否都是成功执行的？
* 不是，因为执行失败的要扣汽油费也要同步状态
 
6. 如果知道交易成功执行或失败?

![](/assets/images/eth/receipt.png)

* 收据 receipt 结构中 status 表示交易执行状态

7. 智能合约是否支持多线程？
* 不支持，没有支持多线程的语句
* 因为以太坊是一个交易驱动的状态机，所以交易都需要各个全节点各自执行，对执行结果必须有确定性
* 因为多线程的问题在于，多个核对内存的访问顺序不同的话，执行结果有可能是不确定的
* 除了多线程其他造成执行结果可能不确定的都不支持，比如产生随机数，所以以太坊的合约不支持产生真正意义下的随机数，所以产生的都是伪随机数


## 0x08 智能合约获取信息
* 智能合约不能获得向 systemcall 的一些系统提供的信息，因为各个全节点环境可能不同

### 智能合约可以获得的区块信息

![](/assets/images/eth/c_block.png)

### 智能合约可以获得的调用信息

![](/assets/images/eth/c_call.png)

* msg.sender 是当前调用者
* tx.origin 是最开始的发起者
* msg.gas 即当前这个调用还剩多少汽油费，决定了还能做哪些操作
* msg.data 即完整的 calldata 调用哪个函数以及参数
* msg.sig 是 msg.data 的前 4 个字节，即函数标识符，也就是调用的那个函数
* now 是当前区块时间戳，跟 block.timestamp 是一样的，智能合约无法获得很精确的时间，只能获得跟当前相关的时间

### 地址类型
* 所有合约均可显示转换成地址类型

![](/assets/images/eth/address.png)

* address.balance 是成员变量，其他都是函数，类型为 uint256，以 wei 为单位的地址类型余额
* address.transfer() 向 address 地址转入多少钱
* address.call() 当前合约发起调用，调用 address 的 call

#### 转账三个方法 都可发送 eth
* address.transfer(uint256 amount) 会导致连锁性回滚
* address.send(uint256 amount) returns (bool) 失败时返回 false 不会导致连锁性回滚
* address.call.value(uint256 amount)() 失败时返回 false 不会导致连锁性回滚

区别
* transfer 和 send 给的汽油费很少，除了转账基本干不了别的事
* call 是把当前所有的汽油都发过去

## 0x09 合约例子
![](/assets/images/eth/contract.png)

#### 那么上边代码有什么问题么 ？

![](/assets/images/eth/contract1.png)

{% highlight ruby %}
合约执行时都是改的本地的数据，执行完才发布到链上，然后其他全节点进行验证，验证时也是在自己本地操作，看是否和你发布的一样，一样才达成共识
{% endhighlight %}

所以这样 hack 攻击会导致大家都收不到钱，因为 hack 的合约没实现兜底的 fallback 最终所有人都无法收钱。
这个有点像不可撤销的信托，irrevocable trust。

{% highlight ruby %}
Code is law
如果 合约有 bug 也是改不了的，所以合约部署前一定要测试 测试 再测试，重要的事情说三遍
{% endhighlight %}

这样无解我们来看看第二个版本

### 版本二
为了解决问题我们不使用 for 取钱而是，取钱让用户自己取
![](/assets/images/eth/contract2.png)

这样就可以了么？

### 重入攻击
![](/assets/images/eth/contract3.png)

* 如果一个黑客写了上边的代码，会导致取钱时不停的递归调用取钱方法，那么黑客第一次取的钱是自己的，之后取的都是别人的
* 只有转账函数 msg.sender.call.value(amout) 调用完才会把这个用户的钱设为 0 ，而转账函数已经和黑客函数形成了递归调用，
* 黑客的合约自己实现了 fallback 函数，而 fallback 函数又调用了 withdraw 函数导致递归调用
* 那么黑客这样取钱会持续到什么时候？有三种情况
1. 拍卖合约账户的余额不足了
2. 汽油费消耗不够了，因为每次递归调用也需要消耗 gas
3. 调用栈溢出

{% highlight ruby %}
所以正确的写法是先把用户的钱清零，再转账，即右边给 beneficiary 的写法是对的
即先清零再转账，如果转账失败再把用户余额恢复

合约开发 Tips
1 先判断条件
2 改变条件
3 再跟合约交互

因为区块链上其他合约可能都是有恶意的，所以要想到你调用的合约的函数是否会反向调用你的合约并修改状态
{% endhighlight %}

还有一个方法改进就是不要用 call.value 函数，改用 transfer 或 send，transfer 或 send 好处是给的汽油费很低，不足以让调用的地址再改其他事，
最多也就是打 个 log 🤣

![](/assets/images/eth/contract4.png)
