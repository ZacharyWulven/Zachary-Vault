---
layout: post
title: 信息的表示和处理(二)
date: 2022-04-21 16:45:30.000000000 +09:00
tag: CSAPP
---

### 整数表示
用位来编码整数的两种不同的方式
1. 只能表示非负数（无符号 UMin = 0, UMax = 2^w - 1）
2. 表示负数 0 正数 （补码 TMin = -2^(w - 1), TMax = 2^(w - 1) - 1）

{% highlight ruby %}
负数的取值范围比整数大 1。
唯一一个与机器相关的取值范围的类型是 long ，大多数 64 bit 使用 8 个字节，32 bit 使用 4 个字节。
{% endhighlight %}

### 无符号数编码
B2U 二进制转无符号函数
{% highlight ruby %}
例 1，0001 = 0 * 2^3 + 0 * 2^2 + 0 * 2^1 + 1 *2^0 = 0+0+0+1 = 1
例 2，1111 = 1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 1 *2^0 = 8+4+2+1 = 15

w 位所能表示的范围，如果 w = 4，那么 B2U4 的最大值就是 2^w - 1 = 2^4 - 1, 范围是 0~2^w - 1
{% endhighlight %}

无符号数编码是唯一的，无符号的编码的唯一性通过双射达成，B2U 二进制到无符号函数，U2B 无符号到二进制。

### 补码
使用补码表示负数, 将字的最高有效位解释为负权(negative weight), 函数 B2T
{% highlight ruby %}
例1，1111 = -1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 1 *2^0 = -8+4+2+1 = -1
例2，1011 = -1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 *2^0 = -8+0+2+1 = -5
{% endhighlight %}

最高有效位 x(w-1) 称为符号位，符号位为 1 时候表示值为负，为 0 表示值为非负。
{% highlight ruby %}
补码范围，以 w 位来说 TMin = -2^(w - 1)， 权值为 -2^(w - 1)，
补码的编码的唯一性也是通过双射达成， T2B 是其反函数

补码最大值 TMax = 2^(w - 1) - 1
|TMin| = |TMax| + 1
{% endhighlight %}

许多程序都是假设用补码来表示有符号数的，在 JAVA 中单字节数据类型是 byte 而不是 char。

{% highlight ruby %}
UMax(w) = 2 * TMax(w) + 1
-1 和 Umax 有同样的位表示，即全1 的串，数字 0 在补码和无符号都是全0
{% endhighlight %}


#### 有符号其他两种表示方法反码和原码
* 反码:除最高有效位权重是 -(2^(w - 1) - 1) 而不是 -2^(w - 1), 其他和补码一样
* 原码:最高有效位是符号位

两种方法把 [0...0] 都解释为 0 ，而值 -0 在源码中表示为 [10...0] 在反码中表示为 [11...1]。浮点数中有使用原码编码。


### 有符号数和无符号数之间转换
C 语言允许不同数字类型之间做强制转换，将负数转成无符号可能得到 0，如果无符号太大以至于超出补码能够表示的范围，可能会得到 TMax

{% highlight ruby %}
对大多数 C 语言实现，有符号与无符号之间的转换都是从位级角度来看的，即数值可能改变，但位模式不变。
例如补码 -12345 跟无符号 53191 一样，因为位模式一样。
{% endhighlight %}

#### 补码和无符号关系
无符号 53191 转为补码为 -12345，请注意 53191 + 12345 = 65536 = 2^16

{% highlight ruby %}
无符号中 UMax 有着和补码表示的 -1 相同的位模式。
{% endhighlight %}


#### 补码转无符号
1 + UMax(w) = 2^w, UMax(w) 为无符号 w 位最大值, 通常最大值为 2^w - 1

{% highlight ruby %}
T2U(w)(X) 为无符号的十进制值，w 为位数，x 为补码的十进制数
当 TMin(w) <= x <= TMax(w)，即 x 在补码的最大最小值范围内
T2U(w)(X) = if   x < 0,  x + 2^w
            else x >= 0, x
{% endhighlight %}

#### 无符号转补码
{% highlight ruby %}
U2T(w)(u) 为补码，w 为位数，u 为无符号的十进制数
当 0 <= u <= UMax(w) 即 u 在无符号区间内
U2T(w)(u) = if   u <= TMax(w),  u
            else u >  TMax(w),  u - 2^w
{% endhighlight %}



{% highlight ruby %}
TMax(w) = 2^(w - 1) - 1, UMax(w) = 2^w - 1.
{% endhighlight %}

### C 语言中有符号与无符号数
C 语言支持所有整型数据类型的有符号和无符号运算。尽管 C 语言标准没有指定有符号数要采用某种表示，但几乎所有机器表示有符号都使用补码。
大多数系统遵循的原则是底层的位表示不变。

printf %d 有符号十进制，%u 无符号十进制，%x 十六进制格式输出一个数字。声明无符号 必须后缀 U 或 u 例 12345U。


{% highlight ruby %}
TMin(w) 的无符号 == TMax(w) + 1
如果一个无符号和一个有符号的进行运算，那么 C 语言会隐式的将有符号参数类型转为无符号数。
{% endhighlight %}


#### C 语言中 TMin 写法
{% highlight ruby %}
对 TMax32 定义： #define INT_MAX 2147483647
对 TMin32 定义： #define INT_MIN (-INT_MAX - 1)
{% endhighlight %}

### 扩展一个数字的位
一个常见的运算是在不同字长的整数之间转换，同时保持数值不变。
* 要将无符号转为一个更大的数据类型，只要简单的在表示开头添加 0 这被称为无符号数的零扩展
* 要将补码转为一个更大的数据类型，可以执行一个符号扩展，在表示中添加最高的有效位的值 (类似算术右移)

{% highlight ruby %}
1011，11011，111011 都表示 -5
1011 = -2^3 + 2 + 1 = -5
11011 = -2^4 + 2^3 + 2 + 1 = -5
111011 = -2^5 + 2^4 + 2^3 + 2 + 1 = -5
{% endhighlight %}

Tips:
{% highlight ruby %}
十六进制数字 8 到 F 的最高有效位是 1.
{% endhighlight %}


### 截断数字
如果需要减少表示一个数字的位数，如 int 转 short，将 32 位的 int 截断成 16 位的 short int。
将一个 w 位数截断为 k 位时，我们会丢弃最高的 w-k 位得到 [x(k-1), x(k-2),....x(0)]，截断一个数可能会改变它的值--溢出的一种形式。


#### 截断无符号
从 x''(w 位) = [x(w-1), x(w-2),....x(0)] 截断为 x'(k 位) = [x(k-1), x(k-2),....x(0)]，则 x' = x mod 2^k，
该原理背后所有被截去的位的权重形式都是 2^i，i >= k。


{% highlight ruby %}
公式 B2U(k) = B2U(w) % 2^k, 即直接 mod 2^k
{% endhighlight %}


#### 截断补码 
与无符号相似，只不过最高位要变成符号位。

1. 先转为无符号
2. 再 mod 2^k
3. 最后转为补码

{% highlight ruby %}
公式 B2T(k) = U2T(k)(B2U(w) % 2^k) 
{% endhighlight %}

### 关于无符号和有符号建议
例子1
{% highlight ruby %}
float sum_elements(float a[], unsigned length) {
  int i;
  float result = 0;
  for (i = 0; i <= length - 1; i++) {
    result += a[i];
  }
  return result;
}
{% endhighlight %}
上边代码停止条件是 i <= length - 1 看上去很自然，因为 length 是无符号，所以 0(length)-1 是无符号运算，结果是 UMax，无符号任何数都小于等于 UMax，
所以这个总为真。修改方法有两种 i < length 或 length 类型为补码。

例子2，写一个函数判断一个字符串是否比另一个字符串更长，前提是使用 strlen 函数
{% highlight ruby %}
strlen 定义
size_t strlen(const char *s)

int strlonger(char *s, char *t) {
return strlen(s) - strlen(t) > 0;
}
{% endhighlight %}
上边代码如果 s 比 t 短时候该函数会不正确返回，因为 size_t 为无符号，无符号相减的差为负时会变成一个很大的无符号，且大于零。应该为 strlen(s) > strlen(t)。


#### Summary
* 有符号和无符号的隐式转换，会导致错误或者漏洞，所以避免这种漏洞方式是绝不使用无符号, 语言设计者认为无符号带来的麻烦比收益多。要避免无符号与有符号类型不统一造成的问题。
* 当我们想要把字仅仅看成是位的集合而没有任何数字意义时，无符号是非常有用的。例如往一个字中放入描述各种布尔条件的标记(flag)时。
* 当实现模运算和多精度运算的数学包时，数字由字的数组来表示，无符号的值也是很有用的。
