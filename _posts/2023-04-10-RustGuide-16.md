---
layout: post
title: RustGuide-16
date: 2023-04-10 16:45:30.000000000 +09:00
categories: [Rust]
tags: [Rust]
---

# 19 高级特性

## Unsafe Rust（不安全 Rust）

### 匹配命名变量
* 在 Rust 中隐藏着第二个语音，它没有强制内存安全保证，它就是 Unsafe Rust
* Unsafe Rust 与普通的 Rust 一样，但提供了一些 “超能力”
* Unsafe Rust 存在是因为以下几个原因
1. 静态分析是保守的（即出于安全考虑会错误判断一些情况为不合法），而使用 Unsafe Rust，即告诉编译器我们知道自己在做什么，并承担相应风险
2. 计算机硬件本身就是不安全的，Rust 需要能够进行底层的系统编程，如果不允许 Unsafe Rust 那么这些工作就无法完成了

### Unsafe 超能力
* 可以使用 unsafe 关键字来切换到 Unsafe Rust 模式，它会后边跟着一个代码块，在这个代码块里写的代码就是 unsafe 代码
* Unsafe Rust 里可执行 4 个动作（超能力）
1. 解引用原始指针
2. 调用 unsafe 函数或方法
3. 访问或修改可变的静态变量
4. 实现 unsafe trait

> unsafe 并没有关闭借用检查或停用其他的安全检查措施，如果你在 unsafe 里使用引用，那么这个引用依然会被检查，unsafe 仅仅是让你可以访问上述 4 个特性，所以即便是 unsafe 中你依然会获得一定的安全性，通过把上边 4 种不安全操作约束在 unsafe 代码块中，你就要知道任何内存安全相关的错误必须留在 unsafe 块里，尽可能隔离 unsafe 代码，最后将其封装在安全的抽象里，提供安全的 API。实际上某些标准库就使用了 unsafe 代码，但他们在这之上又提供了安全的抽象接口，因为使用安全的抽象是安全的。
{: .prompt-info }


### 1 解引用原始指针
* 在 Unsafe Rust 里有两种类似于引用的新型指针，它们叫原始指针（或叫裸指针英文是 Raw Pointer）
1. 与引用类似，它要么是可变的，要么是不可变的
2. 可变的，语法是 `*mut T`
3. 不可变的，语法是 `*const T`，意味着指针在解引用之后不能直接对其进行赋值

> 这里 * 不是解引用符号，它是类型名的一部分
{: .prompt-info }


#### 原始指针与引用的区别
1. 原始指针可忽略借用规则，即允许通过同时具有不可变和可变指针或多个指向同一位置的可变指针
2. 原始指针无法保证能指向合理的内存，而引用总是指向合理的内存
3. 原始指针允许为 null
4. 原始指针不实现任何自动清理

* 在放弃这些安全的保证后，就可以换取更好的性能以及与其他语言或硬件接口的能力了

```rust
fn main() {
    let mut num = 5;

    /*
        在 unsafe 代码块之外创建原始指针
        但只能在 unsafe 代码块中对原始指针解引用
    */
    // 将不可变引用转为不可变原始指针，这是一个有效的原始指针
    let r1 = &num as *const i32;

    // 将可变引用转为可变原始指针，这是一个有效的原始指针
    let r2 = &mut num as *mut i32;

    // 对原始指针解引用
    unsafe {
        println!("r1: {}", *r1);
        println!("r2: {}", *r2);   

        // 可以用 r2 修改其值，这需要多加小心
        *r2 = 3; 
        println!("r2: change to {}", *r2);   
    }

    /*
        创建一个无法知道其有效性的原始指针
        原始指针不一定一直有效

        这个内存地址可能有数据，也可能没有数据，这样依然可以创建一个原始指针
        address 可能是无效的
     */
    let address = 0x1245usize;
    let r = address as *const i32;
    // 对原始指针解引用
    unsafe {
        println!("r: {}", *r);
    }

}
```

#### 使用原始指针的原因
1. 与 C 语言进行接口交互
2. 构建借用检查器无法理解的安全抽象


### 2 调用 unsafe 函数或方法
* unsafe 函数或方法，即在它们前边加上了 unsafe 关键字的函数或方法
* 调用它们前需要满足一些条件（主要靠看文档），因为 Rust 无法对这些条件进行验证
* 调用 unsafe 函数或方法，必须在 unsafe 块里调用
* unsafe 函数或方法也属于 unsafe 块

```rust

unsafe fn dangerous() {
    println!("I am dangerous !");
}

fn main() {

    // 调用 Unsafe 函数需要再 Unsafe 块里
    unsafe {
        dangerous();
    }

}
```

#### 创建 unsafe 代码的安全抽象
* 函数包含 unsafe 代码并不意味着需要将整个函数标记为 unsafe
* 将 unsafe 代码包裹在安全函数中是一种常见的抽象

下边代码让我们看看标准库提供 split_at_mut 函数是如何实现的

```rust
/*
    简单定义 split_at_mut 看看其实现的原理
 */
// fn split_at_mut_demo(slice: &mut [i32], mid: usize) 
// -> (&mut [i32], &mut [i32]) {
//     let len = slice.len();

//     assert!(mid <= len);
//     // 这里报错，因为违反了借用规则, 修正需要使用 unsafe code
//     (&mut slice[..mid], &mut slice[mid..])
// }


/*
    自己实现 split_at_mut 
    
    使用 unsafe 代码修正 split_at_mut_demo
    split_at_mut 里使用了 unsafe 代码，但是其函数
    本身没有标记为 unsafe 所以 split_at_mut 就是一个
    unsafe 安全抽象，我们就可以从安全的代码中对其进行调用
 */
fn split_at_mut(slice: &mut [i32], mid: usize) 
-> (&mut [i32], &mut [i32]) {
    let len = slice.len();
    assert!(mid <= len);
    /*
        这里返回一个原始指针，它的类型是 *mut i32
        它指向这个切片
     */
    let ptr = slice.as_mut_ptr();

    unsafe {
        /*
            from_raw_parts_mut 接收一个原始指针和一个长度来创建切片
            ptr.add(mid) 获得以 mid 为偏移量的原始指针
         */
        (slice::from_raw_parts_mut(ptr, mid),
        slice::from_raw_parts_mut(ptr.add(mid), len - mid)
        )
    }

}

fn main() {
    let mut v = vec![1, 2, 3, 4, 5, 6];
    // r 是 v 的完整的 slice
    let r = &mut v[..];
    /*
        标准库提供 split_at_mut 函数，
        将参数 index 为界限，
        分隔成两个切片
        split_at_mut 实际是使用了不安全的代码
     */
    let (a, b) = split_at_mut(r, 3);
    //let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &mut [1, 2, 3]);
    assert_eq!(b, &mut [4, 5, 6]); 
}
```


```rust
fn main() {
    println!("test_address");
    let address = 0x12345usize;
    let r = address as *mut i32;
    // 这样可能 crash 因为无法保证拥有 10000 元素的切片是有效的
    let slice: &[i32] = unsafe {
        slice::from_raw_parts_mut(r, 10000)
    }; 
}
```

### 使用 extern 函数调用外部代码
* extern 关键字可以简化创建和使用外部函数接口（FFI）的过程
* 外部函数接口（FFI，Foreign Function Interface），它允许一种编程语言定义函数，并让其他的编程语言能调用这些函数

> 任何在 `extern` 块里声明的函数都是不安全的，因为其他语言并不会遵守 Rust 的规则，而 Rust 又无法对他们进行检查
{: .prompt-info }

所以在调用外部函数时的安全问题落在了开发者身上


```rust
/*
    extern "C" 块内的函数签名就是我们想调用的外部函数的签名
    而 "C" 指明了外部函数使用的是应用程序二进制接口（ABI），
    ABI 是用于定义在汇编层面的调用方式的
 */ 
extern "C" {
    fn abs(input:i32) -> i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}
```

* ABI 是用于定义在汇编层面的调用方式的
* "C" ABI 是最常见的，它遵循 C 语言的 ABI

### 从其他语言来调用 Rust 函数
* 可以使用 extern 关键字来创建接口，其他语言通过它们可以调用 Rust 函数
* 在 `fn` 前边添加 `extern` 关键字，并指定对应的 ABI。并且还需要添加 `#[no_mangle]` 注解，避免 Rust 在编译时改变它的名称
1. mangle 实际对应编译的一个阶段，在这个阶段编译器会修改函数的名称从而让其包含更多可用于后续编译的信息，这些改变后的名称通常是难以阅读的

```rust
// 这个函数在编译链接后就可以被 C 语言访问了
// 这类的 extern 功能不需要使用 unsafe

#[no_mangle]
pub extern "C" fn call_from_c() {
    println!("Just call a rust function from C!");
}
```

### 3. 访问或修改一个可变的静态变量
* Rust 支持全局变量，但因为所有权机制可能产生某些问题，例如数据竞争
* 在 Rust 中全局变量叫静态（static）变量


```rust
/*
    命名规范大写，声明时需要标识类型
    静态变量只能存储拥有 'static 这个生命周期的引用
    这就意味着 Rust 可以自己推断出其生命周期
    所以就无需手动标注了

 */
static HELLO_WORLD: &str = "Hello, world!";
fn main() {
    println!("name is {}", HELLO_WORLD);
}
```

#### 静态变量
* 静态变量与常量类似
* 命名规范是大写的 SCREAMING_SNAKE_CASE
* 声明时候必须标注类型
* 静态变量只能存储 `'static` 生命周期的引用，无需显示标注，因为可以推断出来
* 访问不可变的静态变量是安全的

#### 常量和不可变静态变量的区别
* 静态变量：有固定的内存地址，使用它的值总会访问同样的数据
* 常量：允许使用它们的时候对数据进行复制
* 静态变量：是可以改变的，访问和修改可变的静态变量是不安全（unsafe）的操作

```rust
static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    // 访问和修改可变的静态变量是不安全（unsafe）的操作
    // 所以这里放到 unsafe 块里进行操作
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
}
```

### 4. 实现 unsafe trait
* 当某个 trait 中存在至少一个方法拥有编译器无法校验的不安全因素时，就称这个 trait 是不安全的
* 声明不安全的 trait：即在 trait 前加 unsafe 关键字
1. 该 trait 只能在 unsafe 代码块中实现

```rust
unsafe trait Foo {
    // methods go here
}

// 在 unsafe 代码块中实现
unsafe impl Foo for i32 {
    // method implementations go here
}
```

### 何时使用 unsafe 代码
* 编译器无法保证内存安全，让开发者保证 unsafe 代码正确并不是一个简单活儿
* 但又充足理由使用 unsafe 代码时，就可以使用
* 通过显示标记的 unsafe，可以在出现问题时轻松定位


## 高级 Trait

### 在 trait 的定义中使用关联类型来指定占位类型
* 关联类型（associated type）是 trait 中类型的占位符，它可以用在 trait 的方法签名中
1. 即可以定义出包含某些类型的 trait，而在实现前无需知道这些类型具体是什么
2. swift 也有这个特性啊 





## 高级类型

## 高级函数和闭包

## 宏


