---
layout: post
title: RustGuide-16
date: 2023-04-10 16:45:30.000000000 +09:00
categories: [Rust]
tags: [Rust]
---

# 19 高级特性

## Unsafe Rust（不安全 Rust）

### 匹配命名变量
* 在 Rust 中隐藏着第二个语音，它没有强制内存安全保证，它就是 Unsafe Rust
* Unsafe Rust 与普通的 Rust 一样，但提供了一些 “超能力”
* Unsafe Rust 存在是因为以下几个原因
1. 静态分析是保守的（即出于安全考虑会错误判断一些情况为不合法），而使用 Unsafe Rust，即告诉编译器我们知道自己在做什么，并承担相应风险
2. 计算机硬件本身就是不安全的，Rust 需要能够进行底层的系统编程，如果不允许 Unsafe Rust 那么这些工作就无法完成了

### Unsafe 超能力
* 可以使用 unsafe 关键字来切换到 Unsafe Rust 模式，它会后边跟着一个代码块，在这个代码块里写的代码就是 unsafe 代码
* Unsafe Rust 里可执行 4 个动作（超能力）
1. 解引用原始指针
2. 调用 unsafe 函数或方法
3. 访问或修改可变的静态变量
4. 实现 unsafe trait

> unsafe 并没有关闭借用检查或停用其他的安全检查措施，如果你在 unsafe 里使用引用，那么这个引用依然会被检查，unsafe 仅仅是让你可以访问上述 4 个特性，所以即便是 unsafe 中你依然会获得一定的安全性，通过把上边 4 种不安全操作约束在 unsafe 代码块中，你就要知道任何内存安全相关的错误必须留在 unsafe 块里，尽可能隔离 unsafe 代码，最后将其封装在安全的抽象里，提供安全的 API。实际上某些标准库就使用了 unsafe 代码，但他们在这之上又提供了安全的抽象接口，因为使用安全的抽象是安全的。
{: .prompt-info }


### 1 解引用原始指针
* 在 Unsafe Rust 里有两种类似于引用的新型指针，它们叫原始指针（或叫裸指针英文是 Raw Pointer）
1. 与引用类似，它要么是可变的，要么是不可变的
2. 可变的，语法是 `*mut T`
3. 不可变的，语法是 `*const T`，意味着指针在解引用之后不能直接对其进行赋值

> 这里 * 不是解引用符号，它是类型名的一部分
{: .prompt-info }


#### 原始指针与引用的区别
1. 原始指针可忽略借用规则，即允许通过同时具有不可变和可变指针或多个指向同一位置的可变指针
2. 原始指针无法保证能指向合理的内存，而引用总是指向合理的内存
3. 原始指针允许为 null
4. 原始指针不实现任何自动清理

* 在放弃这些安全的保证后，就可以换取更好的性能以及与其他语言或硬件接口的能力了

```rust
fn main() {
    let mut num = 5;

    /*
        在 unsafe 代码块之外创建原始指针
        但只能在 unsafe 代码块中对原始指针解引用
    */
    // 将不可变引用转为不可变原始指针，这是一个有效的原始指针
    let r1 = &num as *const i32;

    // 将可变引用转为可变原始指针，这是一个有效的原始指针
    let r2 = &mut num as *mut i32;

    // 对原始指针解引用
    unsafe {
        println!("r1: {}", *r1);
        println!("r2: {}", *r2);   

        // 可以用 r2 修改其值，这需要多加小心
        *r2 = 3; 
        println!("r2: change to {}", *r2);   
    }

    /*
        创建一个无法知道其有效性的原始指针
        原始指针不一定一直有效

        这个内存地址可能有数据，也可能没有数据，这样依然可以创建一个原始指针
        address 可能是无效的
     */
    let address = 0x1245usize;
    let r = address as *const i32;
    // 对原始指针解引用
    unsafe {
        println!("r: {}", *r);
    }

}
```

#### 使用原始指针的原因
1. 与 C 语言进行接口交互
2. 构建借用检查器无法理解的安全抽象


### 2 调用 unsafe 函数或方法
* unsafe 函数或方法，即在它们前边加上了 unsafe 关键字的函数或方法
* 调用它们前需要满足一些条件（主要靠看文档），因为 Rust 无法对这些条件进行验证
* 调用 unsafe 函数或方法，必须在 unsafe 块里调用
* unsafe 函数或方法也属于 unsafe 块

```rust

unsafe fn dangerous() {
    println!("I am dangerous !");
}

fn main() {

    // 调用 Unsafe 函数需要再 Unsafe 块里
    unsafe {
        dangerous();
    }

}
```

#### 创建 unsafe 代码的安全抽象
* 函数包含 unsafe 代码并不意味着需要将整个函数标记为 unsafe
* 将 unsafe 代码包裹在安全函数中是一种常见的抽象

下边代码让我们看看标准库提供 split_at_mut 函数是如何实现的

```rust
/*
    简单定义 split_at_mut 看看其实现的原理
 */
// fn split_at_mut_demo(slice: &mut [i32], mid: usize) 
// -> (&mut [i32], &mut [i32]) {
//     let len = slice.len();

//     assert!(mid <= len);
//     // 这里报错，因为违反了借用规则, 修正需要使用 unsafe code
//     (&mut slice[..mid], &mut slice[mid..])
// }


/*
    自己实现 split_at_mut 
    
    使用 unsafe 代码修正 split_at_mut_demo
    split_at_mut 里使用了 unsafe 代码，但是其函数
    本身没有标记为 unsafe 所以 split_at_mut 就是一个
    unsafe 安全抽象，我们就可以从安全的代码中对其进行调用
 */
fn split_at_mut(slice: &mut [i32], mid: usize) 
-> (&mut [i32], &mut [i32]) {
    let len = slice.len();
    assert!(mid <= len);
    /*
        这里返回一个原始指针，它的类型是 *mut i32
        它指向这个切片
     */
    let ptr = slice.as_mut_ptr();

    unsafe {
        /*
            from_raw_parts_mut 接收一个原始指针和一个长度来创建切片
            ptr.add(mid) 获得以 mid 为偏移量的原始指针
         */
        (slice::from_raw_parts_mut(ptr, mid),
        slice::from_raw_parts_mut(ptr.add(mid), len - mid)
        )
    }

}

fn main() {
    let mut v = vec![1, 2, 3, 4, 5, 6];
    // r 是 v 的完整的 slice
    let r = &mut v[..];
    /*
        标准库提供 split_at_mut 函数，
        将参数 index 为界限，
        分隔成两个切片
        split_at_mut 实际是使用了不安全的代码
     */
    let (a, b) = split_at_mut(r, 3);
    //let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &mut [1, 2, 3]);
    assert_eq!(b, &mut [4, 5, 6]); 
}
```


```rust
fn main() {
    println!("test_address");
    let address = 0x12345usize;
    let r = address as *mut i32;
    // 这样可能 crash 因为无法保证拥有 10000 元素的切片是有效的
    let slice: &[i32] = unsafe {
        slice::from_raw_parts_mut(r, 10000)
    }; 
}
```

### 使用 extern 函数调用外部代码
* extern 关键字可以简化创建和使用外部函数接口（FFI）的过程
* 外部函数接口（FFI，Foreign Function Interface），它允许一种编程语言定义函数，并让其他的编程语言能调用这些函数

> 任何在 `extern` 块里声明的函数都是不安全的，因为其他语言并不会遵守 Rust 的规则，而 Rust 又无法对他们进行检查
{: .prompt-info }

所以在调用外部函数时的安全问题落在了开发者身上


```rust
/*
    extern "C" 块内的函数签名就是我们想调用的外部函数的签名
    而 "C" 指明了外部函数使用的是应用程序二进制接口（ABI），
    ABI 是用于定义在汇编层面的调用方式的
 */ 
extern "C" {
    fn abs(input:i32) -> i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}
```

* ABI 是用于定义在汇编层面的调用方式的
* "C" ABI 是最常见的，它遵循 C 语言的 ABI

### 从其他语言来调用 Rust 函数
* 可以使用 extern 关键字来创建接口，其他语言通过它们可以调用 Rust 函数
* 在 `fn` 前边添加 `extern` 关键字，并指定对应的 ABI。并且还需要添加 `#[no_mangle]` 注解，避免 Rust 在编译时改变它的名称
1. mangle 实际对应编译的一个阶段，在这个阶段编译器会修改函数的名称从而让其包含更多可用于后续编译的信息，这些改变后的名称通常是难以阅读的

```rust
// 这个函数在编译链接后就可以被 C 语言访问了
// 这类的 extern 功能不需要使用 unsafe

#[no_mangle]
pub extern "C" fn call_from_c() {
    println!("Just call a rust function from C!");
}
```

### 3. 访问或修改一个可变的静态变量
* Rust 支持全局变量，但因为所有权机制可能产生某些问题，例如数据竞争
* 在 Rust 中全局变量叫静态（static）变量


```rust
/*
    命名规范大写，声明时需要标识类型
    静态变量只能存储拥有 'static 这个生命周期的引用
    这就意味着 Rust 可以自己推断出其生命周期
    所以就无需手动标注了

 */
static HELLO_WORLD: &str = "Hello, world!";
fn main() {
    println!("name is {}", HELLO_WORLD);
}
```

#### 静态变量
* 静态变量与常量类似
* 命名规范是大写的 SCREAMING_SNAKE_CASE
* 声明时候必须标注类型
* 静态变量只能存储 `'static` 生命周期的引用，无需显示标注，因为可以推断出来
* 访问不可变的静态变量是安全的

#### 常量和不可变静态变量的区别
* 静态变量：有固定的内存地址，使用它的值总会访问同样的数据
* 常量：允许使用它们的时候对数据进行复制
* 静态变量：是可以改变的，访问和修改可变的静态变量是不安全（unsafe）的操作

```rust
static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    // 访问和修改可变的静态变量是不安全（unsafe）的操作
    // 所以这里放到 unsafe 块里进行操作
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
}
```

### 4. 实现 unsafe trait
* 当某个 trait 中存在至少一个方法拥有编译器无法校验的不安全因素时，就称这个 trait 是不安全的
* 声明不安全的 trait：即在 trait 前加 unsafe 关键字
1. 该 trait 只能在 unsafe 代码块中实现

```rust
unsafe trait Foo {
    // methods go here
}

// 在 unsafe 代码块中实现
unsafe impl Foo for i32 {
    // method implementations go here
}
```

### 何时使用 unsafe 代码
* 编译器无法保证内存安全，让开发者保证 unsafe 代码正确并不是一个简单活儿
* 但又充足理由使用 unsafe 代码时，就可以使用
* 通过显示标记的 unsafe，可以在出现问题时轻松定位


## 高级 Trait

### 在 trait 的定义中使用关联类型来指定占位类型
* 关联类型（associated type）是 trait 中类型的占位符，它可以用在 trait 的方法签名中
1. 即可以定义出包含某些类型的 trait，而在实现前无需知道这些类型具体是什么
2. swift 也有这个特性 

* 标准库的 Iterator 就使用了 associated type
```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```

### 关联类型与泛型的区别
* 泛型
1. 每次实现 trait 时必须标注具体的类型
2. 可以为一个类型多次实现某个 trait（即使用不同的泛型参数）

```rust
pub trait Iterator2<T> {
    fn next(&mut self) -> Option<T>;
}

struct Counter {

}

//多次实现某个 Iterator2 trait for String
impl Iterator2<String> for Counter {
    fn next(&mut self) -> Option<String> {
        None
    }
}

//多次实现某个 Iterator2 trait for u32
impl Iterator2<u32> for Counter {
    fn next(&mut self) -> Option<u32> {
        None
    }
}
```

* 关联类型
1. 在使用 trait 时，无需标注类型，但需要在里边指明关联的类型
2. 无法为单个类型多次实现某个 trait


```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}

struct Counter {

}

impl Iterator for Counter {
    type Item = u32;
    fn next(&mut self) -> Option<Self::Item> {
        None
    }
}
```

> 这个 Iterator trait 只能为 Counter 类型实现一次，多次会报错
{: .prompt-info }


### 默认泛型参数和运算符重载
* 可以在使用泛型参数时为泛型指定一个默认的具体类型
* 语法：`<PlaceholderType=ConcreteType>`，ConcreteType 就是默认的类型
* 这种技术常用于运算符重载（operator overloading）

> 虽然 Rust 不允许创建自己的运算符以及重载任意的运算符。但可以通过实现 `std::ops` 中列出的那些 trait 来重载一部分相应的运算符
{: .prompt-info }


这里重载了 `+` 运算符
```rust
use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, rhs: Self) -> Self::Output {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

fn main() {

    assert_eq!(Point { x: 1, y: 0} + Point { x: 2, y: 3},
               Point {x: 3,y: 3});
    println!("point add");
}
```

* `pub trait Add<Rhs = Self>`，Add 这里就使用了默认的泛型参数类型，即如果在使用 trait 时没有指定默认泛型参数类型则使用 Self 作为默认类型，
所以上边代码中 Self 就是 Point


#### 自己指定默认泛型参数类型

* 为 Millimeters 实现 Add trait，让毫米与米可以相加

```rust
use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

// 这里指定默认的泛型参数为 Meters
impl Add<Meters> for Millimeters {
    type Output = Millimeters;

    fn add(self, rhs: Meters) -> Self::Output {
        Millimeters(self.0 + (rhs.0 * 1000)) 
    }
}
```

#### 默认泛型参数的应用场景
* 扩展一个类型而不破坏现有的代码
* 允许在大部分用户都不需要的特定场景下进行自定义
1. 上边 Millimeters 和 Meters 的例子就属于自定义


### 完全限定语法（Fully Qualified Syntax）如何调用同名方法

```rust
trait Pilot {
    fn fly(&self);
}

trait Wizard {
    fn fly(&self);
}

struct Human;

impl Pilot for Human {
    fn fly(&self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&self) {
        println!("Human's fly");
    }
}

fn main() {
    let person = Human;
    person.fly();

    // 调用 Human 的 Pilot 实现
    Pilot::fly(&person);
    
    Wizard::fly(&person);
}
```

* 上边代码比较简单调用没有问题

```rust
trait Animal {
    fn baby_name() -> String;
}

struct Dog;

impl Dog {
    fn baby_name() -> String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -> String {
        String::from("puppy")
    }
}

fn test_dog() {
    println!("A baby dog is called a {}", Dog::baby_name());

    // 这样就会报错，因为无法知道使用哪个类型的 Animal 实现
    println!("A baby dog is called a {}", Animal::baby_name());
}
```

* 上边代码调用 `Animal::baby_name()` 就会报错，因为无法知道使用哪个类型的 Animal 实现
* 这时可以使用完全限定语法了

#### 完全限定语法
* 格式：`<Type as Trait>::function(receiver_if_method, netx_arg, ...);`
1. receiver_if_method 是接收者
2. netx_arg 是函数参数

* 这种语法可以在任何调用函数或方法的地方使用
* 并且它允许忽略那些从其他上下文能推导出来的部分
* 只有当 Rust 无法区分你期望调用哪个具体实现的时候，才需要使用这种语法。因为这种语法写起来比较麻烦 😅

* 改成 `<Dog as Animal>::baby_name()` 就可以了

```rust
println!("A baby dog is called a {}", <Dog as Animal>::baby_name());
```

### 使用 supertrait 来要求 trait 附带其他 trait 的功能
* 就是一个 trait 继承另外一个 trait
* 有时需要在一个 trait 中使用其他 trait 的功能
1. 即需要那个间接被依赖的 trait 也被实现

> 那个被间接依赖的 trait 就是当前 trait 的 supertrait
{: .prompt-info }

```rust
use std::fmt;

trait OutlinePrint: fmt:: Display {
    fn outline_print(&self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {} *", output);
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}

struct Point {
    x: i32,
    y: i32,
}

impl fmt::Display for Point  {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
```

### 使用 `newtype` 模式在外部类型上实现外部 trait
* 孤儿规则：只有当 trait 或类型定义在本地的包内时，才能为该类型实现这个 trait
* 但是我们可以通过 `newtype` 模式来绕过孤儿规则
1. 即利用 tuple struct（元组结构体）创建一个新的类型


```rust
use std::fmt;
/*
    我们想为 Vec 实现 Display 这个 trait
    而 Vec 和 Display 都定义在外部的包中，
    所以我们无法直接为 Vec 实现 Display 这个 trait

    那么怎么做呢？
    我们可以把 Vec 包裹在 struct Wrapper 中
 */
// 包裹 Vec 以便实现 Display trait
struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        /*
            因为 Wrapper 是一个 tuple struct 可以通过索引将 Vec 取出
         */
        write!(f, "[{}]", self.0.join(", "))
    }
}
```

## 高级类型

### 1 使用 `newtype` 模式实现类型安全和抽象
* `newtype` 模式的作用：
1. 可用于静态的保证各种值之间不会混淆并表明值的单位
2. 为类型的某些细节提供抽象能力
3. 可通过轻量级的封装来隐藏内部实现细节

### 2 使用类型别名来创建类型同义词
* Rust 提供了类型别名的功能
1. 可以为现有类型生产另外的名称（同义词）
2. 这个类型的别名并不是一个独立的类型

* 使用 type 关键字创建类型别名
* 别名的主要用途就是减少代码的字符重复

```rust
use std::fmt;

// 类型别名 1
type Kilometers = i32;


// 类型别名 2
type Thunk = Box<dyn Fn() + Send + 'static>;

fn take_long_type(f: Thunk) {

}

fn return_long_type() -> Thunk {
    Box::new(|| println!("hi"))
}

// 类型别名 3

// 由于这个声明在 use std::io::Error 中所以这里需要注释
//type Result<T> = Result<T, std::io::Error>;

// 可以再别名一次，以便直接使用 Result<T>
type Result<T> = std::io::Result<T>;

pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize>;

    fn flush(&mut self) -> Result<()>;

    fn write_all(&mut self, buf: &[u8]) -> Result<()>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;

}

fn main() {
    let x: i32 = 5;
    let y: Kilometers = 5;
    println!("x + y = {}", x + y);

    //-----------
    let f: Thunk = Box::new(|| println!("hi"));
}
```

### 3 Never 类型
* 有一个名为 ! 的特殊类型
1. 它没有任何值，行话称为空类型（empty type）

* 我们倾向于叫它 never 类型，因为它在不返回值的函数中充当返回类型
* 不返回值的函数也被称作叫发散函数（diverging function）

```rust
// 这个函数表示返回 Never 类型
// 这里报错，什么不写返回的是 `()`

// mismatched types
// expected type `!`
// found unit type `()`
fn bar() -> ! {

}
```



## 高级函数和闭包

## 宏


