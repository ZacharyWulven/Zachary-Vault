---
layout: post
title: RustGuide-05
date: 2023-03-17 16:45:30.000000000 +09:00
categories: [Rust]
tags: [Rust]
---

# 8 常用的集合

## 本章集合不同于数组和元组，它们执行 Heap 上的数据

## Vector
* 写法 `Vec<T>`
* 由标准库提供，可存储多个值，而且只能存储相同类型数据
* 这些值在内存中是连续存放的

### 创建 Vector
* Vec::new()


```rust
    /*
        虽然 Rust 有类型推断
        但 new 返回空数组，无法推断类型，所以这里需要显示声明类型
        Vec 里可以存任意类型
     */ 
    let v: Vec<i32> = Vec::new();
    println!("{:?}", v);

```

### 使用初始值创建 Vector，使用 vec! 宏


```rust
    let v2 = vec![1,2,3];
    println!("{:?}", v2);
```


### 更新 Vector 

```rust
    let mut v3 = Vec::new();
    // 使用 push 添加元素
    v3.push(1); 
```

### 删除 Vector
* 与任何其他 struct 一样，当 Vector 离开作用域后
1. 它就被清理了
2. 它的所有元素也被清理了

### 读取 Vector 里的元素
* 两种方式可以引用 Vector 的值
1. 索引
2. get 方法


```rust
    let v4 = vec![1,2,3,4,5];
    let third = &v4[2];  // 使用索引方式访问，如果索引越界程序会 panic

    println!("The third element is {}", third);

    /*
        使用 get 方法访问
        get 方法参数是 索引，返回 Option<T>，所以可以使用 match
        如果索引越界，则 get 方法返回 None
     */
    match v4.get(100) { 
        Some(third) => println!("The third element is {}", third),
        None => println!("No third element"),
    }
```


> 使用索引访问，如果索引越界程序会 panic。使用 get 方法访问，如果索引越界，则 get 方法返回 None。
{: .prompt-info }



### 所有权和借用规则
* 不能在同一作用域内同时拥有可变和不可变的引用

```rust
    let mut v5 = vec![1, 2, 3, 4, 5];
    let first = &v5[0];  // 这里 first 是不可变的借用, 引用其第一个元素
    
    // 如果这行可以的话，可能造成 v5 容量不够而重新分配内存，导致 first 还指向原来的位置，这样就有问题了
    //v5.push(6);   // 可以变借用, 这里报错, 因为已经借用为 first 不可变的了 
    
    println!("The first element is {}", first);
```


### 遍历 Vector 中的值

```rust
    // 遍历 vector
    let mut v6 = vec![100, 32, 57];
    for i in &mut v6 {
        // *i 为解引用操作
        *i += 50;
    }
    println!("v6 {:?}", v6);
```

