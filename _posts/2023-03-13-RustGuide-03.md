---
layout: post
title: RustGuide-03
date: 2023-03-13 16:45:30.000000000 +09:00
categories: [Rust]
tags: [Rust]
---

# 5 Struct

## 定义并实例化 struct
* 使用 struct 关键字
* 花括号内，为所有字段（Field）定义名称和类型
* 实例化
1. 为每个字段指定具体的值
2. 无需按声明的顺序指定

```rust
struct User {
    name: String,
    email: String,
    sign_in_count: u64,
    active: bool, 
}

// 字段顺序可以不一样
// 这种方式实例化，如果少字段没有赋值 会报错
let user = User {
    email: String::from("tom@gmail.com"),
    sign_in_count: 42,
    name: String::from("tom"),
    active: true,
};
```

* 获取值与赋值

```rust
    let mut user = User {
        email: String::from("tom@gmail.com"),
        sign_in_count: 42,
        name: String::from("tom"),
        active: true,
    };
    println!("{}", user.email);
    
    // 这里赋值必须 user 是可变的，要加 mut
    user.email = String::from("zack@gmail.com");

    println!("{}", user.email);
```

> 一旦一个 struct 实例时可变的，那么它的所有字段就都是可变的
{: .prompt-info }


* struct 作为返回值

```rust
fn build_user(name: String, email: String) -> User {
    User {
        email: email,
        sign_in_count: 42,
        name: name,
        active: true,
    }
}
```

* 字段初始化简写
1. 当字段名称与字段值对应的变量名相同时，就可以使用字段初始化简写方式

```rust
fn easy_build_user(name: String, email: String) -> User {
    User {
        email,  // 简写
        sign_in_count: 42,
        name,
        active: true,
    }
}
```

* struct 更新语法
1. 即你想基于某个 struct 实例来创建一个新实例的时候，可以使用 struct 更新语法
2. 下例 u2 的除 name 和 email 字段，其他字段都使用 u1 的值

```rust
    let u1 = easy_build_user(String::from("jack"), String::from("jack@gmail.com"));
    println!("{}", u1.email);

    let u2 = User {
        email: String::from("u2@gmail.com"),
        name: String::from("u2"),
        ..u1    // 注意这里没有逗号 ,
    };
    println!("{}", u2.email);
```

## Tuple Struct
* 类似 Tuple 的 Struct
* Tuple Struct 整体有个名，但里边的元素没有名
* 适用场景：想给一个 Tuple 整个起个名称，并让他不同于其他 Tuple，而且又不需要给每个元素起名
* 定义 Tuple Struct

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn test_tuple_sturct() {
    let black = Color(0, 0, 0);

    let origin = Point(0,0,0);

    // Note：black 与 origin 是不同类型，因为是不同的 tuple struct 的实例
    println!("{}", black.0);
}
```
## Unit-Like Struct（没有任何字段）
* 在 Rust 里可以定义没有任何字段的 struct，叫做 Unit-Like Struct 
* 适用场景：需要在某个类型上实现某个 trait，但是在里面又没有想要存储的数据


## struct 数据的所有权
* 以 User 为例
1. name 和 email 的类型是 String 而不是 &str，相当于持有对 name 和 email 的所有权
2. 而其他俩字段是标量类型，所以 User 就拥有对其所有字段的所有权，即 User 的实例拥有其所有数据
3. 只有 User 实例有效，那么里边的字段数据也是有效的

* 但 struct 里的字段也可以是引用，这需要生命周期
1. 生命周期可以保证只有 struct 实例时有效的，那么里边的引用也是有效的
2. 否则，如果 struct 里存储的是引用，而不是使用生命周期的话，就行报错


```rust
struct User {
    name: String,
    email: String,
    sign_in_count: u64,
    active: bool, 
}

// 使用 slice（引用）定义 User
struct User {
    name: &str,    // 这样会报错，因为没有指定生命周期，生命周期后边讲
    email: &str,
    sign_in_count: u64,
    active: bool, 
}
```

## struct 例子
```rust

fn main() {
    let w = 30;
    let l = 50;
    println!("area = {}", area(w, l));

    // 使用元组
    let rect = (30, 50);
    println!("area = {}", area_tuple(rect));

    // 使用 struct，最优方案，语义明确
    let rectangle = Rectangle{width: 30,  length: 50};
    println!("area = {}", area_struct(&rectangle));

    // 
    /*
        {} 告诉 println! 使用 Display trait 格式化
        而有些类型没有实现 Display trait 就会报错 
        如果修复
        方式一：可以使用 {:?}, 但需要在 struct 定义上一行声明 #[derive(Debug)]
        #[derive(Debug)] 是让 struct 选择 Debug 功能
        方式二：使用 {:#?} 
         
     */
    println!("{:#?}", rectangle);

}

fn area(width: u32, length: u32) -> u32 {
    width * length
}

fn area_tuple(dim: (u32, u32)) -> u32 {
    dim.0 * dim.1
}

// derive 是派生的意思
#[derive(Debug)] // 意思是让 Rectangle 派生于 Debug 这个 trait
struct Rectangle {
    width: u32,
    length: u32, 
}
// 传递引用，不获取其所有权
fn area_struct(rect: &Rectangle) -> u32 {
    rect.width * rect.length
}

```

### println! 这宏的格式化方法有多种
* std::fmt::Display 即 println!("{}", black.0)
* std::fmt::Debug 即 #[derive(Debug)]，println!("{:#?}", rectangle)
* #[derive(Debug)] 模式下格式化方式 "{:?}" 和 "{:#?}"（这样会格式化一下可读性更高）

## struct 方法 
* 方法与函数不同之处
1. 方法是在 struct 或 enum 或 trait 对象的上下文中定义的
2. 方法的第一个参数总是 `self`，表示方法被调用的 struct 实例，即正在调用 struct 这个方法的实例

### 如何定义方法
* 定义方法需要在 impl 块里定义
* 方法的第一个参数可以是 &self，也可以 self（获得其所有权）或 &mut self（可变借用），和其他参数一样

## 方法调用的运算符
* Rust 没有 -> 运算符
* Rust 会自动引用或解引用，在调用方法时就会发生这种行为
* 在调用方法时，Rust 根据情况自动添加 &、&mut 或 *，以便 object 可以匹配方法签名
* 下边代码效果相同
1. p1.distance(&p2)
2. (&p1).distance(&p2)

* 方法可以有多个参数

## 关联函数
* 可以在 impl 块里定义不把 self 作为第一个参数的函数，它们叫关联函数（不是方法），类似静态方法或叫类方法
1. 例如 String::from("hello")

* 关联函数通常用于构造器
* :: 符号
1. 用于关联函数
2. 用于 Module 创建的命名空间


## 多个 impl 块
* 每个 struct 允许拥有多个 impl 块

```rust
fn main() {
    let rectangle = Rectangle{width: 30,  length: 50};

    println!("rectangle.area {}", rectangle.area());

    // 调用关联函数
    println!("{:#?}", Rectangle::square(30));
}

// derive 是派生的意思
#[derive(Debug)] // 意思是让 Rectangle 派生于 Debug 这个 trait
struct Rectangle {
    width: u32,
    length: u32, 
}

// 为 struct 定义方法需要 impl 块
impl  Rectangle  {
    // self 就是 Rectangle 类型
    fn area(&self) -> u32 {
        self.width * self.length
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.length > other.length
    }

}

impl Rectangle {
    // 这是一个关联函数
    fn square(width: u32) -> Rectangle {
        Rectangle { width, length: width }
    }

}
```

# 6 枚举与模式匹配

## 定义枚举

```rust
fn main() {

    /*
        创建一个枚举值
        枚举的变体（枚举值）都位于标识符的命名空间下，使用两个冒号进行分隔
     */
    let four = IPAddrKind::V4;
    let six = IPAddrKind::V6;
    println!("{:#?}", four);


    let local = IPAddress {
        kind: IPAddrKind::V4,
        address: String::from("127.0.0.1"),
    };
    println!("{:#?}", local);

    let loopback = IPAddress {
        kind: IPAddrKind::V6,
        address: String::from("::1"),
    };
    println!("{:#?}", loopback);

}

// 
fn route(ip: IPAddrKind) {

}

#[derive(Debug)]
enum IPAddrKind {
    V4,
    V6,
}

#[derive(Debug)]
struct IPAddress {
    kind: IPAddrKind,
    address: String,
}
```

### 将数据附加到枚举的变体中
* swift 也有类似的特性
```rust
enum IPAddr {
    V4(String),
    V6(String),
}
```
* 优点
1. 不需要额外使用 struct 来存储相关数据
2. 每个变体可以拥有不同类型以及关联的数据量，例如下列

```rust
enum IPAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

    let home = IPAddr::V4(127, 0, 0, 1);
    let lb = IPAddr::V6(String::from("::1"));

    println!("{:#?}", home);
    println!("{:#?}", lb);
```

## 标准库中的 IpAddr
* 枚举的变体中可以嵌入任意类型的数据

```rust
struct Ipv4Addr {

}

struct Ipv6Addr {

}

enum IpAddr {
  V4(Ipv4Addr),
  V6(Ipv6Addr)
}
```

## 另一个栗子

```rust
#[derive(Debug)]
enum Message {
    Quit,
    Move { x: i32, y: i32}, // 关联的数据类型是一个匿名的 struct
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn test_message() {

    let q = Message::Quit;
    let m = Message::Move { x: 12, y: 12 };
    let w = Message::Write(String::from("Hello"));
    let c = Message::ChangeColor(0, 255, 255);
    
}
```

## 为枚举定义方法
* 也是使用 impl 关键字

```rust
impl Message {
    fn call(&self) { 
        println!("Hello");
    }
}
```

## Option 枚举





![image](/assets//1.png)



