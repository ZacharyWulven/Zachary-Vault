---
layout: post
title: RustGuide-06
date: 2023-03-19 16:45:30.000000000 +09:00
categories: [Rust]
tags: [Rust]
---

# 9 错误处理

### panic! 宏，不可恢复的错误
* 错误分类
1. 可恢复的错误，比如文件未找到，可再次尝试
2. 不可恢复的错误，就是 bug，比如索引超出了范围

* Rust 里没有异常机制
1. 针对可恢复错误，Rust 提供了 `Result<T,E>` 类型
2. 针对不可恢复错误，Rust 提供了 panic! 宏

### 不可恢复错误与 panic! 宏
* 当 panic! 宏执行时
1. 你的程序会打印一个错误信息
2. 展开、清理调用栈
3. 最后退出程序

* 为了应对 panic 
1. 可以展开
2. 或终止（abort）调用栈

* 默认情况下，当 panic 发生时，有两种操作可选择
1. 程序会展开调用栈（工作量大），这意味着程序会沿着调用栈往回走，在往回走的过程中，每遇到一个函数就会把这个函数中的数据清理掉
2. 或理解终止调用栈，这会不进行清理工作，直接终止程序，所使用的内存需要由操作系统来清理


> 如果你想让你的二进制文件更小，我们就可以把 “展开” 改为 “终止”
{: .prompt-info }


* 如果你想让你的二进制文件更小，我们就可以把 “展开” 改为 “终止”
1. 在 Cargo.toml 文件中适当的 profile 部分设置 panic = "abort"


```
[profile.release]
panic = "abort"
```


```rust
    let list = vec![1,2,3];
    list[9]; // 数组越界系统会调用 panic!
```

* panic! 可能调用在我们的代码中，也可能调用在依赖库的代码中
1. 通过 panic! 回溯信息来定位引起问题的代码
2. 设置 RUST_BACKTRACE=1 可以获得回溯信息

```shell
// 执行这个命令查看调试信息
$ RUST_BACKTRACE=1 cargo run

// 执行这个命令查看更丰富的调试信息
$ RUST_BACKTRACE=full cargo run
```

> 为了获取有调试信息的回溯，必须 cargo run 时 不能带 `--release`
{: .prompt-info }

## Result 枚举与可恢复的错误

* `Result<T,E>`


```rust
enum Result<T,E> {
  Ok(T),  // T 即操作成功情况下，Ok 变体里返回的数据类型
  Err(E), // E 即操作失败情况下，Err 变体里返回的错误类型
}

```


### 使用 Match 表达式处理 Result
* 和 Option 枚举一样，Result 及其变体也是由 prelude 模块导入的

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => {
            panic!("open hello txt failed, {:#?}", error);
        }
    };

}
```

* 匹配不同的错误

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("error create file, {:?}", e),
            },
            // other_error 是自己起的名字
            other_error => panic!("error open file failed, {:#?}", other_error),
        },
    };
}
```

* `Result<T,E>` 由很多方法
1. 这些方法接收闭包作为参数
2. 这些方法都是使用 match 来实现的

```rust
// 这样写等于上边的多 match 写法
    let f = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|e| {
                panic!("error create file, {:?}", e)
            })
        } else {
            panic!("error open file failed, {:#?}", error);
        }
    });
```


### unwrap 方法
* 是 match 的一个快捷方法
* 如果 Result 的结果是 Ok，则返回 Ok 里的值
* 如果 Result 的结果是 Err，则调研 panic! 这个宏
* 缺点是错误信息不能自定义

```rust
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => {
            panic!("open hello txt failed, {:#?}", error);
        }
    };

    // 这么写类似上边 match
    let f = File::open("hello.txt").unwrap();
```

### expect 方法
* 与 unwrap 方法类似，但是可以指定错误信息

```rust
    let f = File::open("hello.txt").expect("文件不存在");
```
