---
layout: post
title: RustGuide-08
date: 2023-03-22 16:45:30.000000000 +09:00
categories: [Rust]
tags: [Rust]
---

# 11 编写自动化测试

## 编写和运行测试
* 测试：即是个函数，验证非测试代码的功能是否与预期一致

### 测试函数体内通常执行 3 个操作
1. 准备数据状态
2. 运行被测试的代码
3. Assert（断言）结果

### 测试函数使用 test 属性（attribute）进行标注
* attribute 就是一段 Rust 代码的元数据，不会改变被修饰代码的逻辑，只是对代码进行标注
* 在函数上加 `#[test]` 可以把函数变为测试函数

### 运行测试
* 使用 `cargo test` 命令运行所有的测试函数
1. Rust 会构建一个 Test Runner 可执行文件 
2. Test Runner 就会逐个调用标注了 test attribute 的函数，并报告其运行是否成功

* 当使用 cargo 创建 Library 项目时，会生成一个 test module，里面有一个现成的 test 函数，可以参照这个现成的 test 函数编写其他 test 函数


```
// 创建一个库项目叫 adder
$ cargo new adder --lib

// 执行测试函数
$ cargo test

执行输出：
running 1 test                // 当前运行一个 test
test tests::it_works ... ok   // 运行 tests::it_works 函数，结果是 ok

// test result: ok 表示项目里所有的测试都通过了
// 0 measured 表示有 0 个性能测试
// 0 filtered out 指我们没有过滤掉任何测试
test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

// 这是文档测试的结果，Rust 可以编译测试出现在文档中的代码，这可以保证文档能与实际代码同步
   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```

### 测试失败
* 测试函数 panic 就是失败了
* 每个测试运行在一个新的线程
* 主线程会监听这些测试线程，当主线程看到某个测试线程挂掉嘞，那这个测试就失败了
* 如何让测试线程挂掉呢，就是触发 panic

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test] // 这是一个测试函数
    fn explorer() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
    
    #[test]
    fn make_panic() {
        panic!("make me panic");
    }
}
```

## 断言（Assert）

### 使用 assert! 宏检查测试结果
* assert! 来自标准库，用来确定某个标准库是否为 true
1. 为 true 测试就通过
2. 为 false 就会调用 panic!，测试失败

```rust
    #[test]
    fn another() {
        let a = true;
        assert!(a);
    }
```

### 使用 assert_eq! 和 assert_ne! 测试相等性
* 都来自标准库
* assert_eq!（equal），判断是否相等，实际就是使用 `==`
* assert_ne!（not equal），判断是否不相等，实际就是使用 `!=`
* 如果断言失败，这俩宏会自动打印出两个参数的值，方便我们查看原因，而 assert! 只能指定结果，不能知道原因
1. 失败时使用 debug 格式打印参数，
2. 要求他的参数实现 PartialEq 和 Debug 这俩 Traits（所有的基本类型和标准库里大部分类型都实现了）
3. 针对 struct 和 enum 需要自己自行实现这个俩 trait

* 期待的值可以放 assert_eq! 或 assert_ne! 里的任何参数位置

```rust
fn add_two(a: i32) -> i32 {
    a + 3
}

#[test]
fn it_work_two() {
    assert_eq!(4, add_two(2));
}
```

> 错误信息：thread 'tests::it_work_two' panicked at 'assertion failed: `(left == right)` left: `4`, right: `5`', src/lib.rs:33:9
{: .prompt-info }


## 自定义的错误信息
* 可以向 assert!、assert_eq!、assert_ne! 三个宏添加可选的自定义信息
1. 如果添加了可选的自定义信息，那么他们会和失败信息一起被打印出来

* assert!：第一个参数时必填的，自定义消息作为第二个参数
* assert_eq!、assert_ne! 它们前两个参数是必填的，自定义消息作为第三个参数
* 自定义信息传入 assert!、assert_eq!、assert_ne! 后会被传给 format! 宏，可以使用 {} 占位符

```rust
fn greeting(name: &str) -> String {
    format!("Hello {}", name)
}

#[test]
fn it_work_greeting() {
    let result = greeting("Carol");
    assert!(result.contains("Carol"));
}
```

* 下边代码错误信息：thread 'tests::it_work_greeting1' panicked at 'Greeting did not cntain name Hello!', src/lib.rs:53:9

```rust
fn greeting1(name: &str) -> String {
    format!("Hello!")
}

    #[test]
    fn it_work_greeting1() {
        let result = greeting1("Carol");
        assert!(
            result.contains("Carol"), 
            "Greeting did not cntain name {}", result
        );
    }
```

### 用 should_panic 检查 panic
* 测试函数除了检查代码是否返回正确的值外，还需要检查代码是否如预期的处理了发生错误的情况
* 可验证代码在特定情况下是否发生了 panic
* 为函数添加 shoule_panic 属性
1. 如果标记了 shoule_panic 属性的函数里发生了 panic，那么测试通过
2. 如果没有发生 panic，那么测试失败

```rust
pub struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }
        Guess { value }
    }
}

#[test]
#[should_panic]   // 标记
fn greater_than_100() {
    Guess::new(200); // 测试可以通过，因为发生了 panic
}

```

* 让 should_panic 更精确
1. 为 should_panic 属性添加一个可选的 expected 参数，将检查失败消息中是否包含所指定的文字

```rust
pub struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -> Guess {
        if value < 1 {
            panic!("Guess value must be greater than or equal to 1, got {}.", value);

        } else if value > 100 {
             
        }
        if value < 1 || value > 100 {
            panic!("Guess value must be less than or equal to 100, got {}.", value);
        }
        Guess { value }
    }
}

    #[test]
    // 错误信息要包含 expected 的值，测试才能通过
    #[should_panic(expected = "Guess value must be less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }

```


### 在测试中使用 `Result<T, E>` 枚举
* 在编写测试函数时，无需 panic，可使用 `Result<T, E>` 作为返回类型
1. 返回 Ok：测试通过
2. 返回 Err：测试失败


```rust
#[test]
fn it_work_result() -> Result<(), String>{
    if 2 + 2 == 4 {
        Ok(())
    } else {
        Err(String::from("two plus two does not equal four"))
    }
}
```

> 不要在使用 `Result<T, E>` 为返回值的测试函数上使用 should_panic 属性，因为测试失败返回 Err 不会发生 panic
{: .prompt-info }
