---
layout: post
title: RustGuide-11
date: 2023-03-28 16:45:30.000000000 +09:00
categories: [Rust]
tags: [Rust]
---

# 14 cargo 和 crates.io

## 通过发布配置（release profile）来自定义构建
### 发布配置（release profile）
* 是预定义的
* 可以自定义：可使用不同配置，对代码编译拥有更多的控制
* 每个 profile 的配置都是独立于其他 profile 的

### cargo 主要有两种常见的 profile
* dev profile：适用于开发，执行 `cargo build` 命令时，执行的就是 dev profile
* release profile：适用于发布，执行 `cargo build --release`，执行的就是 release profile

### 自定义 profile
* 针对每个 profile，cargo 都提供了默认的配置
* 如果想自定义某个 profile 的配置
1. 可以在 Cargo.toml 里添加 [profile.xxx] 区域，在里边覆盖默认配置的子集
2. 不覆盖就使用默认的配置


```
// cargo.toml
// opt-level 用于 Rust 编译时对代码执行那种程度的优化，值范围是 0~3
// 优化程度越高，代码编译的时间越长

// 覆盖 dev profile 的 opt-level 值
[profile.dev] 
opt-level = 1


// 覆盖 release profile 的 opt-level 值
[profile.release]
opt-level = 3
```

> 对于每个配置的默认值和完整选项 [参考链接](https://doc.rust-lang.org/cargo)
{: .prompt-info }

## 在 `https://crates.io` 上发布库


### crate 的注册表在 `https://crates.io` 上
* 它会分发已注册的包的源代码
* 主要托管开源的代码


### 文档注释
* 用于生成文档
* 生成 HTML 文档
* 显示公共 API，教你如何使用 API
* 使用 `///` 编写
* 支持 Markdown
* 被放置在说明条目之前


```rust
/// Adds one to the number given.
/// 
/// # Examples
/// 
/// ```
/// let arg = 5;
/// let answer = profile::add_one(arg);
/// 
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```


```shell
// 生成文档
$ cargo doc
```

### 生产 HTML 文档的命令
* cargo doc
1. 它会运行 rustdoc 这个工具（Rust 安装时自带）
2. 将生成的 HTML 文档放在 target/doc 目录下


```shell
// 生成文档并自动打开文档
// 构建当前 crate 的文档（也包含 crate 依赖项的文档）
$ cargo doc --open
```

### 常用的章节
* `# Examples`
* `# Panics` 描述函数可能发生 panic 的场景，开发人员需要注意
* `# Errors` 描述如果函数返回 Result，可能的错误种类，以及可导致错误的条件
* `# Safety` 如果函数处于 unsafe 调用，就应该解释函数 unsafe 的原因，以及调用者确保的使用前提

### 文档注释作为测试
* 运行 cargo test，将会把文档注释中的示例代码作为测试来运行

### 为包含注释的项添加文档注释
* 为外层条目添加文档注释
* 符号用 `//!` 
* 这类注释通常用于描述 crate 和模块
1. 例如 crate root（按惯例就是 src/lib.rs）
2. 或一个模块内，将 crate 或模块作为一个整体进行记录

```rust
//lib.rs

//! # Profile  Crate
//! 
//! `Profile` is a collection of utilities
//! calculations more convenient.


/// Adds one to the number given.
/// 
/// # Examples
/// 
/// ```
/// let arg = 5;
/// let answer = profile::add_one(arg);
/// 
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```

## pub use
* 问题 crate 的程序结构在开发时对于开发者很合理，但对于它的使用者不够方便
1. 开发者会把程序结构分为很多层，使用者想找到这种深层结构中的某个类型很费劲
2. 麻烦：`my_crate::some_module::another_module::UsefulType`
3. 方便：`my_crate::UsefulType`

* 解决方案
1. 不需要重新组织内部代码结构

> 使用 pub use 就可以重新导出，创建一个与内部私有结构不同的对外公共结构
{: .prompt-info }

```rust
pub use self::module
```


## 通过 workspaces 组织大工程

## 从 https://crates.io 来安装库

## 使用自定义命令扩展 cargo








