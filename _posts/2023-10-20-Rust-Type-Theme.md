---
layout: post
title: Rust 中级教程-类型主体
date: 2023-10-14 16:45:30.000000000 +09:00
categories: [Rust, Rust Type]
tags: [Rust, Rust Type]
---


# 0x01 指针

## 什么事指针
* 指针：即是计算机引用无法立即直接访问的数据的一种方式
* 数据在物理内存（RAM）中是分散的存储的，地址空间是检索系统


> 指针就是被编码为内存地址，使用 `usize` 类型的整数表示的。一个地址就好指向地址空间中的某个地方。
{: .prompt-info }


* 地址空间的范围是 `OS` 和 `CPU` 提供的外观界面
  * 程序只知道有序的字节序列，不会考虑系统中实际的 `RAM` 的数量
  
## 名词解释
* 内存地址（地址）：即指代内存中单个字节的一个数
  * 内存地址是汇编语言提供的一种抽象
* 指针（有时扩展称为原始指针）：即指向某种类型的一个内存地址
  * 指针是高级语言提供的抽象
* Rust 中的引用，就是指针。如果是动态大小的类型，就是指针和具有额外保证的一个整数
  * 引用是 Rust 提供的一种抽象


## Rust 的引用
* 引用始终引用的是有效的数据
* 引用与 `usize` 的倍数的对齐的，从而不会降低运行的速度
* 引用可以为动态大小的类型提供上述的保障


### Rust 的引用和指针

```rust
static B: [u8; 10] = [99, 97, 114, 114, 121, 116, 111, 119, 101, 108];
static C: [u8; 11] = [116, 104, 97, 110, 107, 115, 102, 105, 115, 104, 0];

fn main() {

    let a = 42;
    let b = &B;
    let c = &C;

    /*
        {:p} 表示打印指针的地址
     */
    println!("a: {}, b: {:p}, c: {:p}", a, b, c); // a: 42, b: 0x10c7ea44c, c: 0x10c7ea456
}
```

![image](/assets/images/rust/type/memory.png)

* 看图可见，a 占 4 个字节，这里内存是对齐的
* `b 和 c` 是指针是用 `usize` 来表示的，在 32 位的 CPU 上引用是 4 字节，在 64 位上引用是 8 字节
* `b 和 c` 是指针会指向另外一个地址，一个连续的内存块


#### 进一步解释想要的效果
* 想要模拟智能指针和原始指针
* 还是刚才的代码，下图展示了内存结构

> 这个例子中指针的宽度是两个字节
{: .prompt-info }

![image](/assets/images/rust/type/memory_01.png)


* `a` 的类型是 `i16`，在内存中就是 `0x31 和 0x30`
* 这个图中 `b 和 c` 在内存上是不一样的，这是因为上边的代码有一些欺骗性，这其实是我们想要达到的效果
* `b` 的类型是智能指针
  * 它包含：长度字段和地址字段
  * 它的长度字段是 `10`，对应 `0x2D 和 0x2c`
  * 它的地址字段：对应 `0x2F 和 0x2E`，地址是 `32`，即 `0x20` 开始
  * 它就是长度为 10 的固定宽度的 `buffer`，包含不带终止符的字节，不以 `0` 结尾
  * 当在指针类型后面使用时，`buffer` 通常称为后备数组
  * `b 和 B` 一起几乎可以创建出 Rust 中的字符串类型，但字符串类型还包含一个`容量字段`
  
  
* `c` 是原始指针，占两个字节，里边直接存的就是地址，这里是十进制的 `16`，即 `0x10` 开始
  * `c` 是以 `0` 结尾的 `buffer`，就是 `C` 语言中的字符串的内部表示，`C` 中字符串就是一个数组
  * 了解如何将这些类型转换为 Rust 类型，对于通过 FFI(外部函数接口) 处理外部代码非常有用
  * `c 和 C` 一起就是 Rust 里的 `CStr` 类型
  

> `0x0` 就是 `NULL byte`，它是程序的死区。如果指针指向此处，然后解引用，程序通常就会崩溃
{: .prompt-info }
