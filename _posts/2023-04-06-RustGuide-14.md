---
layout: post
title: RustGuide-14
date: 2023-04-06 16:45:30.000000000 +09:00
categories: [Rust]
tags: [Rust]
---

# 17 Rust 的面向对象编程特性

## 面向对象语言的特性

### 继承
* Rust 里没有继承
* 使用继承的原因：代码复用
1. Rust 中默认使用 trait 方法来进行代码共享，因为如果某 trait 有默认实现那么任何实现了这个 trait 的类型就自动拥有那些方法
2. 实现了某 trait 的类型也可以覆盖 trait 的默认实现

* 多态
1. Rust 中使用泛型和 trait 约束（限定参数化多态 bounded parametric）来实现多态

> 现在很多新语言都不使用继承作为内置的设计方案了
{: .prompt-info }

## 使用 trait 对象来存储不同类型的值
有这样一个需求，创建一个 GUI 工具，它会遍历某个元素列表，依次调用元素的 draw 方法进行绘制，例如 Button、TextField 等元素

* 在面向对象语言里，一般是定义一个 Component 的父类，里面定义了 draw 方法，定义 Button、TextField 等类，继承于 Component 类
* Rust 中通过定义一个 trait 实现

> Rust 避免将 struct 或 enum 称为对象，因为它们与 impl 块是分开的
{: .prompt-info }

* trait 对象有些类似于其他语言中的对象，某种程度上是组合了数据与行为
* trait 对象与传统对象不同的地方：无法为 trait 对象添加数据
* trait 对象实际是被专门用于抽象某些共有行为的，它没有其他语言中的对象那么通用

```rust
// lib.rs
pub trait Draw {
    fn draw(&self);
}

pub struct Screen {
    // Vec 里的元素是实现了 Draw trait 的类型
    pub components: Vec<Box<dyn Draw>>,
}

impl Screen {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}

pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&self) {
        println!("绘制一个 Button");
    }
}

// main.rs
use GUI_17::{ Draw, Button, Screen };

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec<String>,
}

impl Draw for SelectBox {
    fn draw(&self) {
        println!("绘制一个选择框");
    }
}

fn main() {
    demo_gui();
}

fn demo_gui() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from("Yes"),
                    String::from("Maybe"),
                    String::from("No"),
                ],
            }), 
            Box::new(Button {
                width: 50,
                height: 20,
                label: String::from("Ok"),
            }),
        ]
    };
    screen.run();
}
```

### Trait 对象执行的是动态派发
* 将 trait 约束作用于泛型时，Rust 编译器会执行单态化操作
1. 即编译器会为我们用来替换泛型类型参数的每一个具体类型生成对应类型的函数和方法的非泛型实现
2. 通过单态化生成的代码会执行静态派发（static dispatch），在编译过程中确定调用的具体方法

* 动态派发（dynamic dispatch）
1. 无法在编译过程中确定你调用的究竟是哪个方法
2. 编译器会产生额外的代码以便于在运行时找出希望调用的方法
* 如果使用 trait 对象，就会执行动态派发
1. 这就会导致产生运行时的开销
2. 并且阻止编译器内联方法代码，使得部分优化操作无法进行

### Trait 对象必须保证对象安全
* 只能把满足对象安全（object-safe）的 trait 转化为 trait 对象
* Rust 采用一系列规则来判定某个对象是否安全，只需记住两条：满足这两条这个对象就是安全的
1. 方法的返回类型不是 Self
2. 方法中不包含任何泛型类型参数

* 标准库 Clone trait 就是一个不符合安全规则的例子

```rust
// 不安全的因为它返回 Self
pub trait Clone {
    fn clone(&self) -> Self;
}


// 这样就会报错，因为 Clone trait 返回 Self，因此不能称为 trait 对象
pub struct Screen {
    pub components: Vec<Box<dyn Clone>>,
}
```
