---
layout: post
title: Rust 中级教程-类型主题-02
date: 2023-10-28 16:45:30.000000000 +09:00
categories: [Rust, Rust Type]
tags: [Rust, Rust Type]
---


# 0x03 所有权（回顾）

## Rust 内存模型的核心思想：所有的值都只有一个所有者
* 即只有一个位置（通常是作用域）来负责释放每个值。通常变量走出其作用域就被释放了
* 这是通过借用检查器来实现的
  * 如果值移动了（比如：赋值新变量、推到 Vec 中、置于 Heap），其所有者也变成新的位置了
* 但有些类型不遵守这个规则
  * 如果值的类型实现了 `Copy trait`，重新赋值时到新内存地址时，发生的就不是移动了，而是复制
  * 大多数的原始类型，例如整数、浮点类型等，都实现了 `Copy trait`
  
## 如何实现 `Copy trait`
* 必须可以按位（bit）来把值进行复制
  * 所以就不包括：
    * 这个值中（的属性）含有 `non-Copy` 类型的类型
    * 拥有这类资源的类型：当类型的值被丢弃时，必须被释放该资源
  
* 为什么呢？
  * 如果 `Box` 是 `Copy` 的，进行赋值：`box1 = box2`，那么它们都认为自己在 heap 上持有那块内存，当它们走出作用域都会去尝试释放那块内存，就会出现二度释放的问题



## 值的删除（丢弃，dropped）
* 当值不再被需要时，其所有者就会将其删除
  * 当值不再存在于作用域内，就会被删除
* 如果值还包含其他的类型，那么类型会递归的将其所包含的值进行删除
  * 例如删除一个复杂类型的变量，可能会导致很多值被删除


> 因为所有权的设计，Rust 不会发生多次删除同一个值的情况
{: .prompt-info }


* 如果变量含义对其他值（比如叫 B）的引用（不拥有该值），当变量被删除时，其他的值（B）不会被删除


## 值删除的顺序
1. 变量（包括函数的参数）是按定义相反的顺序进行删除的
2. 嵌套的值是按照源代码的顺序进行删除的

```rust
fn main() {
    let x1 = 42;
    let y1 = Box::new(88);

    {
        /*
            x1 实现了 Copy，这里只是发生了 Copy，所以下边还可以把 x1 赋值给 x2
            y1 则发生了移动
            
            值删除的顺序
            第一条：y1 先声明，z 后声明，删除的时候先删除 z 后删除 y1
            第二条：先删除 x1 再删除 y1
         */
        let z = (x1, y1);
    }

    // Ok
    let x2 = x1;

    // Error, 因为上边作用域 y1 移动给了 z，所以这里不能再使用 y1，所以报错
    let y2 = y1;
}
```


> 备注：Rust 暂时不允许在单个值内进行自我引用的
{: .prompt-info }



# 0x04 引用及内部可变性（回顾）

## 引用
* 通过引用，Rust 允许将值借用出去，但不放弃所有权
* 引用就是带有附加合约的指针


### 共享引用
* `&T`，就是可以共享的指针
  * 可以同时存在任意数量的引用指向同一个值
  * 每个共享的引用都实现了 `Copy`
  
* 其背后的值是不可变的
  * 编译器允许假定共享引用指向的值，在该引用存活期间是不会改变的
  * 例如：一个共享引用的值在某函数内被多次读取，那编译器就有权让其只读取一次，然后后续重用这个读取的值


### 可变引用
* `&mut T`，可变引用是独占的
  * 编译器假定没有其他线程访问目标值（即如果存在了一个可变引用，就不会出现其他的共享引用或可变引用）

* 例子

```rust
/*
    input 与 output 指向不同的内存，
    因为 output 是可变的，它是独占的
    函数里，修改 output 不会影响 input

    但如果可变引用不是独占的，那么 input 与 output 就可能指向相同的内存，
    这时函数里对 output 的修改可能影响后边的代码逻辑
*/
fn noalias(input: &i32, output: &mut i32) {
    if *input == 1 {
        *output = 2;
    }
    if *input != 1 {
        *output = 3;
    }
}
```

*（重点）可变引用只允许你修改引用所指向的内存地址
  * 看例子
  
```rust
fn main() {
    let x = 42;
    // 1 可以让 y 指向其他的值，但不可以通过 y 来修改 x 的值
    let mut y = &x;   
    // 因为 z 没有 mut 修饰，所以它只能持有对 y 的可变引用，但可以通过 z 来修改 y 的值
    let z = &mut y;

    // *y = 10;  // Error

    let n = 20;
    *z = &n; // 修改 y 的值，y 指向 &n
}
```

## 拥有值 VS 拥有到值的可变引用
* 区别在于：所有者需要对删除值（丢弃值）进行负责


> Note：如果你移动了可变引用背后的值，则必须在其位置上留下另一个值。如果不这样做，所有者会认为它需要将其删除（丢弃），但其实却没有值可以删除了。
{: .prompt-info }

*（重要）上边 Note 的例子：

```rust
fn replace_with_84(s: &mut Box<i32>) {
    // this is not okay，as *s would be empty:

    /*
        这句不能执行
        如果这句可以那么值就移动了，但调用者依然认为他们拥有其所有权，
        所以他们还是会对这个值进行丢弃操作
     */
    // let was = *s;

    /*
        take 函数将 s 移动，并将 s 类型的默认值放到了原来的位置上了，
        这时调用者就会拥有那个新的默认的那个值，
        然后调用者再清理这个变量就不会有问题了
        
        Note：如果你移动了可变引用背后的值，则必须在其位置上留下另一个值，使用 take 留下默认值
     */
    let was = std::mem::take(s);

    println!("was init is {}", was); // was init is 42
    println!("was init s is {}", s); // was init s is 0

    /*
        was 即其他一个合理的值，
        相当于又把原来 s 的值赋值回去了，又变成 42 了
     */
    *s = was;
    println!("*s = was is {}", s);   // *s = was is 42

    let mut r = Box::new(84);
    std::mem::swap(s, &mut r);
    assert_ne!(*r, 84);
}

fn main() {
    let mut s = Box::new(42);
    replace_with_84(&mut s);
}
```

## 内部可变性
* 有一些类型提供了内部可变性
  * 即可以通过共享引用（不可变引用）修改值
  
* 这些类型通常依赖于额外的机制（例如原子 CPU 指令）或不变量来提供安全的可变性，而不依赖于独占引用的语义

### 内部可变性分为两类
* 1 通过共享引用获得可变引用
  * 代表类型：`Mutex` 和 `RefCell`
    * 它们提供了保障机制：如果对某个值提供了可变引用，则同时只会存在一个可变引用，并且也没有共享引用
    * 这依赖于 `UnsafeCell` 类型，这也是通过共享引用修改值的唯一正确方式
  
* 2 通过共享引用可以替换值
  * 代表类型：`std::sync::atomic` 和 `std::cell::Cell`
    * 它们没有提供可变引用到内部的值
    * 它们提供的是就地操作值的方法
    * 例如：无法直接获得到 `usize 或 i32` 的直接引用，但是可以读取和替换值


## `Cell` 类型
* 它是标准库里的
* 通过不变量的方式实现内部可变性
  * 它无法跨线程共享（所以内部值不会被并发的修改，即使通过共享引用发生修改）
  * 它也不会提供 `Cell` 到内部值的引用（所以可以一直移动它）
* 提供什么方法？：
  * 对值整体替换（就地操作）
  * 返回值的副本（读取）





<!--![image](/assets/images/rust/type/memory_01.png)-->

