---
layout: post
title: Rust 中级教程-类型主题-02
date: 2023-10-28 16:45:30.000000000 +09:00
categories: [Rust, Rust Type]
tags: [Rust, Rust Type]
---


# 0x03 所有权（回顾）

## Rust 内存模型的核心思想：所有的值都只有一个所有者
* 即只有一个位置（通常是作用域）来负责释放每个值。通常变量走出其作用域就被释放了
* 这是通过借用检查器来实现的
  * 如果值移动了（比如：赋值新变量、推到 Vec 中、置于 Heap），其所有者也变成新的位置了
* 但有些类型不遵守这个规则
  * 如果值的类型实现了 `Copy trait`，重新赋值时到新内存地址时，发生的就不是移动了，而是复制
  * 大多数的原始类型，例如整数、浮点类型等，都实现了 `Copy trait`
  
## 如何实现 `Copy trait`
* 必须可以按位（bit）来把值进行复制
  * 所以就不包括：
    * 这个值中（的属性）含有 `non-Copy` 类型的类型
    * 拥有这类资源的类型：当类型的值被丢弃时，必须被释放该资源
  
* 为什么呢？
  * 如果 `Box` 是 `Copy` 的，进行赋值：`box1 = box2`，那么它们都认为自己在 heap 上持有那块内存，当它们走出作用域都会去尝试释放那块内存，就会出现二度释放的问题



## 值的删除（丢弃，dropped）
* 当值不再被需要时，其所有者就会将其删除
  * 当值不再存在于作用域内，就会被删除
* 如果值还包含其他的类型，那么类型会递归的将其所包含的值进行删除
  * 例如删除一个复杂类型的变量，可能会导致很多值被删除


> 因为所有权的设计，Rust 不会发生多次删除同一个值的情况
{: .prompt-info }


* 如果变量含义对其他值（比如叫 B）的引用（不拥有该值），当变量被删除时，其他的值（B）不会被删除


## 值删除的顺序
1. 变量（包括函数的参数）是按定义相反的顺序进行删除的
2. 嵌套的值是按照源代码的顺序进行删除的

```rust
fn main() {
    let x1 = 42;
    let y1 = Box::new(88);

    {
        /*
            x1 实现了 Copy，这里只是发生了 Copy，所以下边还可以把 x1 赋值给 x2
            y1 则发生了移动
            
            值删除的顺序
            第一条：y1 先声明，z 后声明，删除的时候先删除 z 后删除 y1
            第二条：先删除 x1 再删除 y1
         */
        let z = (x1, y1);
    }

    // Ok
    let x2 = x1;

    // Error, 因为上边作用域 y1 移动给了 z，所以这里不能再使用 y1，所以报错
    let y2 = y1;
}
```


> 备注：Rust 暂时不允许在单个值内进行自我引用的
{: .prompt-info }



# 0x04 引用及内部可变性（回顾）

## 引用
* 通过引用，Rust 允许将值借用出去，但不放弃所有权
* 引用就是带有附加合约的指针


### 共享引用
* `&T`，就是可以共享的指针
  * 可以同时存在任意数量的引用指向同一个值
  * 每个共享的引用都实现了 `Copy`
  
* 其背后的值是不可变的
  * 编译器允许假定共享引用指向的值，在该引用存活期间是不会改变的
  * 例如：一个共享引用的值在某函数内被多次读取，那编译器就有权让其只读取一次，然后后续重用这个读取的值


### 可变引用
* `&mut T`，可变引用是独占的
  * 编译器假定没有其他线程访问目标值（即如果存在了一个可变引用，就不会出现其他的共享引用或可变引用）

* 例子

```rust
/*
    input 与 output 指向不同的内存，
    因为 output 是可变的，它是独占的
    函数里，修改 output 不会影响 input

    但如果可变引用不是独占的，那么 input 与 output 就可能指向相同的内存，
    这时函数里对 output 的修改可能影响后边的代码逻辑
*/
fn noalias(input: &i32, output: &mut i32) {
    if *input == 1 {
        *output = 2;
    }
    if *input != 1 {
        *output = 3;
    }
}
```

*（重点）可变引用只允许你修改引用所指向的内存地址
  * 看例子
  
```rust
fn main() {
    let x = 42;
    // 1 可以让 y 指向其他的值，但不可以通过 y 来修改 x 的值
    let mut y = &x;   
    // 因为 z 没有 mut 修饰，所以它只能持有对 y 的可变引用，但可以通过 z 来修改 y 的值
    let z = &mut y;

    // *y = 10;  // Error

    let n = 20;
    *z = &n; // 修改 y 的值，y 指向 &n
}
```

## 拥有值 VS 拥有到值的可变引用
* 区别在于：所有者需要对删除值（丢弃值）进行负责


> Note：如果你移动了可变引用背后的值，则必须在其位置上留下另一个值。如果不这样做，所有者会认为它需要将其删除（丢弃），但其实却没有值可以删除了。
{: .prompt-info }

*（重要）上边 Note 的例子：

```rust
fn replace_with_84(s: &mut Box<i32>) {
    // this is not okay，as *s would be empty:

    /*
        这句不能执行
        如果这句可以那么值就移动了，但调用者依然认为他们拥有其所有权，
        所以他们还是会对这个值进行丢弃操作
     */
    // let was = *s;

    /*
        take 函数将 s 移动，并将 s 类型的默认值放到了原来的位置上了，
        这时调用者就会拥有那个新的默认的那个值，
        然后调用者再清理这个变量就不会有问题了
        
        Note：如果你移动了可变引用背后的值，则必须在其位置上留下另一个值，使用 take 留下默认值
     */
    let was = std::mem::take(s);

    println!("was init is {}", was); // was init is 42
    println!("was init s is {}", s); // was init s is 0

    /*
        was 即其他一个合理的值，
        相当于又把原来 s 的值赋值回去了，又变成 42 了
     */
    *s = was;
    println!("*s = was is {}", s);   // *s = was is 42

    let mut r = Box::new(84);
    std::mem::swap(s, &mut r);
    assert_ne!(*r, 84);
}

fn main() {
    let mut s = Box::new(42);
    replace_with_84(&mut s);
}
```

## 内部可变性
* 有一些类型提供了内部可变性
  * 即可以通过共享引用（不可变引用）修改值
  
* 这些类型通常依赖于额外的机制（例如原子 CPU 指令）或不变量来提供安全的可变性，而不依赖于独占引用的语义

### 内部可变性分为两类
* 1 通过共享引用获得可变引用
  * 代表类型：`Mutex` 和 `RefCell`
    * 它们提供了保障机制：如果对某个值提供了可变引用，则同时只会存在一个可变引用，并且也没有共享引用
    * 这依赖于 `UnsafeCell` 类型，这也是通过共享引用修改值的唯一正确方式
  
* 2 通过共享引用可以替换值
  * 代表类型：`std::sync::atomic` 和 `std::cell::Cell`
    * 它们没有提供可变引用到内部的值
    * 它们提供的是就地操作值的方法
    * 例如：无法直接获得到 `usize 或 i32` 的直接引用，但是可以读取和替换值


## `Cell` 类型
* 它是标准库里的
* 通过不变量的方式实现内部可变性
  * 它无法跨线程共享（所以内部值不会被并发的修改，即使通过共享引用发生修改）
  * 它也不会提供 `Cell` 到内部值的引用（所以可以一直移动它）
* 提供什么方法？：
  * 对值整体替换（就地操作）
  * 返回值的副本（读取）


# 0x05 生命周期（补充）

* 官方教程提到：
  * Rust 里每个引用都有生命周期，它就是`引用保持合法的作用域（scope）`，大多数时候是隐式和推断出来的
* 即对某个变量取得引用时生命周期就开始了，当变量移动或离开作用域时生命周期就结束了
* 其实对于生命周期：对于某个引用来说，它必须保持合法的一个代码区域的名称
  * 生命周期通常与作用域重合，但也不一定

## 借用检查器（Borrow Checker）
* 每当具有某个生命周期 `'a` 的引用被使用，借用检查器都会检查 `'a` 是否还存活
  * 追踪路径直到 `'a` 开始（获得引用）的地方
  * 从这开始，检查沿着路径是否存在冲突，保证引用指向一个可安全访问的值
  * 例子


```rust
use rand::prelude::*;
 
fn main() {
    let mut x = Box::new(42);
    let r = &x;      // (1) 'a，生命周期开始

    /*
        可以看到 'a 生命周期并没有延伸到 if 中，
        所以生命周期不一定与作用域重合
     */
    if random::<f32>() > 0.5 {
        *x = 84;   // (2) 需要 x 的可变引用，检查到这是合法的
        // println!("{}", r); // 如果这行在这就 Error，因为违反了借用规则
    } else {
        println!("{}", r); // (3) 'a，因为编译器指定 if else 只会走一个所以这里是 Ok 的
    }

}
// (4)
```

* 生命周期很复杂：也有漏洞，间歇性的失效的例子
  * 有时需要重启生命周期

```rust
fn main() {
    let mut x = Box::new(42);

    let mut z = &x;  // (1) 'a，生命周期开始，这里在获得引用的时候开始
    for i in 0..100 {           
        println!("{}", z);      // (2) 'a
        x = Box::new(1);        // (3)，其实到这第一个生命周期就结束了，因为 x 重新赋值了
        /*
            如果最后这句注释掉，上边就会报错，
            x 一直处于被借用的状态，这时对它赋值就不行了
            所以这个例子生命周期是有间歇性的失效
            然后又有重启的操作，这就是所谓的 `漏洞`
         */
        // z = &x;                 // (4) 'a，即重启了新的生命周期，所以后续循环是 Ok 的
    }
    println!("{}", z);
}
```


* 借用检查器是保守的：
  * 如果不确定某个借用是合法的，借用检查器就会拒绝这个借用
* 借用检查器有时需要帮助来理解某个借用为什么是合法的
  * 这就是 `Unsafe Rust` 存在的部分原因


## 泛型生命周期
* 有时我们需要再自己的类型里存储引用
  * 这些引用都是有生命周期的，以便借用检查器检查其合法性
  * 例如：在该类型方法中返回引用，并且存活时间比 `self` 还要长 
* Rust 允许你基于一个或多个生命周期将类型的定义泛型化

### 两点提醒
1. 如果类型实现了 `Drop`，那么丢弃这个类型时，就会被记作是使用了这个类型所泛型的生命周期或类型
  * 即这个类型的实例要被 `drop` 时，在 `drop` 之前，借用检查器会检查看是否仍然能合法的去使用你类型的泛型生命周期，因为 `drop 方法` 中的代码可能会使用到这些引用
* 如果你的类型没有实现 `Drop`，那么丢弃类型的时候就不会当做使用了生命周期，可以忽略类型里的引用

2. 类型是可以泛型多个生命周期的，但这么做通常会不必要的让类型签名更复杂
  * 只有类型包含多个引用时，你才应该使用多个生命周期参数
  * 而且这个类型方法返回的引用也应该只绑定到其中一个引用的生命周期中
  * 例子：
  
```rust
// 下面代码使用两个生命周期 's, 'p，代码没有问题
use std::path::Iter;

struct StrSplit<'s, 'p> {
    delimiiter: &'p str,   // 分隔符
    document: &'s str,     // 文档
}

// 实现 Iterator trait 
impl<'s, 'p> Iterator for StrSplit<'s, 'p> {
    type Item = &'s str;

    fn next(&mut self) -> Option<Self::Item> {
        todo!()
    }
}

fn str_before(s: &str, c: char) -> Option<&str> {
    StrSplit {
        document: s,
        delimiiter: &c.to_string(),
    }
    .next()
}


// 下面代码改为使用一个生命周期 's 代码有问题
// 因为 str_before 函数内 &c.to_string() 是在函数内创建的所以报错
// 错误为无法引用值到临时的变量，因为一个生命周期，导致它这里的生命周期最短

struct StrSplit<'s> {
    delimiiter: &'s str,   // 分隔符
    document: &'s str,     // 文档
}

// 实现 Iterator trait 
impl<'s> Iterator for StrSplit<'s> {
    type Item = &'s str;

    fn next(&mut self) -> Option<Self::Item> {
        todo!()
    }
}

fn str_before(s: &str, c: char) -> Option<&str> {
    StrSplit {
        document: s,
        delimiiter: &c.to_string(),
    }
    .next()
}
```

## 生命周期的 Variance
* Variance：即哪些类型是其他类型的 `子类`
* 什么时候 `子类` 可以替换 `超类`（vice verse）
* 通常来说：
  * 如果 A 是 B 的子类，那么 A 至少和 B 一样有用
    * Rust 例子：
      * 如果函数接收 `&'a str` 的参数，那么就可以传入 `&'static str` 的参数
      * 因为 `&'static str` 是 `&'a str` 的子类，因为 `'static` 至少跟任何 `'a` 存活的一样长
        * 因为 `'static` 是在程序运行的生命周期一直存活的，例如字符串字面值


### 三种 Variance
* 所有的类型都有 Variance
  * 这个 Variance 就定义了哪些类似的类型可以用在该类型的位置上，或说可以替代该类型

* 三种 Variance
  1. covariant（协变）：某类型只能用 `子类型` 来替代
    * 例如：`&'static T` 可替代 `&'a T`（`&'a T` 也是 `T` 的一个协变）
  2. invariant（不变）：必须提供指定的类型
    * 例如：`&mut T`，对于 `T` 来说就是 invariant
  3. contravariant（逆变）：函数对参数的要求越低，参数可发挥的作用越大
    * 例子：函数对其参数类型的逆变
    
```rust
// let x1: &'static str;       作用更大, 活的更长
// let x2: &'a      str;       作用小, 活的短

// fn take_func1(&'static str) 对参数要求比较严格，作用更小
// fn take_func2(&'s str)      对参数要求比较宽松，作用更大
```

### 多生命周期与 Variance

```rust
/*
    s 有两个生命周期
    'a 是可变的
    'b 不可变
*/
struct MutStr<'a, 'b> {
    s: &'a mut &'b str,
}

fn main() {
    let mut r: &str = "hello";     // &'statiic str => &'a str
    /*
        MutStr { s: &mut r } 是创建实例
        .s 可以修改值，所以它是 'a mut 
        &mut r 传入后生命周期就结束了，下边才可以 println

        如果只有一个生命周期，就报错了，
        只有一个生命周期 到 &mut r 其实是缩短了，因为 &mut 是赋值时候发生的
        也就相当于对 r 缩短了，但是 &'statiic str 可替换为 &'a str
        但是 &mut 是精确类型，所以这里缩短借用就会失败
        所以使用一个生命周期就会 Error
     */
    *MutStr { s: &mut r }.s = "world";
    println!("{}", r);   // 是 'b 的生命周期
}
```

    




<!--![image](/assets/images/rust/type/memory_01.png)-->

