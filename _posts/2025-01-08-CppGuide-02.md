---
layout: post
title: CppGuide-02
date: 2025-01-08 16:45:30.000000000 +09:00
categories: [C++]
tags: [C++]
---


# C++ Const 用法

1. 不能修改指针指向的内容的指针: `const int* b = new int;`
2. 不能修改指针指向的地址，即不能指向别的地址: `int* const c = new int;`
3. 既不能修改指针指向的内容，又不能指向别的地址: `const int* const d = new int`
4. 类中的常量方法 `Only in Class` ：`int GetX() const`


> `const int* b = new int` 等价于 `int const* b = new int`。关键是 `const` 在 `*` 之前。
{: .prompt-info }

```c++
#include <iostream>

class Entity {
    
private:
    int m_X, m_Y;
    
    // mutable 允许函数时常量方法，可以修改的变量
    mutable int var;
public:
    /*
     用法三：只在类中有效，即声明这个方法是只读的，不会修改类中成员的值
     如果这样声明了，则方法内不能修改类中成员
     即 m_X = 2; 会报错
     
     记住：总是标记方法为 const，如果它们实际上没有修改类或它们不应该修改类时
     
     ## 另一个 case：
     如果在 const 方法中，想要修改成员的值，比如 debug 用，
     我们可以使用 mutable 关键字，如 mutable int var
     这样 在 GetX() 中就可以修改 var 的值了
     */
    int GetX() const
    {
//        m_X = 2;
        
        var = 2;
        return m_X;
    }
    
    int GetX()
    {
        m_X = 2;
        return m_X;
    }
    
    void Set(int x)
    {
        m_X = x;
    }
    
};

class Entity2 {
    
private:
    int* m_X,  *m_Y; // 这样 m_Y 才是这个指针
     
public:
    const int* const GetX() const
    {
        return m_X;
    }
    
};

void PrintEntity(const Entity& e)
{
//    e = Entity(); // Error: 因为引用就是内容
    
    // e.GetX() 将使用 GetX 的 const 版本
    std::cout << "Entity x is " << e.GetX() << std::endl;
}

int main(int argc, const char * argv[]) {
    
    const int MAX_AGE = 90;
    
    
    int* a = new int;
    *a = 2; // 可以改变指针指向的内容
    std::cout << "a is " << *a << std::endl;
    a = (int*)&MAX_AGE;  // 也可以改变指针指向的地址
    std::cout << "a is " << *a << std::endl;

    // ## 用法一：不能修改指针指向的内容的指针
//    const int* b = new int;
    int const* b = new int;
//    *b = 2; // Error: 不能修改指针指向的内容
    b = (int*)&MAX_AGE; // But 可以修改指针指向的地址
    std::cout << "b is " << *b << std::endl;

    // ## 用法二：不能修改指针指向的地址，即不能指向别的地址
    int* const c = new int;
    *c = 6;
//    c = (int*)&MAX_AGE; // Error:
    std::cout << "c is " << *b << std::endl;
    
    
    // ## 不能修改指针指向的内容的指针，也不能指向别的地址
    const int* const d = new int;
//    *d = 2;              // Error
//    d = (int*)&MAX_AGE;  // Error

    
    Entity e;

    return 0;
}
```


> Tips：`const` 在 `*` 前边：`const int* b = new int;` 不能修改指向的内容。`const` 在 `*` 后边：`int* const b = new int;`，不能指向别的地址。
{: .prompt-info }


# C++ mutable 用法

## mutable 两种用法
1. 与 `const` 一起使用。(常用)
2. 在 `lambda` 表达式中。（用的少）

* 或同时覆盖这两种情况


```c++
#include <iostream>
#include <string>

class Entity {
private:
    std::string m_Name;
    // 用法一：
    mutable int m_DebugCount = 0;
public:
    // const 方法内不能修改类成员
    const std::string& GetName() const
    {
        // 声明为 mutable 可以在常量方法内修改
        m_DebugCount++;
        return m_Name;
    }
};

int main(int argc, const char * argv[]) {
    std::cout << "Hello, World!\n";
    
    const Entity e;
    // const e 只能调用 const 方法
    e.GetName();
    
    
    // # 用法二：lambda
    int x = 8;
    /*
     lambda 函数
     lambda 基本上就像一个一次性小函数
     你可以写出来赋值给一个变量
     */
    auto f = [=]() mutable // Note: 这里参数还是值传递
    {

        x++;
        std::cout << x << std::endl; // x = 9
    };
     
    auto f1 = [=]()
    {
        // 下边两行等于 加 mutable 的 f 里边的 x++
        int y = x;
        y++;
        std::cout << x << std::endl;
    };
    
    
    f();
    std::cout << "extern x is " << x << std::endl; // x = 8

    return 0;
}
```
