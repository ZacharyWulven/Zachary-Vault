---
layout: post
title: CppGuide-02
date: 2025-01-08 16:45:30.000000000 +09:00
categories: [C++]
tags: [C++]
---


# C++ Const 用法

1. 不能修改指针指向的内容的指针: `const int* b = new int;`
2. 不能修改指针指向的地址，即不能指向别的地址: `int* const c = new int;`
3. 既不能修改指针指向的内容，又不能指向别的地址: `const int* const d = new int`
4. 类中的常量方法 `Only in Class` ：`int GetX() const`


> `const int* b = new int` 等价于 `int const* b = new int`。关键是 `const` 在 `*` 之前。
{: .prompt-info }

```c++
#include <iostream>

class Entity {
    
private:
    int m_X, m_Y;
    
    // mutable 允许函数时常量方法，可以修改的变量
    mutable int var;
public:
    /*
     用法三：只在类中有效，即声明这个方法是只读的，不会修改类中成员的值
     如果这样声明了，则方法内不能修改类中成员
     即 m_X = 2; 会报错
     
     记住：总是标记方法为 const，如果它们实际上没有修改类或它们不应该修改类时
     
     ## 另一个 case：
     如果在 const 方法中，想要修改成员的值，比如 debug 用，
     我们可以使用 mutable 关键字，如 mutable int var
     这样 在 GetX() 中就可以修改 var 的值了
     */
    int GetX() const
    {
//        m_X = 2;
        
        var = 2;
        return m_X;
    }
    
    int GetX()
    {
        m_X = 2;
        return m_X;
    }
    
    void Set(int x)
    {
        m_X = x;
    }
    
};

class Entity2 {
    
private:
    int* m_X,  *m_Y; // 这样 m_Y 才是这个指针
     
public:
    const int* const GetX() const
    {
        return m_X;
    }
    
};

void PrintEntity(const Entity& e)
{
//    e = Entity(); // Error: 因为引用就是内容
    
    // e.GetX() 将使用 GetX 的 const 版本
    std::cout << "Entity x is " << e.GetX() << std::endl;
}

int main(int argc, const char * argv[]) {
    
    const int MAX_AGE = 90;
    
    
    int* a = new int;
    *a = 2; // 可以改变指针指向的内容
    std::cout << "a is " << *a << std::endl;
    a = (int*)&MAX_AGE;  // 也可以改变指针指向的地址
    std::cout << "a is " << *a << std::endl;

    // ## 用法一：不能修改指针指向的内容的指针
//    const int* b = new int;
    int const* b = new int;
//    *b = 2; // Error: 不能修改指针指向的内容
    b = (int*)&MAX_AGE; // But 可以修改指针指向的地址
    std::cout << "b is " << *b << std::endl;

    // ## 用法二：不能修改指针指向的地址，即不能指向别的地址
    int* const c = new int;
    *c = 6;
//    c = (int*)&MAX_AGE; // Error:
    std::cout << "c is " << *b << std::endl;
    
    
    // ## 不能修改指针指向的内容的指针，也不能指向别的地址
    const int* const d = new int;
//    *d = 2;              // Error
//    d = (int*)&MAX_AGE;  // Error

    
    Entity e;

    return 0;
}
```


> Tips：`const` 在 `*` 前边：`const int* b = new int;` 不能修改指向的内容。`const` 在 `*` 后边：`int* const b = new int;`，不能指向别的地址。
{: .prompt-info }


# C++ mutable 用法

## mutable 两种用法
1. 与 `const` 一起使用。(常用)
2. 在 `lambda` 表达式中。（用的少）

* 或同时覆盖这两种情况


```c++
#include <iostream>
#include <string>

class Entity {
private:
    std::string m_Name;
    // 用法一：
    mutable int m_DebugCount = 0;
public:
    // const 方法内不能修改类成员
    const std::string& GetName() const
    {
        // 声明为 mutable 可以在常量方法内修改
        m_DebugCount++;
        return m_Name;
    }
};

int main(int argc, const char * argv[]) {
    std::cout << "Hello, World!\n";
    
    const Entity e;
    // const e 只能调用 const 方法
    e.GetName();
    
    
    // # 用法二：lambda
    int x = 8;
    /*
     lambda 函数
     lambda 基本上就像一个一次性小函数
     你可以写出来赋值给一个变量
     */
    auto f = [=]() mutable // Note: 这里参数还是值传递
    {

        x++;
        std::cout << x << std::endl; // x = 9
    };
     
    auto f1 = [=]()
    {
        // 下边两行等于 加 mutable 的 f 里边的 x++
        int y = x;
        y++;
        std::cout << x << std::endl;
    };
    
    
    f();
    std::cout << "extern x is " << x << std::endl; // x = 8

    return 0;
}
```


# C++ 构造函数成员初始化列表
* 即我们在构造函数中初始化类成员（变量）的一种方式
* 格式: `ClassName() : 成员名(入参)`

## 为什么要用成员初始化列表？
1. 代码更整洁
2. 性能会更好：功能上如果直接赋值，成员实际上会被构造两次。


```c++
#include <iostream>
#include <string>

class Example {
    
public:
    Example()
    {
        std::cout << "Created Entity!" << std::endl;
    }
    
    Example(int x)
    {
        std::cout << "Created Entity with " << x << "!" << std::endl;
    }
};

class Entity {

private:
    std::string m_Name;
    int m_Score;
    Example m_Example;
public:
    
    /*
     方法一：赋值初始化成员
     构造函数，是接受 name 作为参数的构造函数
     */
    Entity()
//    Entity() : m_Example(Example(8))
    {
        /*
         Note Note Note：这样实际上 m_Name 对象会被构造两次
         一次是默认构造器，另一次是这个 "Unknown" 赋值
         这里实际是：m_Name = std::string("Unknown")
         这是性能浪费
         */
        m_Name = "Unknown";
        
//        Example m_Example;       // 构造第一次相当于这行
//        m_Example = Example(8);  // 构造第二次
    }
    
    // # 方法二：通过成员初始化列表进行初始化

    /*
     格式 : 成员名(入参)
     Note: 使用成员初始化需要按顺序写，不然有些编译器会警告
     */
//    Entity() : m_Name("Unknown"), m_Score(0)
//    {
//        
//    }
    
    Entity(const std::string& name) : m_Name(name), m_Score(0)
    {
        
    }
    
    const std::string& GetName() const
    {
        return m_Name;
    }
    
};

int main(int argc, const char * argv[]) {

    Entity e0;
    std::cout << e0.GetName() << std::endl;

    Entity e1("Cherno");
    std::cout << e1.GetName() << std::endl;

   
    /*
     演示不使用成员初始化列表，构造两次问题
     创建 Entity
     打印 Created Entity! 和 Created Entity with 8!
     */
    Entity e2;

    return 0;
}
```

> Note: 使用成员初始化需要按顺序写，不然有些编译器会警告。应该总是使用成员初始化列表。
{: .prompt-info }


# C++ 三元操作符
## 优点
1. 性能更好
2. 能让代码更干净


```c++
#include <iostream>
#include <string>

int main(int argc, const char * argv[]) {
    
    int level = 11;

    /*
        这种声明方式，会构造一个空字符串对象，然后用新对象覆盖 otherRank
        下边这段代码从技术上讲更慢一些，因为构造了中间的字符串
     */
    std::string otherRank;
    if (level > 10) {
        otherRank = "Master";
    } else {
        otherRank = "Beginner";
    }
    
    /*
     这里没有构造了中间字符串的原因实际上与返回值优化有关
     返回值优化是一种高级编译器特性
     */
    std::string rank = level > 10 ? "Master" : "Beginner";
    return 0;
}
```


# 创建关键字初始化 C++ 对象与 `new` 关键字

## 创建并初始化 C++ 对象

### 创建对象我们要选择对象要放在哪里？
1. 栈：变量有自己的生存期，它的生存期实际由它声明地方作用域决定的，只要超过作用域，内存就会被释放。当作用域结束时，栈会弹出作用域里的东西
2. 堆：如果对象太大了或你想要显示的控制对象的生存期


> 结论：优先选择在栈上创建对象。就性能而言：在 C++ 中分配对象不应该总是使用 `new`。使用 `new` 需要自己 `delete` 进行内存释放。
{: .prompt-info }


## `new` 关键字（重要）
* 在你写 C++ 程序时，应该关心内存，性能和优化问题
* `new` 分配内存，以字节为单位
* 格式：`new 数据类型`

### `new` Core

* `new` 做两件事
1. 分配内存, 返回空指针（没有类型的指针）
2. 调用构造函数

> `new` 是一个操作符，意味着你可以重载它，改变它的行为
{: .prompt-info }

![image](/assets/images/cpp/new.png)


> 通常，调用 `new`, 会调用隐藏在里边的 `C 函数 malloc()`（它表示分配内存，传入 size 字节，返回空指针）
{: .prompt-info }


```c++
#include <iostream>
#include <string>

// alais
using String = std::string;

class Entity {
private:
    String m_Name;
public:
    Entity() : m_Name("Unknown") {}
    Entity(const String& name) : m_Name(name) {}
    
    const String& GetName() const { return m_Name; }
};


int main(int argc, const char * argv[]) {
    
    // # 在栈上创建对象
    // # 尽量总是在栈上创建对象
    
    /*
     这里看起来想没有初始化
     但是，实际上调用默认的构造器 Entity() : m_Name("Unknown")
     因为 Entity 有默认构造器
     */
    Entity e;
    Entity e2 = Entity("Cherno");
    Entity e3("Cherno");

    std::cout << e.GetName() << std::endl;
    std::cout << e2.GetName() << std::endl;
    std::cout << e3.GetName() << std::endl;

    
    // # 在堆上创建对象
    /*
        有时不能在栈上分配
        比如函数返回值时，你需要控制对象的生存期 或 对象太大了
     */
    
    Entity* entity;
    {
        Entity e4 = Entity("e4");
        
        Entity* eh = new Entity("eh");  // 在堆上分配
        entity = &e4;
        std::cout << "entity name is " << entity->GetName() << std::endl;

        entity = eh;
        std::cout << e4.GetName() << std::endl;
        
        std::cout << "entity name is " << (*entity).GetName() << std::endl;
        std::cout << "entity name is " << entity->GetName() << std::endl;
    }

    delete entity;  // 使用 delete 清理自己 new 的对象
    
    
    // ----------`new` 关键字（重要）---------------------------------
    // 一个 4 字节在堆上分配，b 存储它的内存地址
    int* b = new int;
    int* c = new int[50]; // 200 bytes

    // 使用 new 分配内存并调用构造函数
    // 与下边 malloc 区别是：new 调用了构造函数
    Entity* ne = new Entity();
    // 类似于这样，将 C 中用法用在 C++
    // Note：你不应该在 C++ 中这样分配内存
    Entity* nn = (Entity*)malloc(sizeof(Entity));
    
    /*
        # one more thing: placement new
        即决定使用的内存来自哪里，所以并没有真正分配内存，
        这种情况，你只需要调用构造函数，并在一个特定的内存地址中初始化你的 Entity
        可以通过写 new() 指定内存地址
     */
    Entity* ee = new(c) Entity();

    /*
        delete 也是一个操作符
        delete 调用了 free 函数，free 可以释放 malloc 申请的内存
        
        如果你使用 new，那么必须使用 delete 清理它
     */
    delete ne;
    
    // delete[] 删除数组
    delete[] c;
    
    return 0;
}
```

# 隐式转换与 `explicit` 关键字
* 隐式转换：即不明确告诉它要干什么，有点像自动，通过上下文知道
* 比如：隐式类型转换

> C++ 实际上允许编译器对代码执行一次隐式转换。隐式构造可以简化代码，但尽量避免使用
{: .prompt-info }


## `explicit` 关键字
* 它与隐式转换有关, 因为 `explicit` 会禁用 `implicit`
* `explicit` 放在构造函数前边
  - 构造函数前有 `explicit`, 意味着没有隐式转换
  - 需要显式调用构造函数
* `explicit` 可以防止做意外转换，导致性能问题或 bug


> Note：要意识到隐式构造的存在
{: .prompt-info }


```c++
#include <iostream>
#include <string>

class Entity {
private:
    std::string m_Name;
    int m_Age;
public:
    Entity(const std::string& name) : m_Name(name), m_Age(-1)
    {
        
    }
//    Entity(int age) : m_Name("Unknown"), m_Age(age)
//    {
//        
//    }

    explicit Entity(int age) : m_Name("Unknown"), m_Age(age)
    {
        
    }
    
};

void PrintEntity(const Entity& entity)
{
    // Print
    
}

int main(int argc, const char * argv[]) {
    // insert code here...
    std::cout << "Hello, World!\n" << std::endl;
    
    Entity a("Cherno");
    // 隐式构造
    Entity a1 = std::string("Cherno");
    
    Entity b(22);
    
    /*
        这叫隐式构造：因为有一个 Entity 的构造函数，接受一个 int 参数
     
        explicit 关键字
        如果构造函数前有 explicit，则下边会报错，因为没有了隐式转换
        需要 Entity b2 = (Entity)22; 才行
     */
    Entity b1 = 22;
    Entity b2 = (Entity)22;


    /*
        隐式构造
        25 可以转换为一个 Entity, 因为你可以调用其构造函数
     */
    PrintEntity(25);
    
//    PrintEntity("Cherno"); // 不能这样因为 C++ 只做一次隐式转换，这里是 const char[] 类型
    PrintEntity(std::string("Cherno"));
    return 0;
}
```

# 运算符 & 运算符重载

```c++
#include <iostream>

struct Vector2 {
    float x, y;
    
    Vector2(float x, float y) : x(x), y(y)
    {
        
    }
    
    Vector2 Add(const Vector2& other) const
    {
        return Vector2(x + other.x, y + other.y);
    }
    
    Vector2 Add2(const Vector2& other) const
    {
        return operator+(other);
    }
    
    Vector2 Add3(const Vector2& other) const
    {
        // this 是一个指针，所以 *this
        return *this + other;
    }
    
    // 重载 +运算符
    Vector2 operator+(const Vector2& other) const
    {
        return Add(other);
    }
    
    Vector2 Multiply(const Vector2& other) const
    {
        return Vector2(x * other.x, y * other.y);
    }
    
    // 重载 *运算符
    Vector2 operator*(const Vector2& other) const
    {
        return Multiply(other);
    }
    
    // 重载 ==运算符
    bool operator==(const Vector2& other) const
    {
        return x == other.x && y == other.y;
    }

    // 重载 !=运算符
    bool operator!=(const Vector2& other) const
    {
//        return operator==(other);
        return !(*this == other);
    }
    
};

// 重载 std::cout 的 <<，以便直接打印 Vector2
std::ostream& operator<<(std::ostream& stream, const Vector2& other)
{
    stream << "x is " << other.x << ", y is " << other.y;
    return stream;
}

int main(int argc, const char * argv[]) {
    // insert code here...
    
    Vector2 position(4.0f, 4.0f);
    Vector2 speed(0.5f, 1.5f);
    Vector2 powerup(1.1f, 1.1f);

    Vector2 result1 = position.Add(speed.Multiply(powerup));
    Vector2 result2 = position + speed * powerup;

    
    std::cout << result2 << std::endl; // x is 4.55, y is 5.65
    
    if (result1 == result2) {
        std::cout << "result1 == result2" << std::endl;
    }
    
    return 0;
}
```

> Tips：运算符其实就是函数
{: .prompt-info }
