---
layout: post
title: CppGuide-02
date: 2025-01-08 16:45:30.000000000 +09:00
categories: [C++]
tags: [C++]
---


# C++ Const 用法

1. 不能修改指针指向的内容的指针: `const int* b = new int;`
2. 不能修改指针指向的地址，即不能指向别的地址: `int* const c = new int;`
3. 既不能修改指针指向的内容，又不能指向别的地址: `const int* const d = new int`
4. 类中的常量方法 `Only in Class` ：`int GetX() const`


> `const int* b = new int` 等价于 `int const* b = new int`。关键是 `const` 在 `*` 之前。
{: .prompt-info }

```c++
#include <iostream>

class Entity {
    
private:
    int m_X, m_Y;
    
    // mutable 允许函数时常量方法，可以修改的变量
    mutable int var;
public:
    /*
     用法三：只在类中有效，即声明这个方法是只读的，不会修改类中成员的值
     如果这样声明了，则方法内不能修改类中成员
     即 m_X = 2; 会报错
     
     记住：总是标记方法为 const，如果它们实际上没有修改类或它们不应该修改类时
     
     ## 另一个 case：
     如果在 const 方法中，想要修改成员的值，比如 debug 用，
     我们可以使用 mutable 关键字，如 mutable int var
     这样 在 GetX() 中就可以修改 var 的值了
     */
    int GetX() const
    {
//        m_X = 2;
        
        var = 2;
        return m_X;
    }
    
    int GetX()
    {
        m_X = 2;
        return m_X;
    }
    
    void Set(int x)
    {
        m_X = x;
    }
    
};

class Entity2 {
    
private:
    int* m_X,  *m_Y; // 这样 m_Y 才是这个指针
     
public:
    const int* const GetX() const
    {
        return m_X;
    }
    
};

void PrintEntity(const Entity& e)
{
//    e = Entity(); // Error: 因为引用就是内容
    
    // e.GetX() 将使用 GetX 的 const 版本
    std::cout << "Entity x is " << e.GetX() << std::endl;
}

int main(int argc, const char * argv[]) {
    
    const int MAX_AGE = 90;
    
    
    int* a = new int;
    *a = 2; // 可以改变指针指向的内容
    std::cout << "a is " << *a << std::endl;
    a = (int*)&MAX_AGE;  // 也可以改变指针指向的地址
    std::cout << "a is " << *a << std::endl;

    // ## 用法一：不能修改指针指向的内容的指针
//    const int* b = new int;
    int const* b = new int;
//    *b = 2; // Error: 不能修改指针指向的内容
    b = (int*)&MAX_AGE; // But 可以修改指针指向的地址
    std::cout << "b is " << *b << std::endl;

    // ## 用法二：不能修改指针指向的地址，即不能指向别的地址
    int* const c = new int;
    *c = 6;
//    c = (int*)&MAX_AGE; // Error:
    std::cout << "c is " << *b << std::endl;
    
    
    // ## 不能修改指针指向的内容的指针，也不能指向别的地址
    const int* const d = new int;
//    *d = 2;              // Error
//    d = (int*)&MAX_AGE;  // Error

    
    Entity e;

    return 0;
}
```


> Tips：`const` 在 `*` 前边：`const int* b = new int;` 不能修改指向的内容。`const` 在 `*` 后边：`int* const b = new int;`，不能指向别的地址。
{: .prompt-info }


# C++ mutable 用法

## mutable 两种用法
1. 与 `const` 一起使用。(常用)
2. 在 `lambda` 表达式中。（用的少）

* 或同时覆盖这两种情况


```c++
#include <iostream>
#include <string>

class Entity {
private:
    std::string m_Name;
    // 用法一：
    mutable int m_DebugCount = 0;
public:
    // const 方法内不能修改类成员
    const std::string& GetName() const
    {
        // 声明为 mutable 可以在常量方法内修改
        m_DebugCount++;
        return m_Name;
    }
};

int main(int argc, const char * argv[]) {
    std::cout << "Hello, World!\n";
    
    const Entity e;
    // const e 只能调用 const 方法
    e.GetName();
    
    
    // # 用法二：lambda
    int x = 8;
    /*
     lambda 函数
     lambda 基本上就像一个一次性小函数
     你可以写出来赋值给一个变量
     */
    auto f = [=]() mutable // Note: 这里参数还是值传递
    {

        x++;
        std::cout << x << std::endl; // x = 9
    };
     
    auto f1 = [=]()
    {
        // 下边两行等于 加 mutable 的 f 里边的 x++
        int y = x;
        y++;
        std::cout << x << std::endl;
    };
    
    
    f();
    std::cout << "extern x is " << x << std::endl; // x = 8

    return 0;
}
```


# C++ 构造函数成员初始化列表
* 即我们在构造函数中初始化类成员（变量）的一种方式
* 格式: `ClassName() : 成员名(入参)`

## 为什么要用成员初始化列表？
1. 代码更整洁
2. 性能会更好：功能上如果直接赋值，成员实际上会被构造两次。


```c++
#include <iostream>
#include <string>

class Example {
    
public:
    Example()
    {
        std::cout << "Created Entity!" << std::endl;
    }
    
    Example(int x)
    {
        std::cout << "Created Entity with " << x << "!" << std::endl;
    }
};

class Entity {

private:
    std::string m_Name;
    int m_Score;
    Example m_Example;
public:
    
    /*
     方法一：赋值初始化成员
     构造函数，是接受 name 作为参数的构造函数
     */
    Entity()
//    Entity() : m_Example(Example(8))
    {
        /*
         Note Note Note：这样实际上 m_Name 对象会被构造两次
         一次是默认构造器，另一次是这个 "Unknown" 赋值
         这里实际是：m_Name = std::string("Unknown")
         这是性能浪费
         */
        m_Name = "Unknown";
        
//        Example m_Example;       // 构造第一次相当于这行
//        m_Example = Example(8);  // 构造第二次
    }
    
    // # 方法二：通过成员初始化列表进行初始化

    /*
     格式 : 成员名(入参)
     Note: 使用成员初始化需要按顺序写，不然有些编译器会警告
     */
//    Entity() : m_Name("Unknown"), m_Score(0)
//    {
//        
//    }
    
    Entity(const std::string& name) : m_Name(name), m_Score(0)
    {
        
    }
    
    const std::string& GetName() const
    {
        return m_Name;
    }
    
};

int main(int argc, const char * argv[]) {

    Entity e0;
    std::cout << e0.GetName() << std::endl;

    Entity e1("Cherno");
    std::cout << e1.GetName() << std::endl;

   
    /*
     演示不使用成员初始化列表，构造两次问题
     创建 Entity
     打印 Created Entity! 和 Created Entity with 8!
     */
    Entity e2;

    return 0;
}
```

> Note: 使用成员初始化需要按顺序写，不然有些编译器会警告。应该总是使用成员初始化列表。
{: .prompt-info }
