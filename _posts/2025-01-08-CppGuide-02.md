---
layout: post
title: CppGuide-02
date: 2025-01-08 16:45:30.000000000 +09:00
categories: [C++]
tags: [C++]
---


# C++ Const 用法

1. 不能修改指针指向的内容的指针: `const int* b = new int;`
2. 不能修改指针指向的地址，即不能指向别的地址: `int* const c = new int;`
3. 既不能修改指针指向的内容，又不能指向别的地址: `const int* const d = new int`
4. 类中的常量方法 `Only in Class` ：`int GetX() const`


> `const int* b = new int` 等价于 `int const* b = new int`。关键是 `const` 在 `*` 之前。
{: .prompt-info }

```c++
#include <iostream>

class Entity {
    
private:
    int m_X, m_Y;
    
    // mutable 允许函数时常量方法，可以修改的变量
    mutable int var;
public:
    /*
     用法三：只在类中有效，即声明这个方法是只读的，不会修改类中成员的值
     如果这样声明了，则方法内不能修改类中成员
     即 m_X = 2; 会报错
     
     记住：总是标记方法为 const，如果它们实际上没有修改类或它们不应该修改类时
     
     ## 另一个 case：
     如果在 const 方法中，想要修改成员的值，比如 debug 用，
     我们可以使用 mutable 关键字，如 mutable int var
     这样 在 GetX() 中就可以修改 var 的值了
     */
    int GetX() const
    {
//        m_X = 2;
        
        var = 2;
        return m_X;
    }
    
    int GetX()
    {
        m_X = 2;
        return m_X;
    }
    
    void Set(int x)
    {
        m_X = x;
    }
    
};

class Entity2 {
    
private:
    int* m_X,  *m_Y; // 这样 m_Y 才是这个指针
     
public:
    const int* const GetX() const
    {
        return m_X;
    }
    
};

void PrintEntity(const Entity& e)
{
//    e = Entity(); // Error: 因为引用就是内容
    
    // e.GetX() 将使用 GetX 的 const 版本
    std::cout << "Entity x is " << e.GetX() << std::endl;
}

int main(int argc, const char * argv[]) {
    
    const int MAX_AGE = 90;
    
    
    int* a = new int;
    *a = 2; // 可以改变指针指向的内容
    std::cout << "a is " << *a << std::endl;
    a = (int*)&MAX_AGE;  // 也可以改变指针指向的地址
    std::cout << "a is " << *a << std::endl;

    // ## 用法一：不能修改指针指向的内容的指针
//    const int* b = new int;
    int const* b = new int;
//    *b = 2; // Error: 不能修改指针指向的内容
    b = (int*)&MAX_AGE; // But 可以修改指针指向的地址
    std::cout << "b is " << *b << std::endl;

    // ## 用法二：不能修改指针指向的地址，即不能指向别的地址
    int* const c = new int;
    *c = 6;
//    c = (int*)&MAX_AGE; // Error:
    std::cout << "c is " << *b << std::endl;
    
    
    // ## 不能修改指针指向的内容的指针，也不能指向别的地址
    const int* const d = new int;
//    *d = 2;              // Error
//    d = (int*)&MAX_AGE;  // Error

    
    Entity e;

    return 0;
}
```


> Tips：`const` 在 `*` 前边：`const int* b = new int;` 不能修改指向的内容。`const` 在 `*` 后边：`int* const b = new int;`，不能指向别的地址。
{: .prompt-info }


# C++ mutable 用法

## mutable 两种用法
1. 与 `const` 一起使用。(常用)
2. 在 `lambda` 表达式中。（用的少）

* 或同时覆盖这两种情况


```c++
#include <iostream>
#include <string>

class Entity {
private:
    std::string m_Name;
    // 用法一：
    mutable int m_DebugCount = 0;
public:
    // const 方法内不能修改类成员
    const std::string& GetName() const
    {
        // 声明为 mutable 可以在常量方法内修改
        m_DebugCount++;
        return m_Name;
    }
};

int main(int argc, const char * argv[]) {
    std::cout << "Hello, World!\n";
    
    const Entity e;
    // const e 只能调用 const 方法
    e.GetName();
    
    
    // # 用法二：lambda
    int x = 8;
    /*
     lambda 函数
     lambda 基本上就像一个一次性小函数
     你可以写出来赋值给一个变量
     */
    auto f = [=]() mutable // Note: 这里参数还是值传递
    {

        x++;
        std::cout << x << std::endl; // x = 9
    };
     
    auto f1 = [=]()
    {
        // 下边两行等于 加 mutable 的 f 里边的 x++
        int y = x;
        y++;
        std::cout << x << std::endl;
    };
    
    
    f();
    std::cout << "extern x is " << x << std::endl; // x = 8

    return 0;
}
```


# C++ 构造函数成员初始化列表
* 即我们在构造函数中初始化类成员（变量）的一种方式
* 格式: `ClassName() : 成员名(入参)`

## 为什么要用成员初始化列表？
1. 代码更整洁
2. 性能会更好：功能上如果直接赋值，成员实际上会被构造两次。


```c++
#include <iostream>
#include <string>

class Example {
    
public:
    Example()
    {
        std::cout << "Created Entity!" << std::endl;
    }
    
    Example(int x)
    {
        std::cout << "Created Entity with " << x << "!" << std::endl;
    }
};

class Entity {

private:
    std::string m_Name;
    int m_Score;
    Example m_Example;
public:
    
    /*
     方法一：赋值初始化成员
     构造函数，是接受 name 作为参数的构造函数
     */
    Entity()
//    Entity() : m_Example(Example(8))
    {
        /*
         Note Note Note：这样实际上 m_Name 对象会被构造两次
         一次是默认构造器，另一次是这个 "Unknown" 赋值
         这里实际是：m_Name = std::string("Unknown")
         这是性能浪费
         */
        m_Name = "Unknown";
        
//        Example m_Example;       // 构造第一次相当于这行
//        m_Example = Example(8);  // 构造第二次
    }
    
    // # 方法二：通过成员初始化列表进行初始化

    /*
     格式 : 成员名(入参)
     Note: 使用成员初始化需要按顺序写，不然有些编译器会警告
     */
//    Entity() : m_Name("Unknown"), m_Score(0)
//    {
//        
//    }
    
    Entity(const std::string& name) : m_Name(name), m_Score(0)
    {
        
    }
    
    const std::string& GetName() const
    {
        return m_Name;
    }
    
};

int main(int argc, const char * argv[]) {

    Entity e0;
    std::cout << e0.GetName() << std::endl;

    Entity e1("Cherno");
    std::cout << e1.GetName() << std::endl;

   
    /*
     演示不使用成员初始化列表，构造两次问题
     创建 Entity
     打印 Created Entity! 和 Created Entity with 8!
     */
    Entity e2;

    return 0;
}
```

> Note: 使用成员初始化需要按顺序写，不然有些编译器会警告。应该总是使用成员初始化列表。
{: .prompt-info }


# C++ 三元操作符
## 优点
1. 性能更好
2. 能让代码更干净


```c++
#include <iostream>
#include <string>

int main(int argc, const char * argv[]) {
    
    int level = 11;

    /*
        这种声明方式，会构造一个空字符串对象，然后用新对象覆盖 otherRank
        下边这段代码从技术上讲更慢一些，因为构造了中间的字符串
     */
    std::string otherRank;
    if (level > 10) {
        otherRank = "Master";
    } else {
        otherRank = "Beginner";
    }
    
    /*
     这里没有构造了中间字符串的原因实际上与返回值优化有关
     返回值优化是一种高级编译器特性
     */
    std::string rank = level > 10 ? "Master" : "Beginner";
    return 0;
}
```


# 创建关键字初始化 C++ 对象与 `new` 关键字

## 创建并初始化 C++ 对象

### 创建对象我们要选择对象要放在哪里？
1. 栈：变量有自己的生存期，它的生存期实际由它声明地方作用域决定的，只要超过作用域，内存就会被释放。当作用域结束时，栈会弹出作用域里的东西
2. 堆：如果对象太大了或你想要显示的控制对象的生存期


> 结论：优先选择在栈上创建对象。就性能而言：在 C++ 中分配对象不应该总是使用 `new`。使用 `new` 需要自己 `delete` 进行内存释放。
{: .prompt-info }


## `new` 关键字（重要）
* 在你写 C++ 程序时，应该关心内存，性能和优化问题
* `new` 分配内存，以字节为单位
* 格式：`new 数据类型`

### `new` Core

* `new` 做两件事
1. 分配内存, 返回空指针（没有类型的指针）
2. 调用构造函数

> `new` 是一个操作符，意味着你可以重载它，改变它的行为
{: .prompt-info }

![image](/assets/images/cpp/new.png)


> 通常，调用 `new`, 会调用隐藏在里边的 `C 函数 malloc()`（它表示分配内存，传入 size 字节，返回空指针）
{: .prompt-info }


```c++
#include <iostream>
#include <string>

// alais
using String = std::string;

class Entity {
private:
    String m_Name;
public:
    Entity() : m_Name("Unknown") {}
    Entity(const String& name) : m_Name(name) {}
    
    const String& GetName() const { return m_Name; }
};


int main(int argc, const char * argv[]) {
    
    // # 在栈上创建对象
    // # 尽量总是在栈上创建对象
    
    /*
     这里看起来想没有初始化
     但是，实际上调用默认的构造器 Entity() : m_Name("Unknown")
     因为 Entity 有默认构造器
     */
    Entity e;
    Entity e2 = Entity("Cherno");
    Entity e3("Cherno");

    std::cout << e.GetName() << std::endl;
    std::cout << e2.GetName() << std::endl;
    std::cout << e3.GetName() << std::endl;

    
    // # 在堆上创建对象
    /*
        有时不能在栈上分配
        比如函数返回值时，你需要控制对象的生存期 或 对象太大了
     */
    
    Entity* entity;
    {
        Entity e4 = Entity("e4");
        
        Entity* eh = new Entity("eh");  // 在堆上分配
        entity = &e4;
        std::cout << "entity name is " << entity->GetName() << std::endl;

        entity = eh;
        std::cout << e4.GetName() << std::endl;
        
        std::cout << "entity name is " << (*entity).GetName() << std::endl;
        std::cout << "entity name is " << entity->GetName() << std::endl;
    }

    delete entity;  // 使用 delete 清理自己 new 的对象
    
    
    // ----------`new` 关键字（重要）---------------------------------
    // 一个 4 字节在堆上分配，b 存储它的内存地址
    int* b = new int;
    int* c = new int[50]; // 200 bytes

    // 使用 new 分配内存并调用构造函数
    // 与下边 malloc 区别是：new 调用了构造函数
    Entity* ne = new Entity();
    // 类似于这样，将 C 中用法用在 C++
    // Note：你不应该在 C++ 中这样分配内存
    Entity* nn = (Entity*)malloc(sizeof(Entity));
    
    /*
        # one more thing: placement new
        即决定使用的内存来自哪里，所以并没有真正分配内存，
        这种情况，你只需要调用构造函数，并在一个特定的内存地址中初始化你的 Entity
        可以通过写 new() 指定内存地址
     */
    Entity* ee = new(c) Entity();

    /*
        delete 也是一个操作符
        delete 调用了 free 函数，free 可以释放 malloc 申请的内存
        
        如果你使用 new，那么必须使用 delete 清理它
     */
    delete ne;
    
    // delete[] 删除数组
    delete[] c;
    
    return 0;
}
```

# 隐式转换与 `explicit` 关键字
* 隐式转换：即不明确告诉它要干什么，有点像自动，通过上下文知道
* 比如：隐式类型转换

> C++ 实际上允许编译器对代码执行一次隐式转换。隐式构造可以简化代码，但尽量避免使用
{: .prompt-info }


## `explicit` 关键字
* 它与隐式转换有关, 因为 `explicit` 会禁用 `implicit`
* `explicit` 放在构造函数前边
  - 构造函数前有 `explicit`, 意味着没有隐式转换
  - 需要显式调用构造函数
* `explicit` 可以防止做意外转换，导致性能问题或 bug


> Note：要意识到隐式构造的存在
{: .prompt-info }


```c++
#include <iostream>
#include <string>

class Entity {
private:
    std::string m_Name;
    int m_Age;
public:
    Entity(const std::string& name) : m_Name(name), m_Age(-1)
    {
        
    }
//    Entity(int age) : m_Name("Unknown"), m_Age(age)
//    {
//        
//    }

    explicit Entity(int age) : m_Name("Unknown"), m_Age(age)
    {
        
    }
    
};

void PrintEntity(const Entity& entity)
{
    // Print
    
}

int main(int argc, const char * argv[]) {
    // insert code here...
    std::cout << "Hello, World!\n" << std::endl;
    
    Entity a("Cherno");
    // 隐式构造
    Entity a1 = std::string("Cherno");
    
    Entity b(22);
    
    /*
        这叫隐式构造：因为有一个 Entity 的构造函数，接受一个 int 参数
     
        explicit 关键字
        如果构造函数前有 explicit，则下边会报错，因为没有了隐式转换
        需要 Entity b2 = (Entity)22; 才行
     */
    Entity b1 = 22;
    Entity b2 = (Entity)22;


    /*
        隐式构造
        25 可以转换为一个 Entity, 因为你可以调用其构造函数
     */
    PrintEntity(25);
    
//    PrintEntity("Cherno"); // 不能这样因为 C++ 只做一次隐式转换，这里是 const char[] 类型
    PrintEntity(std::string("Cherno"));
    return 0;
}
```

# 运算符 & 运算符重载

```c++
#include <iostream>

struct Vector2 {
    float x, y;
    
    Vector2(float x, float y) : x(x), y(y)
    {
        
    }
    
    Vector2 Add(const Vector2& other) const
    {
        return Vector2(x + other.x, y + other.y);
    }
    
    Vector2 Add2(const Vector2& other) const
    {
        return operator+(other);
    }
    
    Vector2 Add3(const Vector2& other) const
    {
        // this 是一个指针，所以 *this
        return *this + other;
    }
    
    // 重载 +运算符
    Vector2 operator+(const Vector2& other) const
    {
        return Add(other);
    }
    
    Vector2 Multiply(const Vector2& other) const
    {
        return Vector2(x * other.x, y * other.y);
    }
    
    // 重载 *运算符
    Vector2 operator*(const Vector2& other) const
    {
        return Multiply(other);
    }
    
    // 重载 ==运算符
    bool operator==(const Vector2& other) const
    {
        return x == other.x && y == other.y;
    }

    // 重载 !=运算符
    bool operator!=(const Vector2& other) const
    {
//        return operator==(other);
        return !(*this == other);
    }
    
};

// 重载 std::cout 的 <<，以便直接打印 Vector2
std::ostream& operator<<(std::ostream& stream, const Vector2& other)
{
    stream << "x is " << other.x << ", y is " << other.y;
    return stream;
}

int main(int argc, const char * argv[]) {
    // insert code here...
    
    Vector2 position(4.0f, 4.0f);
    Vector2 speed(0.5f, 1.5f);
    Vector2 powerup(1.1f, 1.1f);

    Vector2 result1 = position.Add(speed.Multiply(powerup));
    Vector2 result2 = position + speed * powerup;

    
    std::cout << result2 << std::endl; // x is 4.55, y is 5.65
    
    if (result1 == result2) {
        std::cout << "result1 == result2" << std::endl;
    }
    
    return 0;
}
```

> Tips：运算符其实就是函数
{: .prompt-info }


# C++ `this` 关键字

```c++
void PrintEntity(Entity* e);

class Entity {
    
public:
    int x, y;
    
    Entity(int x, int y)
    {
        // 在非 const 函数中 this 的类型 Entity* const
        // 这就是 this: Entity* const this
        Entity* const e = this;
//        Entity* const & e = this;
        
        this->x = x;
//        (*this).x = x;
        this->y = y;
        
        Entity& ne = *this;
        
        PrintEntity(this);
    }
    
    int GetX() const
    {
        // 在 const 函数中 this 的类型是 const Entity* const
        const Entity *e = this;
        
        return x;
    }
    
    
};

void PrintEntity(Entity* e)
{
    
    
}
```

> `this` 是一个指向当前对象实例的指针
{: .prompt-info }


# C++ 对象的生存期（栈作用域生存期）
* 栈可以被认为是一种数据结构

> 你在栈上创建的对象，当它超出作用域范围时，它就会被销毁
{: .prompt-info }

```c++
#include <iostream>

class Entity {
    
public:
    int x; // 这个变量在这个类的作用域中
    
    Entity()
    {
        std::cout << "Created Entity!" << std::endl;
    }
    
    ~Entity()
    {
        std::cout << "Destroyed Entity!" << std::endl;
    }
    
};

int* CreateArray()
{
    
//    int array[50]; // 在栈上创建数组，函数返回它会被销毁，这样是不对的
    /*
        fixed proposal 有两种：
        1. 在堆上分配
        2. 将这里创建的数据复制给一个在栈作用域之外存在的变量
     */
    int* array = new int[50];
    return array;
}

void CreateArray2(int* array)
{
    // fill our array
}

int main(int argc, const char * argv[]) {
    
    {
        Entity e; // 在栈上创建 Entity 对象
    }   // 离开作用域，在在栈上创建 Entity 对象 e 将被销毁
    
    
    int array[50];

    // fixed proposal 2. 将这里创建的数据复制给一个在栈作用域之外存在的变量
    CreateArray2(array);
    
    return 0;
}
```

## 作用域指针
* 栈作用域可以帮我们自动化代码，例如智能指针，作用域指针或作用域锁
* 作用域指针
1. 基本上是一个类，它是一个指针的包装器
2. 在构造时用堆分配指针，然后析构时删除指针，所以我们可以自动化这个 new 和 delete


```c++
#include <iostream>

class Entity {
    
public:
    
    Entity()
    {
        std::cout << "Created Entity!" << std::endl;
    }
    
    ~Entity()
    {
        std::cout << "Destroyed Entity!" << std::endl;
    }
    
};

// 这是一个基本的作用域指针（类）
class ScopedPtr {
    
private:
    Entity* m_Ptr;
public:
    ScopedPtr(Entity* ptr) : m_Ptr(ptr)
    {
        
    }
    ~ScopedPtr()
    {
        delete m_Ptr;
    }
};

int main(int argc, const char * argv[]) {    
    // ## 作用域指针
    {
        /*
            我们用 new 创建 Entity 对象，想在超出作用域时，让它自动删除
            可以做到吗？答案是可以，我们可以使用标准库中的 unique_ptr(作用域指针)
            这里例子中，我们自己编写代码，以便可以看到它如何工作，
            我们写一个 ScopedPtr 类
         */
//        Entity* e = new Entity();
        
        /*
            这个 ScopedPtr 在栈上分配
            走出作用域时 Entity() 就被销毁了，因为会调用 ScopedPtr 的析构函数
         
            这种 ScopedPtr 自动构造，自动析构，是非常有用的
         */
        ScopedPtr e = new Entity(); // 这样初始化是因为隐式转换
    } // 离开作用域，Entity() 将被销毁
    return 0;
}
```
> 这种 ScopedPtr 自动构造，自动析构，是非常有用的。比如 `Timer` 类，可以在对象构造时启动 `Timer`, 析构时停止`Timer`。这样一旦它超出作用域会自己停止。
或者作用域锁，在函数开头锁住，在函数结束时解锁。
{: .prompt-info }


# C++ 智能指针（`shared_ptr` 和 `unique_ptr`）
* 智能指针是实现了内存释放自动化的一种方式
* 智能指针让你调用 `new` 之后，不需要调用 `delete`, 甚至不需要调用 `new`
* 智能指针本质上是一个原始指针的包装，当你创建一个智能指针，它会调用 `new` 并为你分配内存，然后基于你使用的智能指针，这些内存会在某一时刻自动释放


## `unique_ptr`  (最简单的智能指针)
* 它是一个作用域指针，当超出作用域时，它会被销毁，然后调用 `delete`, 低开销
* 你不能复制 `unique_ptr`
    - 因为如果你复制一个 `unique_ptr`，那么会有两个指针指向同一块内存，如果其中一个被销毁了，它会释放那块内存，也就是说，你指向同一块内存的第二个 `unique_ptr` 指向了已经被释放的内存
    
    
```c++
#include <iostream>
#include <string>
#include <memory>

class Entity {
    
public:
    Entity()
    {
        std::cout << "Created Entity!" << std::endl;
    }
    
    ~Entity()
    {
        std::cout << "Destroyed Entity!" << std::endl;
    }
    
    void Print()
    {
        std::cout << "Print Entity" << std::endl;
    }
};

int main(int argc, const char * argv[]) {
    
    {
        std::shared_ptr<Entity> e0;
        {
            // ## unique_ptr
            // 创建 unique_ptr
            //        std::unique_ptr<Entity> entity(new Entity());
            
            /*
             最佳实践：通过 std::make_unique 创建 unique_ptr
             如果因为构造函数抛出异常，make_unique 会安全一些，
             您最终不会得到一个没有引用的悬空指针，从而造成内存泄漏
             */
            std::unique_ptr<Entity> entity1 = std::make_unique<Entity>();
            // 调用方法
            entity1->Print();
            
            // Error：不能 Copy unique_ptr，其拷贝构造函数和拷贝构造操作符被删除了
            //        std::unique_ptr<Entity> e0 = entity1;
            
        } // 当作用域结束时，entity1 会被自动销毁
        
    }
    return 0;
}
```

> 最佳实践：通过 `std::make_unique` 创建 `unique_ptr` 更安全些
{: .prompt-info }



## `shared_ptr` (共享指针)
* 它使用引用计数, 有一点开销，因为它的引用计数系统


```c++
#include <iostream>
#include <string>
#include <memory>

class Entity {
    
public:
    Entity()
    {
        std::cout << "Created Entity!" << std::endl;
    }
    
    ~Entity()
    {
        std::cout << "Destroyed Entity!" << std::endl;
    }
    
    void Print()
    {
        std::cout << "Print Entity" << std::endl;
    }
};


int main(int argc, const char * argv[]) {
    
    {
        std::shared_ptr<Entity> e0;
//        std::weak_ptr<Entity> e0;
        
        {
            // ## 共享指针 shared_ptr
            std::shared_ptr<Entity> sharedEntity = std::make_shared<Entity>();
            
            
            /*
             不应该使用 new 创建 shared_ptr
             对于 unique_ptr 不直接调用 new 是因为异常安全
             但是在 shared_ptr 中，有所不同
             shared_ptr 需要分配另一块内存，叫控制块，用于存储引用计数
             如果你通过 new 创建 Entity 然后传入给 shared_ptr 构造函数，
             它必须分配 2 次内存，先做一次 new Entity 分配，然后是 shared_ptr
             的控制内存块分配，
             但是，如果用 std::make_shared 会更有效率
             */
            //        std::shared_ptr<Entity> sharedEntity1(new Entity());
            
            
            // 弱引用指针：weak_ptr 不会增加引用计数
            std::weak_ptr<Entity> weakEntity = sharedEntity;
            e0 = sharedEntity;
        }
        
//        std::cout << e0 << std::endl;

    }
    return 0;
}
```

> `shared_ptr` 和 `unique_ptr` 并没有取代 `new` 和 `delete`。有时也需要使用 `new` 和 `delete`。
{: .prompt-info }

> 当你生命一个堆分配的对象，并且不希望自己来清理内存，因为你不想显式调用 `delete` 或显式管理内存时，这时就应该使用智能指针，尽量优先使用 `unique_ptr`，因为它有较低的开销。但当你需要对象之间共享不能使用 `unique_ptr` 时，就使用 `shared_ptr`
{: .prompt-info }

> Tips：选择智能指针顺序，优先选择 `unique_ptr`，然后才是 `shared_ptr`
{: .prompt-info }


# C++ 复制与拷贝构造函数
* 拷贝需要时间，有性能消耗
* 当你编写一个变量，赋值给另一变量的代码时，你总是在复制。在指针情况下，你在复制指针，也就是内存地址（数字而已），而不是指针指向的实际内存。
* 构造函数: 是一个构造函数，当你复制第二个字符串时，它会被调用。


```c++
#include <iostream>
#include <string>

struct Vector2 {
    float x, y;
};

class String {
private:
    char* m_Buffer;
    unsigned int m_Size;
public:
    String(const char* string) 
    {
        m_Size = strlen(string);
        m_Buffer = new char[m_Size + 1];     // Note: + 1 为了 '\0'
        memcpy(m_Buffer, string, m_Size + 1);
        
        // 或这样
//        memcpy(m_Buffer, string, m_Size);
//        m_Buffer[m_Size] = 0;
    }
    
    /*
        下边是 C++ 默认复制构造函数，就是内存复制
        将 other 对象内存，浅层拷贝进这些成员变量
     */
//    String(const String& other) : m_Buffer(other.m_Buffer), m_Size(other.m_Size)
//    {
//        
//    }
    
    // 禁用拷贝构造函数
//    String(const String& other) = delete;
    
    
    // 自定义的深拷贝的拷贝构造函数
    String(const String& other) : m_Size(other.m_Size)
    {
        std::cout << "Copied String!" << std::endl;

        m_Buffer = new char[m_Size + 1];
        memcpy(m_Buffer, other.m_Buffer, m_Size + 1);
    }
    
    ~String()
    {
        delete[] m_Buffer;
    }
    
    char& operator[](unsigned int index)
    {
        return m_Buffer[index];
    }
    
    friend std::ostream& operator<<(std::ostream& stream, const String& string);
};

std::ostream& operator<<(std::ostream& stream, const String& string)
{
    stream << string.m_Buffer;
    return stream;
}

//void PrintString(String string) // 这样会每次 Copy string，调用其拷贝构造函数，没有必要
void PrintString(const String& string) // 修改为引用，const String&, 总是通过 const 引用去传递对象
{
    String copy = string;
    std::cout << string << std::endl;
}

int main(int argc, const char * argv[]) {
    // insert code here...
    std::cout << "Hello, World!\n";
    
    Vector2 a = { 2, 3 };
    Vector2 b = a;   // Copy Value, a 与 b 占不同的内存地址
    b.x = 5;
    
    Vector2* m = new Vector2();
    /*
     当你编写一个变量，赋值给另一变量的代码时，你总是在复制，
     在指针情况下，你在复制指针，也就是内存地址（数字而已），而不是指针指向的实际内存
     */
    Vector2* n = m;  // Copy 指针
    n->x = 2;  // 同时影响 m 和 n，因为它们指向同一内存地址
    
    std::cout << m->x << std::endl;
    std::cout << n->x << std::endl;


    /// --------------------------------------------------
    String string = "Cherno";
    /*
     如果没有实现深拷贝的拷贝构造函数：
     
     这里做到是复制，当我们 Copy String 时，
     C++ 自动为我们做的是将所有类的成员变量，
     将他们复制到一个新的内存地址里，这新的内存地址包含了 second 字符串
     这里发生的是浅拷贝，会复制 char* m_Buffer 指针
     两个 String 有相同的 char* m_Buffer 值
     程序崩溃是因为，到达作用域结束时，两个 String 都被销毁，
     然后调用 delete[] m_Buffer 两次，程序试图释放同一块内存两次
     */
    String second = string;
    
    second[2] = 'A';
    
    PrintString(string); // Copied String!
    PrintString(second);

//    std::cout << string << std::endl;
//    std::cout << second << std::endl;

    return 0;
}
```


> 重要 Tips: 函数参数中应该总是尽量优先通过 `const 引用` 去传递对象。这样可以减少不必要的 `Copy`
{: .prompt-info }


# C++ 箭头操作符(->)

## 箭头操作符以及其重载


```c++
#include <iostream>
#include <string>

class Entity {
public:
    int x;
public:
    void Print() const
    {
        std::cout << "Hello!" << std::endl;
    }
};

class ScopedPtr {
    
private:
    Entity* m_Obj;
public:
    ScopedPtr(Entity* entity) : m_Obj(entity)
    {
        
    }
    ~ScopedPtr()
    {
        delete m_Obj;
    }
    
    Entity* GetObject() { return m_Obj; }
    
    Entity* operator->()             // "重载 -> 操作符"
    {
        return m_Obj;
    }
    
    const Entity* operator->() const // "重载 -> 操作符"
    {
        return m_Obj;
    }
};


int main(int argc, const char * argv[]) {
    // insert code here...
    std::cout << "Hello, World!\n";
    
    
    // -> 基本用法 ptr->x = 2
    Entity e;
    e.Print();
    
    Entity *ptr = &e;
    Entity& entity = *ptr;
    entity.Print();
    (*ptr).Print();
    ptr->Print();
    
    ptr->x = 2;
    
    
    // ------重载 -> 操作符--------------------------
    std::cout << "重载 -> 操作符" << std::endl;
    
    const ScopedPtr entity0 = new Entity();
//    entity0.GetObject()->Print();
    entity0->Print(); // 重载 -> 操作符后，可直接调用 Print 方法
    
    return 0;
}
```

## 使用箭头操作符，获取内存中成员变量的偏移量

```c++
struct Vector3 {
    float x;
    float y; // y 偏移量是 4 字节
    float z; // z 偏移量是 8 字节
};

int main(int argc, const char * argv[]) {
     
    // ------使用箭头操作符，获取内存中成员变量的偏移量--------------------------
    // 想找出变量 y 在内存中的偏移量
    
    // 取得 x 的偏移量，因为从 0 开始
    &((Vector3*)0)->x;  // 等于 &((Vector3*)nullptr)->x;
    
    
//    int offset = (int)&((Vector3*)nullptr)->x;
    int offset = (uintptr_t)&((Vector3*)nullptr)->y;  // Xcode 中
    std::cout << "y is "<< offset << std::endl;   // 4
    
    return 0;
}
```

# C++ 动态数组(Vector)
* 标准库在 Vector 这种情况下应该叫标准模版库，本质上是一个库，可以模版化一些东西
* 容器包含数据类型，实际上由你决定
* 模版可以处理你提供的底层数据类型
* EASTL(EA标准模版库)

```c++
#include <iostream>
#include <string>
#include <vector>

struct Vertex {
    float x, y, z;
};


std::ostream& operator<<(std::ostream& stream, const Vertex& vertex)
{
    stream << vertex.x << ", " << vertex.y << ", " << vertex.z;
    return stream;
}

// 参数使用引用 &，这样确保没有把整个数组复制到这个函数中
void Function(const std::vector<Vertex>& vertices)
{
    
}


int main(int argc, const char * argv[]) {
    
    // Vertex* vertices = new Vertex[5];
    
    // 这是 C++ 模版，你可以这样传递基本类型
    // std::vector<int> vertices2;
    std::vector<Vertex> vertices;
    vertices.push_back({1, 2, 3});
    vertices.push_back({4, 5, 6});
    
    Function(vertices);

    for (int i = 0; i < vertices.size(); i++) {
        std::cout << vertices[i] << std::endl;
    }
    
    /*
     erase 返回 vector_iterator
     erase 参数是一个迭代器
     */
    vertices.erase(vertices.begin() + 1); // 将第二元素删除

    
//    for (Vertex v : vertices) { 这实际上将每个 vertex 复制到这个 for 范围循环中
    for (const Vertex& v : vertices) { // 改为 Vertex& 引用，避免复制数据
        std::cout << v << std::endl;
    }
    
    vertices.clear(); // 让 size 清零
    
    return 0;
}
```

> 重要 Tips: 函数参数中应该总是尽量优先通过 `const 引用` 去传递对象。这样可以减少不必要的 `Copy`
{: .prompt-info }
