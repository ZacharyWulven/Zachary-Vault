---
layout: post
title: RustGuide-02
date: 2023-03-11 16:45:30.000000000 +09:00
categories: [Rust]
tags: [Rust]
---

# 所有权（Rust Core）
* 所有权时 Rust 最独特的特性，它让 Rust 无需 GC 就可以保证内存安全

## 什么是所有权
* 所有程序在运行时都必须管理它们使用计算机内存的方式
1. 有些语言有垃圾回收机制，在程序运行时它们会不断寻找不用的内存
2. 有些语言程序员需要显示的分配和释放内存

* 而 Rust 使用第三种方式
1. 内存是通过所有权系统管理的，其中包含一组编译器在编译时检查的规则
2. 在程序运行时所有权特性不会减慢程序的运行速度

## Stack（栈内存）VS Heap（堆内存）
* 一个值在 stack 上还是 heap 上对语言的行为和你要做某些决定是有很大影响的

## Stack 栈内存
* 按值的接收顺序存储，按相反的顺序将它们移除（后进先出，LIFO）
1. 添加数据叫压入栈
2. 移除数据叫弹出栈

* 所有存储在 stack 上的数据必须拥有已知的固定的大小

## Heap 堆内存
* 编译时大小未知的数据或运行时大小可能发生变化的数据必须存放在 heap 上
* heap 的内存组织性差一些，当你把数据放入 heap 时，你会请求一定数量的空间
* 操作系统在 heap 中找到一块足够大的空间，把它标记为已用，然后返回一个指针，即这个空间的地址，
这个过程就叫在 heap 上进行分配



## Stack VS Heap

* 因为指针是已知的固定的，所以可以把指针放在 stack 上
1. 但如果想要实际数据，就必须使用指针来定位它

* 把数据压到 stack 上要比 heap 上分配速度快的多
1. 因为系统不需要寻找用来存储新数据的空间，这个位置永远在栈顶

* 在 heap 上分配空间需要更多的操作
1. 首先系统需要找到一个足够大的空间来存储数据，然后做好记录方便下次分配

* 访问 heap 的数据要比访问 stack 上的数据慢的多，因为需要指针才能找到 heap 中的数据
1. 属于间接访问，多了指针跳转操作
2. 现代操作系统的处理器，由于缓存的缘故，如果指令在内存中跳转次数越少，则速度越快

* 如果数据存放的距离比较近，那么处理器处理的速度就会快一些（比如 stack）
* 如果数据存放的距离比较远，那么处理器处理的速度就会慢一些（比如 heap）
1. 在 heap 上分配大量空间也是需要时间的

## 函数调用
* 当调用函数时，被传入到函数（也包括指向 heap 的指针）。函数本地变量被压入到 stack，当函数结束这些变量会从 stack 弹出。


## 所有权能解决的问题
* 跟踪代码那些部分正在使用 heap 的哪些数据
* 最小化 heap 上的重复数据量
* 清理 heap 上未使用的数据，以避免空间不足
* 一旦懂得了所有权就不需要去想 stack 和 heap 了
* 管理 heap 数据才是所有权存在的原因，这有助于解释它为什么这么做

## 所有权的规则
1. 每个值都有一个变量，这个变量是该值的所有者
2. 每个值同时只能有一个所有者
3. 当所有者超出作用域（scope）时，这个值将被删除

## 变量的作用域（scope）
* scope 就是程序中一个项目的有效范围

```rust
{
// 这行 s 不可用 
let s = hello; // s 开始可以用了
    // 可对 s 进行相关操作
} // s 的作用域结束，s 不再可用
```

### String 类型与作用域
* String 存在 heap 上
* 字符串字面量是不可变的

#### 创建 String 
* 使用 from 从字面量创建
1. :: 表示 from 是 String 类型下的一个函数

```rust
    let mut s = String::from("hello");
    s.push_str(", World!");
    println!("{}", s);
```

* 字符串字面量不能改而 String 可以改是因为它们处理内存方式不同

### 内存与分配
* 字符串字面量在编译时就知道它的内容了，其内容直接被硬编码到最终的可执行文件中
1. 速度快，高效
2. 不可变

* String 类型，为了支持可变性，需要在 heap 上分配内存来保存编译时未知的文本内容
* Rust 中对于某个值，当拥有它的变量走出了作用域，内存会立即交还给系统，即内存立即释放 


> 当变量离开作用域，Rust 会调用 drop 函数
{: .prompt-info }

## 变量与数据交互方式：移动（Move）
* 多个变量可以与同一个数据使用一种独特的方式来交互
* Case 1

```rust
let x = 5;
let y = x;
println!("{} {}", x, y); // 此时没有 Move，x 依然可访问
整数是固定的已知值简单值，这里两个 5 被压入到 stack 中
```

* Case 2，String 版本

![image](/assets/images/rust/move_str.png)

Rust 没有使用这种方式
![image](/assets/images/rust/move_str1.png)

Rust 使用的方式
![image](/assets/images/rust/move_str2.png)

```rust
let mut s1 = String::from("hello");
let s2 = s1;
// 因为 s1 已经把所有权给了 s2，这里不能在访问 s1
```

### 浅拷贝（shallow copy）和深拷贝（deep copy）

![image](/assets/images/rust/move_str3.png)

> 你会认为复制指针、长度、容量视为浅拷贝，但由于 Rust 让 s1 失效了，所以我们用一个新的术语叫 Move，由于只有 s2 是有效的，所以只有在 s2 离开作用域时才会释放内存，这样就避免了二次释放的问题，Rust 不会自动创建数据的深拷贝，就运行时性能而言，任何自动赋值都是廉价的
{: .prompt-info }


> 可以认为浅拷贝 heap 上的数据会进行 Move
{: .prompt-info }

### 克隆 Clone
* 如果想对 heap 上的 String 数据进行深度拷贝，可以使用 clone 这个方法

```rust
let mut s1 = String::from("hello");
let s2 = s1.clone();
println!("s1 is {}, s2 is {}", s1, s2); // 深拷贝，可以访问 s1
```
![image](/assets/images/rust/clone.png)

### Stack 上的数据：复制

```rust
let x = 5;
let y = x;
println!("{} {}", x, y); // 此时没有 Move，x 依然可访问
```

> 标量类型深拷贝和浅拷贝没有区别，它们不会 Move
{: .prompt-info }

* Copy trait，可以用于像整数这样完全存放在 stack 上面的类型
* 如果一个类型实现了 Copy trait，那么旧的变量在赋值后仍然可用
* 如果一个类型或该类型的一部分实现了 Drop trait，那么 Rust 不允许它再去实现 Copy trait 了

### 哪些类型实现了 Copy trait
* 任何简单的标量的组合类型都可以实现 Copy trait 的
* 任何需要分配内存或某种资源的都不可实现 Copy trait
* 拥有 Copy trait 的类型
1. 所有的整数类型，例如 u32
2. bool
3. char
4. 所有的浮点类型，例如 f64
5. Tuple（元组），如果其所有字段都是 Copy 的，那么这个 Tuple 是拥有 Copy trait 的，如 (i32,i32) 就是，(i32, String) 则不是

## 所有权与函数
* 在语义上，将值传递给函数和把值赋值给变量是类似的
1. 将值传递给函数将发生移动或复制

```rust
fn main() {
    let s = String::from("Hello World");

    // 这里 s 已经 move 到函数中了
    take_ownership(s);

    //println!("s is {}", s); // 由于 take_ownership 调用， s 已经 Move 了，所以 s 不再可用

    let x = 5;

    makes_copy(x);

    println!("x is {}", x); // x 依然可用，因为 makes_copy 调用只是把 x 是标量类型，是把副本传给函数
}

fn take_ownership(string: String) {
    println!("string is {}", string); // 传进来的 s 在这里可用，在函数结束 drop
}

fn makes_copy(number: i32) {
    println!("num is {}", number);
}
```

### 返回值与作用域
* 函数在返回值的过程中同样也会发生所有权的转移

```rust
fn main() {
    // 将 str 的 hello 移动给了 s1
    let s1 = gives_ownership();

    let s2 = String::from("hello");

    // 这里其实是 s2 Move 给了 s3
    let s3 = takes_and_gives_back(s2);

    // 作用域结束 s1、s3 drop，s2 因为已经 Move 了，所以不会有什么变化
}

fn gives_ownership() -> String {
    let str = String::from("hello");
    str
}

fn takes_and_gives_back(a_string: String) -> String {
    a_string
}
```
* 一个变量的所有权总是遵循同样的模式
1. 把一个值赋值给其他变量时就会移动
2. 当一个包含 heap 数据的变量离开作用域时，它的值就会被 drop 清理，除非数据的所有权移动到了另一个变量上

#### 如何让函数使用某个值，而不获得其所有权呢？
* 方式一，可以函数再把变量值 return 出来，但这种方式比较麻烦
* Rust 有个特性叫引用，即 Reference
