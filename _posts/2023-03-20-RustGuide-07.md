---
layout: post
title: RustGuide-07
date: 2023-03-20 16:45:30.000000000 +09:00
categories: [Rust]
tags: [Rust]
---

# 10 泛型、Trait、生命周期

## 提取函数消除重复代码

```rust
// 使用 &
fn largest(list: &[i32]) -> i32 {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

// 使用 *
fn largest2(list: &[i32]) -> i32 {
    let mut largest = list[0];
    for item in list {
        if *item > largest {
            largest = *item;
        }
    }
    largest
}
```

## 泛型
* 可以提高代码复用能力
* 泛型是具体类型或其他属性的抽象代替
1. 编写代码时，泛型是一个占位符
2. 编译器在编译时将 “占位符” 替换为具体类型
* 例如 `fn largest<T>(list: &[T]) -> T { ... }`
1. T 叫类型参数。通常很短一般是一个字母


### 函数定义中使用泛型

```rust
fn largest<T>(list: &[T]) -> T {
    let mut largest = list[0];
    for &item in list {
        if item > largest { // 这里有问题，之后讲
            largest = item;
        }
    }
    largest
}
```

### struct 中定义泛型
* 可以使用多个泛型类型参数

```rust
struct Point<T> {
    x: T,
    y: T,
}

fn test_struct() {
    let p = Point { x: 1, y: 2};
    let p2 = Point { x: 1.0, y: 2.0};

}
```

### enum 中定义泛型
* 让枚举的变体持有泛型的数据类型

```rust
enum Option<T> {
    Some(T),
    None,
}

enum Result<T,E> {
    Ok(T),
    Err(E),
}
```

### 方法中定义泛型

```rust
struct Point<T> {
    x: T,
    y: T,
}

// 泛型方法
impl<T> Point<T>  {
    fn getX(&self) -> &T {
        &self.x
    }
}

// 针对特定类型的方法
// 只有 Point<i32> 有 getX1 方法，其他 Point<T> 没有 getX1 方法
impl Point<i32>  {
    fn getX1(&self) -> &i32 {
        &self.x
    }
}
```


> 把 T 放在 impl 关键字后，表示在类型 T 上实现方法，例如 `impl<T> Point<T>`
{: .prompt-info }


> struct 里的泛型参数可以和方法里的泛型参数不同
{: .prompt-info }

```rust
struct Origin<T, U> {
    x: T,
    y: U,
}

impl<T, U> Origin<T, U> {
    fn mixup<V, W>(self, other: Origin<V, W>) -> Origin<T, W> {
        Origin { x: self.x, y: other.y }
    }
}

fn test_origin() {
    let p1 = Origin{ x: 1, y: 4};
    let p2 = Origin{ x: "hello", y: "world"};
    let p3 = p1.mixup(p2);
    println!("p3.x={}, p3.y={}", p3.x, p3.y);
}
```

### 泛型代码的性能
* 使用泛型的代码和使用具体类型的代码运行速度是一样的
* 单态化（monomorphization）：即在编译时将泛型替换为具体类型的过程

## Trait
* 告诉 Rust 编译器
1. 某种类型具有哪些并且可以与其他类型共享的功能
* Trait 可以以抽象的方式定义共享的行为
* Trait bounds（约束）：泛型类型参数指定为实现了特定行为的类型，即泛型类型参数实现了某些 Trait
* Trait 与其他语言的接口（interface）有些类似，但又有区别

### 定义一个 Trait
* 把方法签名放在一起，来定义实现某种目的所必需的一组行为
* 只有方法签名，没有方法的具体实现
* Trait 里可以写多个方法，每个方法签名占一行，以 `;` 结尾
* 实现该 Trait 的类型必须提供具体方法的实现

```rust
// 定义一个 trait
pub trait Summary {
    fn summarize(&self) -> String;
}
```

### 在类型上实现 trait
* 与为类型实现方法类似

```rust
// lib.rs
// 定义一个 trait
pub trait Summary {
    fn summarize(&self) -> String;
}

pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {

    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{} -> {}", self.username, self.content)
    }
}


// main.rs
// traits 即 Cargo.toml 里的 package name
use traits::NewsArticle;
use traits::Summary;
use traits::Tweet;

fn main() {
    println!("Hello, world!");
    let tweet = Tweet {
        username: String::from("hourse_ebook"),
        content: String::from("of course, as you probably already know, people"),
        reply: false,
        retweet: false,
    };
    println!("1 new tweet: {}", tweet.summarize());

}
```

### 实现 trait 的约束
* 想要在某个类型上实现某些 trait 它有一些前提条件
1. 这个类型或这个 trait 实在本地 crate 里定义的
* 无法为外部类型来实现外部 trait，例如在本地项目为标准库里 Vector 实现标准库里的 Display trait 这是不行的
1. 这个限制即程序属性的一部分（也就是一致性）
2. 更具体的说：它叫孤儿原则，之所以这么命名是因为它的父类型并没有定义在当前库里。
3. 此规则可以保证其他人的代码不能破坏你写的代码，vice verse
4. 如果没有这个规则，那么两个 crate 就可以为同一类型实现同一 trait，Rust 就不知道该使用哪个实现了

> 这里在 OC 里是相当于会覆盖，OC 本质是放到数组前边了
{: .prompt-info }


### 默认实现
* 通常为 trait 提供默认行为是有用的


```rust
// 定义一个 trait
pub trait Summary {
    //fn summarize(&self) -> String;
    // 默认实现
    fn summarize(&self) -> String {
        String::from("Read more...")
    }
}
```


* Note：默认实现的方法也可以调用 trait 中的其他方法，即使这个方法没有默认实现

```rust
// 定义一个 trait
pub trait Summary {
    fn summarize_author(&self) -> String;

    //fn summarize(&self) -> String;
    // 默认实现
    fn summarize(&self) -> String {
        format!("Read more by {}", self.summarize_author())
    }
}

pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {

    fn summarize_author(&self) -> String {
        format!("@{}", self.author)
    }

    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {

    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }

    // 注释掉，就用默认实现了
    // fn summarize(&self) -> String {
    //     format!("{} -> {}", self.username, self.content)
    // }
}
```

> 无法从方法重新实现里调用该方法的默认实现
{: .prompt-info }


### Trait 作为参数
* 1 impl trait 语法，适用于简单 case


```rust
pub fn notify(item: impl Summary) {
    println!("Breaking news {}", item.summarize());
}

// call
traits::notify(tweet);
```

* 2 trait bound 语法，适用于复杂 case
1. impl trait 其实就是 trait bound 语法的语法糖 


```rust
// trait bound 写法
pub fn notify2<T: Summary>(item: T) {
    println!("Breaking news {}", item.summarize());
}
```

### 使用 + 号指定多个 trait bound

```rust
// impl trait 写法, 使用 + 号指定多个 trait bound
pub fn notify(item: impl Summary + Display) {
    println!("Breaking news {}", item.summarize());
}

// trait bound 写法，使用 + 号指定多个 trait bound
pub fn notify2<T: Summary + Display>(item: T) {
    println!("Breaking news {}", item.summarize());
}
```

### trait bound 使用 where 语句来指定 trait 的约束
* 在方法签名的后边指定 where 语句


```rust
pub fn notify_no_where<T: Summary + Display, U: Clone + Debug>(a: T, b: U) -> String {
    format!("where {}", a.summarize())
}

pub fn notify_where<T, U>(a: T, b: U) -> String
    where T: Summary + Display, 
          U: Clone + Debug  {
    format!("where {}", a.summarize())
}
```

### 使用 trait 作为返回类型

