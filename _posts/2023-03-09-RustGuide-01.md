---
layout: post
title: 2023-03-10-RustGuide-01
date: 2023-03-09 16:45:30.000000000 +09:00
categories: [Rust]
tags: [Rust]
---

# 相关命令

* 查看版本，例如 rustc 1.68.0 (2c8cc3432 2023-03-06)
1. 2c8cc3432 commit hash
2. 1.68.0 版本

```
$ rustc --version
```

* 更新
```
$ rustup update
```

* 卸载
```
$ rustup self uninstall
```

* 本地文档
```
$ rustup doc
```

# Hello World

* rust 文件后缀名称 .rs
* 命名规范：单词用下划线分隔，例如 hello_word.rs
```rust
// main 函数式 Rust 程序入口
// Rust 缩进是 4 个空格，而不是 Tab
fn main() {
    // println! 是一个宏，函数没有 !
    println!("hello world!");
}
```

* 运行 Rust 程序前必须先编译，使用 rustc 命令编译
```
$ rustc main.rs
```
* 编译成功后生成二进制文件，rustc 只适合简单程序

# Cargo
* Cargo 是 Rust 的构建系统和包管理工具，用于构建代码，下载依赖库
* 查看 Cargo 版本
```
$ cargo --version
```
* 使用 Cargo 创建新项目，cargo new `项目名`
```
$ cargo new hello_world
```
* 生成新项目目录结构
1. Cargo.toml 配置文件
2. src 文件夹，用于放源代码
3. 顶层目录可以放 README、许可信息、配置文件、其他跟源代码无关的文件
4. 如果没有使用 Cargo 创建项目，也可手动变成 Cargo 形式，即把源代码放到 src 目录下，并添加 Cargo.toml 配置文件

* Toml（Tome‘s Obvious，Minimal Language 格式）文件



```
[package] // 表示区域标题，下方内容是来配置 package 的
name = "hello_world"  // 项目名
version = "0.1.0"     // 项目版本
edition = "2021"      // 使用的 Rust 版本

[dependencies] // 项目的依赖项
```

> 在 Rust 里，代码的包称为 crate
{: .prompt-info }


## Build Cargo 项目
```
$ cargo build
```
生成文件路径：/target/debug/{项目名}

> 第一次 cargo build 会在顶层目录生成 cargo.lock，cargo.lock 负责追踪项目依赖的精确版本（类似 Podfile.lock）
{: .prompt-info }

## Run Cargo 项目
编译 + 运行项目
```
$ cargo run
```
* 如果之前编译成功过，并且源代码没有改动，那就直接运行程序

## Check Cargo 项目
* 用于检查代码，确保编译能通过，但不产生任何可执行文件
```
$ cargo check
```

> cargo check 比 cargo build 快的多，所以开发时可以用 cargo check，到生成二进制文件时候再用 cargo build
{: .prompt-info }

## 为发布构建
* 编译时会进行优化，代码会运行更快，但是编译时间更长
* 可执行文件生成在 target/release 下
```
$ cargo build --release
```


# 例子

* rust 默认变量都是 immutable 不可变的
* 在变量前加 mut 表示变量是可变的 mutable

```rust
let foo = 1;
// foo = 2; // error can't assign twice to immutable variable 

let mut _bar = foo; // rust 默认变量都是 immutable 不可变的
_bar = 3;  // 在变量前加 mut 表示变量是可变的 mutable
```


## 猜数游戏


```
// 引用标准库 std 的 io 库 可以使用 io
/*
rust 默认把 prelude（预导入） 导入到程序的每个作用域中,如果你使用的类型 prelude 里没有
这时你需要自行导入, 就是使用 use 导入库
 */
use std::io;

// fn 即声明一个函数
fn main() {
    println!("猜数!");
    println!("猜一个数");

    // rust 中 String 使用 utf-8 编码
    // :: 两个冒号表示后边的是一个静态方法
    // 这里 new 函数创建一个空白的字符串
    let mut guess = String::new();

    // 1 读取一行东西，并放到 guess 字符串引用里
    // 2 expect 为抛出异常时候输出的错误信息
    // 3 & 表示参数是一个引用
    // 4 read_line 参数是需要一个引用
    // 5 引用默认也是不可变的比如 &guess, 所以 &mut 就是可变引用
    // 
    /* 
        6   
       read_line 返回 Result 类型，Result 就是枚举类型
       io::Result 有两个值 OK 和 Err
       如果是 OK 表示操作成功，并且里边有结果
       如果是 Err 表示操作失败，Err 里有失败 reason
       expect 是 Result 的方法，如果返回 Err 则 expect 会中断程序，将传入字符串显示
       如果返回 OK，expect 就将用户输入的值返回
     */
    io::stdin().read_line(&mut guess).expect("无法读取行");

    // {} 是一个占位，输出时候会被替换成 guess 变量的值
    // 一个 {} 对应一个变量的值
    println!("你猜测的数是：{}", guess);

}

```

## format

* 安装 format
```
$ rustup component add rustfmt
```

* 对代码进行格式化
```
$ cargo fmt
```


## 随机数
[随机数](https://crates.io/crates/rand)

一个 crate 就是一个库


### cargo update
* 会忽略 cargo.lock 中的版本，来找到 cargo.toml 里符合的版本

```
$ cargo update
```

### 添加依赖库 rand
* 在 cargo.toml 中添加 rand 库

```
[dependencies]
rand = "0.8.5"  // 指定版本号

```

之后 vscode 会下载依赖库，下载好后可执行 `cargo build`


* 生成随机数

```rust

// Rng 是一个 trait，可以看成是一个协议
use rand::Rng; // trait

    /* 
        ThreadRng 就是一个随机数生成器，它是位于本地线程空间
        并通过系统获得随机数的种子
        gen_range 在 [1, 101) 之间获取随机数
    */
    let rand_number = rand::thread_rng().gen_range(1..101);
    println!("神秘数字是 {}", rand_number);
```
