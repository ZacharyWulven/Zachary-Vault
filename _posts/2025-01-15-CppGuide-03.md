---
layout: post
title: CppGuide-03
date: 2025-01-15 16:45:30.000000000 +09:00
categories: [C++]
tags: [C++]
---


# C++ 静态数组 `std::array`
* C++ 标准库模版库提供，不能改变其大小
* `std::array` 与 C 语言风格是一样的，都存储在栈上。`vector` 存储在堆上
* `std::array`优点：
  1. 它帮助我们维护了 `size`，`size` 是构造时候传入的数量，不会有 `size` 计算属性
  2. 它有边界检查，指定 Debug 或 Release 模式生效与否


```c++
template <typename T, int N>
void PrintArray(std::array<T, N> array)
{
    for (auto it = array.begin(); it != array.end(); it++) {
        std::cout << *it << std::endl;
    }
}

int main(int argc, const char * argv[]) {        
    std::cout << "静态数组 std::array" << std::endl;
    /*
     std::array 与 C 语言风格是一样的
     */
    std::array<int, 5> data;
    data[0] = 2;
    data[3] = 1;
    data[4] = 4;

    PrintArray<int, 5>(data);
    
    // C 语言风格
    int dataOld[5];
    dataOld[0] = 0;
    
    return 0;
}
```

# (C/C++ 语言)函数指针

## 原始函数指针（raw function pointer）

* `auto` 关键字对于函数指针很有用

```c++
#include <iostream>

void HelloWorld(int a)
{
    std::cout << "Hello, World! Value: " << a << std::endl;
}

int main(int argc, const char * argv[]) {
    
    // function type is void (*)()    (FunctionPointer`HelloWorld() at main.cpp:11)
    auto function = HelloWorld; // 获取 HelloWorld 地址, 这里有个隐式 &
    function(0);
    function(1);

    // 实际类型: void (*)()
    void(*func)(int) = HelloWorld;
    func(2);
    
    // use typedef
    typedef void(*HelloWorldFunction)(int);

    HelloWorldFunction h = HelloWorld;
    h(3);
    
    
    return 0;
}
```

## 函数指针作为函数参数 和 `lambda` 匿名函数


```c++
#include <iostream>
#include <vector>

void PrintValue(int a)
{
    std::cout << "Print Value: " << a << std::endl;
}

void ForEach(const std::vector<int>& values, void(*func)(int))
{
    for (int value: values) {
        func(value);
    }
}

int main(int argc, const char * argv[]) {
    
    std::vector<int> values = {1, 5, 4, 2, 3};
    ForEach(values, PrintValue);
    
    // Lambda 函数
    // [] 叫捕获方式
    ForEach(values, [](int value){
        std::cout << "Lambda Value: " << value << std::endl;
    });

    return 0;
}
```


# `lambda` 表达式（匿名函数）
1. 就是一个普通函数，它是我们代码在运行中生成的，用完就废弃，不算一个真正的函数，是匿名函数
2. 不需要实际创建一个函数，就像一个快速一次性函数，展示下需要运行的代码，我们更想将它视为一个变量，
而不是像一个正式的函数那样，在实际编译代码中作为一个符号存在

## 工作原理
* 只要你有一个函数指针，你都可以在 C++ 中使用 `lambda`

## 如何使用
* 写 `lambda` 表达式，要先用`[]` 即捕获方式，也就是如何传递变量

[cppreference 参考网站](https://en.cppreference.com/w/cpp/language/lambda)

```c++
#include <iostream>
#include <vector>
#include <functional>
#include <algorithm>

//void ForEach(const std::vector<int>& values, void(*func)(int))
void ForEach(const std::vector<int>& values, const std::function<void(int)>& func)
{
    for (int value: values) {
        func(value);
    }
}

int main(int argc, const char * argv[]) {
    
    std::vector<int> values = {1, 5, 4, 2, 3};
    //
    /*
     *  [] 叫捕获方式
        [=] 表示传递所有变量，通过值传递
        [&] 表示传递所有变量，通过引用传递
        [a] 表示传递变量 a，值传递
        [&a] 表示传递变量 a，引用传递
     
        Note：这个例子传入 auto lambda，实际上我们不管是通过值还是引用来捕获变量
        都会有错误，因为我们正在使用原始指针
        需要改为使用 std::function
     */
    int a = 5;
    // 值传入所有变量，即拷贝变量，然后传入
    auto lambda = [=](int value) mutable {
        // 声明 mutable 可以在这里修改 a 的值, 但不影响外部的 a, 
        // 因为是值传递
        a = 6; 
        
        std::cout << "Lambda a: " << a << std::endl;
        std::cout << "Lambda Value: " << value << std::endl;
    };
    
    ForEach(values, lambda);
    std::cout << "final a Value: " << a << std::endl; // 5
    
    // ------------------------------------
    // lambda 另一个 Case
    // 找到比 3 大的整数，然后返回它的迭代器，即满足条件的第一个元素
    auto it = std::find_if(values.begin(), values.end(), [](int value) {
        return value > 3;
    });
    std::cout << *it << std::endl; // 5

    return 0;
}
```
