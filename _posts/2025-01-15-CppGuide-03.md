---
layout: post
title: CppGuide-03
date: 2025-01-15 16:45:30.000000000 +09:00
categories: [C++]
tags: [C++]
---


# C++ 静态数组 `std::array`
* C++ 标准库模版库提供，不能改变其大小
* `std::array` 与 C 语言风格是一样的，都存储在栈上。`vector` 存储在堆上
* `std::array`优点：
  1. 它帮助我们维护了 `size`，`size` 是构造时候传入的数量，不会有 `size` 计算属性
  2. 它有边界检查，指定 Debug 或 Release 模式生效与否


```c++
template <typename T, int N>
void PrintArray(std::array<T, N> array)
{
    for (auto it = array.begin(); it != array.end(); it++) {
        std::cout << *it << std::endl;
    }
}

int main(int argc, const char * argv[]) {        
    std::cout << "静态数组 std::array" << std::endl;
    /*
     std::array 与 C 语言风格是一样的
     */
    std::array<int, 5> data;
    data[0] = 2;
    data[3] = 1;
    data[4] = 4;

    PrintArray<int, 5>(data);
    
    // C 语言风格
    int dataOld[5];
    dataOld[0] = 0;
    
    return 0;
}
```

# (C/C++ 语言)函数指针

## 原始函数指针（raw function pointer）

* `auto` 关键字对于函数指针很有用

```c++
#include <iostream>

void HelloWorld(int a)
{
    std::cout << "Hello, World! Value: " << a << std::endl;
}

int main(int argc, const char * argv[]) {
    
    // function type is void (*)()    (FunctionPointer`HelloWorld() at main.cpp:11)
    auto function = HelloWorld; // 获取 HelloWorld 地址, 这里有个隐式 &
    function(0);
    function(1);

    // 实际类型: void (*)()
    void(*func)(int) = HelloWorld;
    func(2);
    
    // use typedef
    typedef void(*HelloWorldFunction)(int);

    HelloWorldFunction h = HelloWorld;
    h(3);
    
    
    return 0;
}
```

## 函数指针作为函数参数 和 `lambda` 匿名函数

```c++
#include <iostream>
#include <vector>

void PrintValue(int a)
{
    std::cout << "Print Value: " << a << std::endl;
}

void ForEach(const std::vector<int>& values, void(*func)(int))
{
    for (int value: values) {
        func(value);
    }
}

int main(int argc, const char * argv[]) {
    
    std::vector<int> values = {1, 5, 4, 2, 3};
    ForEach(values, PrintValue);
    
    // Lambda 函数
    // [] 叫捕获方式
    ForEach(values, [](int value){
        std::cout << "Lambda Value: " << value << std::endl;
    });

    return 0;
}
```


# `lambda` 表达式（匿名函数）
1. 就是一个普通函数，它是我们代码在运行中生成的，用完就废弃，不算一个真正的函数，是匿名函数
2. 不需要实际创建一个函数，就像一个快速一次性函数，展示下需要运行的代码，我们更想将它视为一个变量，
而不是像一个正式的函数那样，在实际编译代码中作为一个符号存在

## 工作原理
* 只要你有一个函数指针，你都可以在 C++ 中使用 `lambda`

## 如何使用
* 写 `lambda` 表达式，要先用`[]` 即捕获方式，也就是如何传递变量

[cppreference 参考网站](https://en.cppreference.com/w/cpp/language/lambda)

```c++
#include <iostream>
#include <vector>
#include <functional>
#include <algorithm>

//void ForEach(const std::vector<int>& values, void(*func)(int))
void ForEach(const std::vector<int>& values, const std::function<void(int)>& func)
{
    for (int value: values) {
        func(value);
    }
}

int main(int argc, const char * argv[]) {
    
    std::vector<int> values = {1, 5, 4, 2, 3};
    //
    /*
     *  [] 叫捕获方式
        [=] 表示传递所有变量，通过值传递
        [&] 表示传递所有变量，通过引用传递
        [a] 表示传递变量 a，值传递
        [&a] 表示传递变量 a，引用传递
     
        Note：这个例子传入 auto lambda，实际上我们不管是通过值还是引用来捕获变量
        都会有错误，因为我们正在使用原始指针
        需要改为使用 std::function
     */
    int a = 5;
    // 值传入所有变量，即拷贝变量，然后传入
    auto lambda = [=](int value) mutable {
        // 声明 mutable 可以在这里修改 a 的值, 但不影响外部的 a, 
        // 因为是值传递
        a = 6; 
        
        std::cout << "Lambda a: " << a << std::endl;
        std::cout << "Lambda Value: " << value << std::endl;
    };
    
    ForEach(values, lambda);
    std::cout << "final a Value: " << a << std::endl; // 5
    
    // ------------------------------------
    // lambda 另一个 Case
    // 找到比 3 大的整数，然后返回它的迭代器，即满足条件的第一个元素
    auto it = std::find_if(values.begin(), values.end(), [](int value) {
        return value > 3;
    });
    std::cout << *it << std::endl; // 5

    return 0;
}
```

# 不要使用 `using namespace`
* 只 `using` 自己的库，绝对不要 `using std`, 我们必须要知道我们到底用的是什么 

```c++
#include <iostream>
#include <string>

namespace apple {
void print(const std::string& text)
{
    std::cout << text << std::endl;
}
}


namespace orange {
void print(const char* text)
{
    std::string temp = text;
    std::reverse(temp.begin(), temp.end());
    std::cout << temp << std::endl;
}
}

using namespace apple;
using namespace orange;

int main(int argc, const char * argv[]) {
    
    /*
       本来是要调用 apple 的 print
       如果没有 orange，apple 的 print 其实是做了隐式转换
       因为 const char 数组可以转换为 string 对象
       然而，引入 orange 后 orange 的 print 函数更加匹配
       这种情况没有编译错误，这是运行时错误
     */
    print("Hello");

//    apple::print("Hello");
    
    return 0;
}
```

> 绝对不要在头文件中使用 `using namespace`。如果要用 `using namespace` 只在一个很小的作用域内使用
{: .prompt-info }


# C++ 命名空间
* 命名空间用于避免编译代码函数签名等冲突

[namespace 参考](https://en.cppreference.com/w/cpp/language/namespace)


```c++
#include <iostream>
#include <string>

namespace apple { namespace functions {

void print(const char* text)
{
    std::cout << text << std::endl;
}

void print_again(const char* text)
{
    std::cout << text << std::endl;
}

}
}

namespace orange {
void print(const char* text)
{
    std::string temp = text;
    std::reverse(temp.begin(), temp.end());
    std::cout << temp << std::endl;
}
}

// C++ 新特性，但有些编译器不支持
namespace func::apple {

}

int main(int argc, const char * argv[]) {
    // case 1
    using apple::functions::print;
    print("Hello");
    
    // case 2 这个 case namespace 定义只在 main 生效
    namespace a = apple;
    a::functions::print_again("Again");
    
    // case 3
    using namespace apple::functions;
    print_again("Again using apple::functions");
    
    // case 4
    using namespace apple;
    using namespace functions;
    print_again("Again using apple::functions");

    // case 5
    namespace b = apple::functions;
    b::print_again("Again b");
    
    return 0;
}
```


> 类也是一种命名空间。建议 `using namespace` 只在一个很小的作用域内使用，比如一个 `if` 语句内
{: .prompt-info }


# C++ 多线程

```c++
#include <iostream>
#include <thread>

static bool s_Finished = false;

void DoWOrk()
{
    using namespace std::literals::chrono_literals;
    
    std::cout << "Started thread id=" << std::this_thread::get_id() << std::endl;
    
    while (!s_Finished) {
        std::cout << "Working... \n";
        std::this_thread::sleep_for(1s); // 等待 1 秒
    }
    
}

int main(int argc, const char * argv[]) {
    
    std::thread worker(DoWOrk);
    
    std::cin.get();
    s_Finished = true;
    
    /*
        线程加入(或叫 wait)，这个东西是并行运行的
        写 join 目的是在主线程上等待工作线程完成所有执行后，
        再继续执行主线程
    
        这里会等待 DoWOrk 里任务都执行完成
     */
    worker.join();
    std::cout << "Finished." << std::endl;
    std::cout << "Started thread id=" << std::this_thread::get_id() << std::endl;

    std::cin.get();
    
    return 0;
}
```

# C++ 计时
* 使用 `std::chrono`

```c++
#include <iostream>
#include <chrono>
#include <thread>

struct Timer
{
    std::chrono::time_point<std::chrono::steady_clock> start, end;
    std::chrono::duration<float> duration;
    
    Timer()
    {
        start = std::chrono::high_resolution_clock::now();
    }
    
    ~Timer()
    {
        end = std::chrono::high_resolution_clock::now();
        duration = end - start;
        float ms = duration.count() * 1000.0f;
        std::cout << "Timer took " << ms << "ms" << std::endl;
    }
};

void Function()
{
    Timer timer;
    for (int i = 0; i < 100; i++) {
        std::cout << "Hello\n";
    }
}

int main(int argc, const char * argv[]) {
    
    using namespace std::literals::chrono_literals;
    auto start = std::chrono::high_resolution_clock::now();
    std::this_thread::sleep_for(1s);
    auto end = std::chrono::high_resolution_clock::now();
    
    std::chrono::duration<float> duration = end - start;
    std::cout << "duration is " << duration.count() << "s " << std::endl;

    
    Function();

    return 0; 
}
```

# C++ 多维数组

```c++
#include <iostream>

int main(int argc, const char * argv[]) {
    /*
        重要的是：类型只是一种语法，设置类型是用来处理数据的
        这里分配了 200 字节
        现在存储了 200 字节的指针，50个指针，
        然后我们可以遍历并设置每个指针指向一个数组
     */
    int** a2d = new int*[50]; // 只是分配内存
//    a2d[0] = nullptr;
    
    // 创建 50 个数组，并存放在 a2d 中
    for (int i = 0; i < 50; i++) {
        a2d[i] = new int[50];
    }
    
    
    // 三维数组
    int*** a3d = new int**[50];
    for (int i = 0; i < 50; i++) {
        a3d[i] = new int*[50];
        for (int j = 0; j < 50; j++) {
//            a3d[i][j] = new int[50];
            // or
            int ** ptr = a3d[i];
            ptr[j] = new int[50];
        }
    }

    
    a3d[0][0][0] = 1;
    
    a2d[0][0] = 0;
    a2d[0][1] = 1;
    a2d[0][2] = 1;
    
    /*
        我们使用 new 创建，所以需要 delete 它们
        我们必须遍历它们，然后 delete 所有数组
        因为不能 delete 一次就搞定
     
        如果 delete[] a2d，那么会造成内存泄漏，
        因为 a2d 里边的数组我们无法访问了
     */
//    delete[] a2d;
    
    // 正确清理内存做法
    for (int i = 0; i < 50; i++) {
        delete[] a2d[i];
    }
    delete[] a2d;
    
    // ## 优化相关
    /*
        像上边那样使用多维数组会造成内存碎片
        我们没有一个连续的内存缓冲区，在一行中保存25个整数
        实际上我们已经创建了5个单独的缓冲区，每个缓冲区有5个整数
        我们每次遍历5个之后，会跳到数组下一行，或者叫数组其他维度，
        也就是跳到下一个整数数组时，我们必须跳转到内存中的另一个
        位置来读写数据，这会导致 cache miss（缓存不命中）
        这意味着我们在浪费时间从 ram 中获取数据，如果
        它们恰好是紧密地一起分配的，那么这可能不会造成 cache miss
        但是不能指望一定会分配到一起，通常不会分配在一起，因为这个
        实际上用这种方式遍历这 25 个整数要比我们只分配一个一维数组
        要慢的多，因为一维数组内存都在一起
        最重要一点是在你编译和优化时，在处理内存问题时，你可以优化最重要
        的事情之一就是优化你的内存访问，所以你能将要访问内存存储在一起
        的数据时，会有更多的 cache hits，更少的 cache miss，
        你的程序会更快
     */

    int** b2d = new int*[5]; // 只是分配内存
    
    for (int i = 0; i < 5; i++) {
        b2d[i] = new int[5];
    }
    
    // 你可以用一维数组代替上边的二维数组
    int* list = new int[5 * 5];
    for (int i = 0; i < 5; i++) {
        for (int j = 0; j < 5; j++) {
            list[i * 5 + j] = 2;
        }
    }
    
    for (int i = 0; i < 25; i++) {
        std::cout << list[i] << std::endl;
    }
    return 0;
}
```

> 尽量避免使用多维数组
{: .prompt-info }


# C++ 排序

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>

int main(int argc, const char * argv[]) {
    
    std::vector<int> values = {3, 5, 1, 4, 2};
    
    // 对于整数，默认按升序排序
    std::sort(values.begin(), values.end());
    for (int value: values) {
        std::cout << value << std::endl;
    }
    
    std::cout << "----------------------------" << std::endl;

    // 指定排序方式 std::greater<int>，从大到小
    std::sort(values.begin(), values.end(), std::greater<int>());
    for (int value: values) {
        std::cout << value << std::endl;
    }
    std::cout << "----------------------------" << std::endl;

    // 自定义排序方式
    std::sort(values.begin(), values.end(), [](int a, int b)
    {
        if (a == 1) {
            return false;
        }
        if (b == 1) {
            return true;
        }
        return a < b;
    });
    for (int value: values) {
        std::cout << value << std::endl;
    }
    return 0;
}
```

# C++ 类型双关(用于在 C++ 中绕过类型系统)
* C++ 中虽然类型是由编译器强制执行的，但您可以直接访问内存
* 如果你不想处理某种类型的复制或转换，它会非常有用


```c++
#include <iostream>

struct Entity {
    int x, y;
    
    int* GetPositions()
    {
        return &x;
    }
};

int main(int argc, const char * argv[]) {
    
    int a = 50;
    
    /*
     这样非常糟糕
     我们取了一个4字节整数，然后定位成 double
     我们先把一个int型指针转换为一个double型指针
     然后解引用，实际上在我们int之后的继续4个字节，
     然后获取这部分内存，但这部分内存不是我们的内存
     即不是我们用来存放整数a的内存，这很糟糕，在某些
     情况下甚至会导致崩溃
     */
    double value = *(double*)&a;
    std::cout << value << std::endl;
    /*
     使用引用&，而不是拷贝成一个新变量
     这样你就能编辑这个int内存
     */
    double& value2 = *(double*)&a;
    value2 = 0.0; // 很危险，它实际上要写8个字节，而不是4个字节，但我们只要4字节空间
    std::cout << value2 << std::endl;

    //-------------------------------------
    
    // 如果 struct 是空的，那么它至少要有一个字节
    // 而 Entity 就是两个整数的容量
    Entity e = { 5, 8 };
    // 因此我们可以将 Entity 想象成一个 int 数组
    int* position = (int*)&e;
    std::cout << position[0] << ", " << position[1] << std::endl;

    int y = *(int*)((char*)&e + 4);
    std::cout << "y is " << y << std::endl;
    
    int* position2 = e.GetPositions();
    position2[1] = 10;
    std::cout << position2[0] << ", " << position2[1] << std::endl;

    return 0;
}
```

> 如果 `struct` 是空的，那么它至少要有一个字节
{: .prompt-info }


> 这些代码可能永远不会在实际应用程序中存在，因为它太疯狂了，这里只在展示一下可以这么玩而已
{: .prompt-info }


# C++ `Union(联合体，共用体)`

## `Union` 只能有一个成员，它一次只能占用一个成员内存
* 通常如果我们有一个结构体，声明了 `4 个浮点数`，我们可以有 `4 * 4 个字节`在这个结构体中，这就是它占用的内存。
但是 `Union` 的话这个例子就只有 `4 个字节`
* 你可以像使用结构体或类一样使用它们，你也可以给它添加静态函数或普通函数，方法等等，然而，你不能使用虚方法
* 通常大家用 `Union` 做事情跟类型双关紧密相关
  - 当你想给一个变量取两个不同名字时，是很有用的
* 通常 `Union` 是匿名使用的，但是匿名 `Union` 不能含有成员函数

```c++
#include <iostream>

struct Vector2 {
    float x, y;
};

struct Vector4 {
    
    union
    {
        // 这个 struct 是 union 的一个成员
        struct
        {
            float x, y, z, w;
        };
        struct
        {
            // a 和 上边 x y 内存一样的
            // b 和 上边 z w 内存相同
            Vector2 a, b;
        };
    };
    
//    float x, y, z, w;
//    Vector2& GetA()
//    {
//        // 一种方式，另一种方式是使用 union
//        return *(Vector2*)&x;
//    }
    
    
};

void PrintVector2(const Vector2& vector)
{
    std::cout << vector.x << ", " << vector.y << std::endl;

}

int main(int argc, const char * argv[]) {
        
    struct Union {
        union
        {
            float a;
            int b;
        };
    };

    Union u;
    u.a = 2.0f;
    std::cout << u.a << ", " << u.b << std::endl;

    //---------------------------------
    
    Vector4 vector = {1.0f, 2.0f, 3.0f, 4.0f};
    // 这里能直接访问 x 是因为 struct 是匿名的
    // 如果它是匿名的，它只是一种数据结构，并没有添加任何其他
    vector.x = 1.0f;
    std::cout << vector.x << ", " << vector.y << std::endl;

    // 现在我们有几种访问 Vector4 内数据的方法
    std::cout << "现在我们有几种访问 Vector4 内数据的方法" << std::endl;
    std::cout << "a 和 上边 x y 内存一样的" << std::endl;
    std::cout << "b 和 上边 z w 内存相同" << std::endl;

    PrintVector2(vector.a);
    PrintVector2(vector.b);
    std::cout << "-----------------------------------" << std::endl;
    vector.z = 500.0f;
    PrintVector2(vector.a);
    PrintVector2(vector.b);

    return 0;
}
```
