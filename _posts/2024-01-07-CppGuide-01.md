---
layout: post
title: CppGuide-01
date: 2024-01-07 16:45:30.000000000 +09:00
categories: [C++, 入门]
tags: [C++]
---


# HelloWorld

```c++
//******* Log.hpp
#ifndef Log_hpp
#define Log_hpp

#include <stdio.h>
#include <iostream>

void Log(const char* message);

#endif /* Log_hpp */



//******* Log.cpp
#include "Log.hpp"

//const char* 是一种可以保存文本字符串的数据类型
void Log(const char* message) {
  std::cout << message << std::endl;
}



//******* main.cpp
//  Hello
//
//  Created by Zacharyah on 2024/2/7.
//

// 预处理，在编译前执行
#include <iostream>

int main(int argc, const char * argv[]) {
  // insert code here...
  /*
   << 是重载运算符，将其理解为函数
   类似于 std::cout.print("Hello, World!\n").print(std::endl);
   
   std::endl，它将光标移动到新行
   
   */
  std::cout << "Hello, World!\n" << std::endl;

  Log("Hi!");

  // 只是等待您按 Enter 移动到程序的下一行，
  // 即到这行程序就暂停了，直到我们按下 Enter 键
  std::cin.get();
  
  // Note：main 函数是个特例，如果这里不返回任何，默认系统将其视为返回 0
  return 0;
}
```

# C++ 编译器

* 1 说明编译器工作的一个例子
  * 下边代码通过 `#include "EndBrace.h"` 可以编译过

```c++
//******* main.cpp

// 预处理，在编译前执行
#include <iostream>

#include "Log.hpp"


int Multiply(int a, int b) {
  int result = a * b;
  return result;
#include "EndBrace.h"


int main(int argc, const char * argv[]) {
  std::cout << "Hello, World!\n" << std::endl;  
  // Note：main 函数是个特例，如果这里不返回任何，默认系统将其视为返回 0
  return 0;
}


//******* EndBrace.h
#ifndef EndBrace_h
#define EndBrace_h

}

#endif /* EndBrace_h */
```

* 2 预编译 `#if`

```c++
// #if true 才编译里边的代码
#if 1 
int Multiply(int a, int b) {
  int result = a * b;
  return result;
#include "EndBrace.h"
#endif
```

# C++ 链接器

* 使用 `static` 表示
  * 只在本文件中使用
  * 不会被其他任何文件可见
  * 可以通过这样避免一些链接错误

```c++
// static 表示 Multiply 只在 main.cpp 文件中使用
// 如果 main.cpp 中没有调用 Multiply，就不会相关链接错误
static int Multiply(int a, int b) {
  int result = a * b;
  Log("Hi!");
  return result;
#include "EndBrace.h"
``` 

* 函数声明必须与实现一样，否则会有链接错误

* 如果两个函数签名一样，会导致链接错误，有以下解决方案：
1. 使用 `static`
2. 使用 `inline`
3. 把其定义移动到同一个翻译单元


<!--![image](/assets/images/react/guide/index_key.png)-->


# 变量

## char
* 占 1 byte

## 布尔类型
* 占 1 byte
* 0 意味着 false，除了 0 之外任何数字都是 true

## sizeof
* 获得类型占用的字节数

```c++
  std::cout << sizeof(char) << std::endl;
```

# 函数


```c++
// 格式：返回类型 函数名称(形参列表) 
int Add(int a, int b) {
  std::cout << a + b << std::endl;
  return a + b;
}
```

> Note：只有 `main` 函数是个特例，可以不返回任何数据，默认系统将其视为返回 0。其他声明返回类型的函数必须返回数据，否则报错。
{: .prompt-info }


# 头文件

## 解决头文件被多次引用的方式：
### 方式一 `#pragm once`：即只包含这个文件一次，它阻止我们单个头文件多次被包含，并转换
 为单个翻译单元。（类似 OC 的 `#import`）

```c++
// Log.hpp
/*
 # 开头被称为预处理器命令
 pragma 本质是一个被发送到编译器或处理器的预处理指令
 #pragma once 即只包含这个文件一次，它阻止我们单个头文件多次被包含，并转换
 为单个翻译单元
 
 */
//#pragma once

//#ifndef Log_hpp
//#define Log_hpp


#include <stdio.h>
#include <iostream>


void Log(const char* message);

struct Player {};
```

### 方式二：`#ifndef 宏`

```c++
#ifndef Log_hpp
#define Log_hpp

#include <stdio.h>
#include <iostream>

void Log(const char* message);

struct Player {};

#endif /* Log_hpp */
```

> 推荐使用 `#pragm once`
{: .prompt-info }


## `""` VS `<>`
* `<>` 只用于编译器包含路径，
* `""` 可以做一切，但通常只用于相对路径


## C/C++ 标准库
* C++ 标准库没有 `.h`。而 C 标准库有 `.h`，这是用来区分 C/C++ 标准库的一种方法
  * 例如：C 中引用是这样 `#include <stdlib.h>`。而 C++ 是 `#include <iostream>`，iostream 就是一个文件



# 原始指针

* 内存就像一个一条街（一条线性的大直线），有开始也有结束，就是一排房子
  - 每个房子都有一个号码和地址（一个字节的数据）

* 指针就是一个整数，就是这些地址，这些地址告诉我们房子在哪里


> 一个指针就是一个地址，它是一个保存内存地址的整数。Just a Integer
{: .prompt-info }


## 类型是完全无意义的

> 所有类型的指针都是保存内存地址的整数。类型只对该内存的操作很有用
{: .prompt-info }


## `0` 不是一个有效的地址


```c++
int main(int argc, const char * argv[]) {
    
    void* ptr = 0;
    void* ptr1 = NULL;
    void* ptr2 = nullptr;
    
    return 0;
}
```

> 0 不是一个有效的内存地址，意味着指针是无效的,如果对 0 地址读/写则程序会崩溃
{: .prompt-info }


## 常规操作

* 通过 `&` 获取变量的内存地址
* 通过 `*` 解引用，修改变量的值


```c++
#include <iostream>

#define LOG(x) std::cout << x << std::endl;

int main(int argc, const char * argv[]) {
    
    int var = 8;
    void* ptr = &var; // 获取 var 的内存地址
    *ptr = 10; // Note：编译 error 因为 void* 不知道设置的是 int
    
    int* ptrIntVal = &var;
    *ptrIntVal = 10;
    
    LOG(var)
      
    return 0;
}
```
   
## 在堆上申请内存，使用指针
   
```c++
#include <iostream>

int main(int argc, const char * argv[]) {

    char* buffer = new char[8]; // 分配 8 字节的内存，并返回一个指向那块内存开始的指针
    /*
        memset
        参数1：接收一个指针，
        参数2：这个指针是内存块的开始位置，比如 0
        参数3：取一个大小，即填充的数量
        
     */
    memset(buffer, 0, 8); // 8 个字节都会被填充为 0

    char** ptrB = &buffer; // 指向指针的指针

    delete[] buffer; // 使用 delete[] 释放内存
    
    return 0;
}
```

## 引用
* 指针和引用本质上是一样的，引用即别名, 引用只是语法糖
* 引用通常只是指针的伪装
* 引用是一种我们引用现有变量的方式，不像指针，你可以创建一个新的指针变量，然后设置它等于空指针或类似的东西，你不能对引用这样做，
因为引用必须`引用`已经存在的变量，引用本身并不是新的变量,它们没有真正的存储空间

* 引用可以让代码更简洁

> Tips: 引用并不占用内存, 也不产生新的变量
{: .prompt-info }


* 语法：`类型&` 表示取引用

```c++
#include <iostream>

#define LOG(x) std::cout << x << std::endl;

// 使用指针
void Increment(int* value) {
    (*value)++;
}

// 使用引用
void Increment2(int& value) {
    value++;
}

int main(int argc, const char * argv[]) {
    
    int a = 5;
    int* b = &a;
    
    // & 是类型的一部分，int& 表示取引用
    // 引用并不占用内存，也不产生新的变量
    // 引用就是别名
    int& ref = a;
    
    ref = 2;
    LOG(a)
    
    Increment2(a);
    LOG(a)

    return 0;

}

```

### 引用的另一个重要的事
* 一旦你声明了一个引用，你不能改变它引用的东西
* 引用时必须初始化赋值

```c++
int main(int argc, const char * argv[]) {
    
    int a = 5;
    int b = 8;
    
    // 重要 Note：一旦你声明了一个引用，你不能改变它引用的东西
    // 不能下边这样，这样意思是 a 的值被赋值为 b 的值，也就是 8
//    int& ref = a; // 对变量 a 引用, 引用时必须初始化赋值
//    
//    ref = b; // 不能这样，这样意思是 a 的值被赋值为 b 的值，也就是 8
//    
//    LOG(a) // a = 8
//    LOG(b) // b = 8
    
    // 那如何修改上边 `ref` 的指向？ 
    // 答案是使用指针

    int* ref = &a;
    *ref = 3;
    
    ref = &b;
    *ref = 1;

    LOG(a) // a = 3
    LOG(b) // b = 1

    return 0;
}
```


# 类

```c++
class Player {

// 默认类中属性都是 private 的，意味着只有函数能访问那些变量
// 下边声明为 public，使外部可访问
public:
    int x, y;
    int speed;
    
    // 类中的方法
    void Move(int xa, int ya) {
        x += xa * speed;
        y += ya * speed;
    }
    
}; // Note：这里有个 ;


//void Move(Player& player, int xa, int ya) {
//    player.x += xa * player.speed;
//    player.y += ya * player.speed;
//}


int main(int argc, const char * argv[]) {
        
    Player player;
    player.x = 5;
    
    player.Move(3, 5);
    return 0;

}
```

## 类 VS 结构体
* 基本上没有区别，只有一个关于可见度的区别


> 一个类的成员默认是 `private`; 而在结构体中成员默认是 `public`
{: .prompt-info }


```c++
struct Player {
private:         // 默认为 public，除非手动设置为 private
    int x, y;
    int speed;
    
    
    void Move(int xa, int ya) {
        x += xa * speed;
        y += ya * speed;
    }
    
};
```

* C++ 中还保留结构体是因为它希望与 C 保持向后兼容，因为 C 代码没有类，但是 C 有结构体

* 我们可以用 `#define struct class`，这样与 C 保持兼容性  



## 何时使用类，何时使用结构体

### 使用结构体：
1. 简单的数据的结构，例如 Vec，Point


```c++
struct Vec2 
{
    float x, y;
    
    void Add(const Vec2& other) 
    {
        x += other.x;
        y += other.y;
    }
    
};
```


### 使用类
1. 复杂的数据结构
2. 涉及继承


## 一个不好的简单的类 Demo

```c++

#include <iostream>

class Log
{
public:
    const int LogLevelError = 0;
    const int LogLevelWarning = 1;
    const int LogLevelInfo = 2;

private:
    int m_LogLevel = LogLevelInfo; // 私有成员，使用 m_ 前缀; 默认为 LogLevelInfo
    
    
public:
    
    void SetLevel(int level)
    {
        m_LogLevel = level;
    }
    
    void Error(const char* message)
    {
        if (m_LogLevel >= LogLevelError) {
            std::cout << "[Error]: " << message << std::endl;
        }
    }
    
    void Warn(const char* message)
    {
        if (m_LogLevel >= LogLevelWarning) {
            std::cout << "[WARNING]: " << message << std::endl;
        }
    }
    
    void Info(const char* message)
    {
        if (m_LogLevel >= LogLevelInfo) {
            std::cout << "[Info]: " << message << std::endl;
        }
    }
    
};

int main(int argc, const char * argv[]) {
    Log log;
    log.SetLevel(log.LogLevelWarning);
    log.Warn("Hello!");
    log.Error("Hello!");
    log.Info("Hello!");
    return 0;
}
```


# C++ 中 static
## 两种情况

### case 1：在类或结构体`外部`使用 `static` 关键字
* 意味着它只能对你定义它的翻译单元可见
* `static` 关键字就类似一个 `private` 变量


```c++
// static.cpp

// 静态变量以 s_ 开头
// 这个变量只会在这个翻译单元内部进行链接
// 即：链接器不会在这个翻译单元的作用域之外，寻找那个符号定义
static int s_Variable = 5;


static void Function() {
    std::cout << "static Function" << std::endl;
}


// -------------------------

// main.cpp
int s_Variable = 10;

int main(int argc, const char * argv[]) {
    
    std::cout << s_Variable << std::endl;
    
    Function();

    return 0;
}

void Function() {
    std::cout << "main Function" << std::endl;
}

// 可以编译通过
```


> 这个变量只会在这个翻译单元内部进行链接, 即：链接器不会在这个翻译单元的作用域之外，寻找那个符号定义. 
{: .prompt-info }


* 或者去掉 static, 声明 extern 也可以通过编译

```c++
// static.cpp
int s_Variable = 5;



// main.cpp
extern int s_Variable;

int main(int argc, const char * argv[]) {
    
    std::cout << s_Variable << std::endl;
    
    return 0;
}
```


> 小结：全局变量不是个好习惯，你可以让函数或变量标记为静态的，除非你真的需要它们跨翻译单元链接
{: .prompt-info }



### case 2：在类或结构体`内部`使用 `static` 关键字
* 意味着该变量将与类的所有实例共享内存
* 意味着该静态变量在你的类中创建的所有实例中，静态变量只有一个实例
* 类似的也适用于类中的静态方法


> Note：你不能引用到类的实例
{: .prompt-info }


```c++
struct Entity {
    int x, y;
    
    void Print()
    {
        std::cout << x << ", " << y << std::endl;
    }
};


int main(int argc, const char * argv[]) {
    
    
    Entity e;
    e.x = 2;
    e.y = 3;
    
    Entity e1 = { 5, 8};
    
    e.Print();
    e1.Print();
    
    return 0;
}
```

* 如果我们将 `x, y` 声明为 `static` 会怎样？


```c++
struct Entity {
    static int x, y;

    static void Print()
    {
        std::cout << x << ", " << y << std::endl;
    }
};


int Entity::x;
int Entity::y;


int main(int argc, const char * argv[]) {
    
    std::cout << s_Variable << std::endl;
    
    Function();
    
    Entity e;
    e.x = 2;
    e.y = 3;
    
//    Entity e1 = { 5, 8}; // 初始化会报错, 因为 x y 不属于实例
    Entity e1;
    e1.x = 5;
    e1.y = 8;
    
    // 我们可以这样写
    Entity::x = 5;
    Entity::y = 8;


    e.Print();  // 5, 8
    e1.Print(); // 5, 8
    
    Entity::Print();
    
    return 0;
}

```


> 类中使用 `static` 是因为有时你想要在所有 `Entity` 实例之间共享数据. 静态方法不能访问非静态变量, 因为静态方法没有类实例
{: .prompt-info }



# C++ 中的局部静态（Local Static）
* 在一个局部作用域使用 static，不同于上边说的两种 case
* 声明一个变量，我们需要考虑两种情况：
    1. 变量的生命周期：指变量实际的存活时期，即在它被删除之前，它会在我们的内存中存在多久
    2. 变量的作用域：指我们可以访问变量的范围

* Local Static 变量允许我们声明一个变量，它的生命周期基本相当于整个程序的生命周期，然而它的作用范围被限制在这个函数内。
你可以在任何作用域中声明


```c++
void Function() {
    static int i = 0;
    i++;
    std::cout << i << std::endl;
}

int main(int argc, const char * argv[]) {
    Function();
    Function();
    Function();
    Function();    
}
```

## 使用 `Local Static` 的另一个例子是，在单列中使用它

* 这是没有使用 `Local Static` 的例子，相当繁琐

```c++
class Singleton
{
private:
    static Singleton* s_Instance;
    
public:
    static Singleton& Get() {
        return *s_Instance;
    }
    
    void Hello() {}
};


Singleton* Singleton::s_Instance = nullptr;

int main(int argc, const char * argv[]) {

    Singleton::Get().Hello();
    
}
```

* 使用 `Local Static` 的例子

```c++
class Singleton
{
public:
//    static Singleton Get() {
    /*
        如果 s_Instance 不使用 static，返回引用可能有问题
        只有声明了 static 才会保持其引用的生命周期足够长
     */
     
    static Singleton& Get() {
        static Singleton s_Instance;
        return s_Instance;
    }
    
    void Hello() {
        std::cout << "Hello" << std::endl;
    }
};

int main(int argc, const char * argv[]) {

    Singleton::Get().Hello();
    
}
```


# C++ 枚举
* 枚举默认: 从 0 开始, 依次递增
* 或你可以指定初始值
* 冒号后必须时整数; 冒号后不能使用 float，因为 float 不是整数

```c++
//enum Example : unsigned char  // unsigned char 枚举认为是 32 位整型
enum Example : char
{
    A = 5, B, C
};

int main(int argc, const char * argv[]) {
    
    std::cout << "Example::A: " << Example::B << std::endl;

}
```

## 使用枚举改进 Log Demo

```c++
class Log
{
public:
    
    // 这个 Level 不是真正的命名空间
    enum Level
    {
//        Error = 0 , Warning, Info
        LevelError = 0 , LevelWarning, LevelInfo
    };
    
private:
    Level m_LogLevel = LevelInfo; // 私有成员，使用 m_ 前缀; 默认为 LogLevelInfo
    
public:

    void SetLevel(Level level)
    {
        m_LogLevel = level;
    }

    /*
        Note：枚举变体名称不能与函数名称相同
        可以改 Error 为 LevelError
     */
    void Error(const char* message)
    {
        if (m_LogLevel >= LevelError) {
            std::cout << "[Error]: " << message << std::endl;
        }
    }
    
    void Warn(const char* message)
    {
        if (m_LogLevel >= LevelWarning) {
            std::cout << "[WARNING]: " << message << std::endl;
        }
    }
    
    void Info(const char* message)
    {
        if (m_LogLevel >= LevelInfo) {
            std::cout << "[Info]: " << message << std::endl;
        }
    }
    
};


int main(int argc, const char * argv[]) {
    Log log;
    log.SetLevel(Log::LevelError);
    log.Warn("Hello!");
    log.Error("Hello!");
    log.Info("Hello!");
    return 0;
}
```


> 小结：枚举的本质就是整数
{: .prompt-info }


# C++ 构造函数 & 析构函数

## 构造函数
* 构造函数是一种特殊类型的方法，一种每次你构造一个对象时都会调用的方法
* 构造函数名称要与类名相同
* 如果你写构造函数，会有一个默认的构造函数，默认的构造函数什么也没做
* 像 JAVA 基本数据类型，比如 int 和 float，会自动初始化为 0，


> C++ 不会自动初始化基本数据类型，你必须手动初始化所有的基本类型。否则它们将被设置为留在该内存中的其他什么值（类似 C）。构造函数，主要用途是初始化该类
{: .prompt-info }


* 当你使用 `new` 创建一个类的实例时，它会自动调用构造函数


> C++ 为我们提供了默认的构造函数，默认的构造函数什么也没做
{: .prompt-info }


## 析构函数
* 析构函数是在对象销毁时被调用
* 析构函数同时适用于栈和堆分配的对象
    - 如果你使用 `new` 分配一个对象，当你调用 `delete` 时，析构函数会被调用
    - 如果只是一个`栈对象`, 当作用域结束时，栈对象将被删除，这时析构函数也会被调用



```c++
class Entity {
    
public:
    float X, Y;

    // 默认的构造函数：如果你不写构造函数，会有一个默认的构造函数，默认的构造函数什么也没做
    // 构造函数: 名称要与类名相同
    Entity()
    {
        X = 0;
        Y = 0;
        std::cout << "Fashioned Entity!" << std::endl;
    }
    
    // 函数重载：即有相同函数名称，但有不同的参数的不同函数版本
    Entity(float x, float y)
    {
        X = x;
        Y = y;
    }
    
    // 析构函数
    ~Entity()
    {
        std::cout << "Destroyed Entity!" << std::endl;

    }
    
    void Print()
    {
        std::cout << X << ", " << Y << std::endl;
    }
    
};


class DLog {
    
public:
    DLog() = delete;  // Note: 删除构造函数，让调用者只能使用 static 方法

    static void Write()
    {
        
    }
    
};


void Function2()
{
    Entity e;
    e.Print();
//    e.~Entity(); // Note：可以手动调用析构函数，但不常用

}

int main(int argc, const char * argv[]) {

    // 栈分配, 当主函数退出时 析构函数才会被调用
//    Entity e = Entity(5.0, 10.0);
//    std::cout << e.x << ", " << e.y << std::endl;
//    e.Print(); // 当没有构造函数时，得到未知的值，因为没有初始化 x y

    
    Function2();
    
    DLog::Write();
//    DLog l; // error: 因为 DLog 的构造函数被 delete
    
}
```

# 继承

```c++

class Entity {
    
public:
    float X, Y;
    
    void Move(float xa, float ya)
    {
        X += xa;
        Y += ya;
    }
    
};

// 任何 Entity 类中不是私有的东西，实际上都可以被 Player 访问
class Player: public Entity {
    
public:
    const char* Name;
    
    
    void PrintName()
    {
        std::cout << Name << std::endl;
    }
};

int main(int argc, const char * argv[]) {
    
    std::cout << sizeof(Entity) << std::endl;
    std::cout << sizeof(Player) << std::endl;

    Player player;
    player.Move(5, 5);
    player.PrintName();
    
    return 0;
}
```


> 如果我们重新函数和 Player 类，那么就需要维护一个 V 表（虚函数表）
{: .prompt-info }


# 虚函数

* 使用 `virtual` 标记，告诉编译器为某个函数生成`虚表`吧，这样如果它被重写 `override` 了，以便可以指向正确的函数


```c++
#include <iostream>
#include <string>

class Entity {
    
public:
    // virtual 标记，告诉编译器为这个函数生成 v表吧，
    // 这样如果它被重写 override 了，以便可以指向正确的函数
    virtual std::string GetName() { return "Entity"; }
};

class Player : public Entity {

private:
    std::string m_Name;
public:
    Player(const std::string& name) : m_Name(name) {
        
    }
    /*
     C++ 11, 引入了 override 标记，但这不是必须的
     但最好还是写 override，这样好处有
     1 可读性更高
     2 以防编译错误
     */
    std::string GetName() override { return m_Name; }

};

void PrintName(Entity* entity)
{
    /*
        这里传 Player or Entity，GetName 都会是 Entity
        原因如下：
        通常声明函数时，我们方法通常在内部起作用，
        然后当要调用方法时候，会调用属于该类型的方法
        这里参数是 Entity 类型，它就只会在 Entity 类中找方法
        然鹅我们希望 C++ 能知道传入的具体类型，让它去具体的类型中找方法，
        这时就是虚函数出现的地方
     
     
        虚函数：
        引入了一个叫做动态联编（Dynamic Dispatch）的东西，
        它通常通过 v表（虚函数表）来实现编译，
        v表就是一个表，它包含基类中所有虚函数的映射，这样就可以在运行时，
        将它们映射到正确的覆写（override）的函数
  
        简单起见：
        你只需知道，如果你想覆写（override）一个函数，
        必须将基类中的基函数标记为虚函数
     */
    std::cout << entity->GetName() << std::endl;
}

int main(int argc, const char * argv[]) {
    
    Entity *e = new Entity();
    PrintName(e);                 // Entity
//    std::cout << e->GetName() << std::endl;  // Entity
    
    Player *p = new Player("Hello");
    PrintName(p);                 // Entity
//    std::cout << p->GetName() << std::endl;  // Hello
    
    return 0;
}
```

## 虚函数不是免费的，有两个与虚函数相关的运行成本
1. 我们需要额外的内存来存储 v表，这样我们就可以分配到正确的函数，包括基类中要有一个成员指针指向 v表
2. 每次我们调用虚函数时，我们需要遍历这个表，来确定要映射到哪个函数

> 虚函数有成本，但成本很小可以忽略不计，不影响使用
{: .prompt-info }

