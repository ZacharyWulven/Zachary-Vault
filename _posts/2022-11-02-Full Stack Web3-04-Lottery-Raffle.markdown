---
layout: post
title: Full Stack Web3-04-Lottery-Raffle
date: 2022-11-02 16:45:30.000000000 +09:00
tag: 区块链
---

# Hardhat Smart Contract Lottery/Raffle ( Lesson 9)

本节课制作 FundMe 合约的前端
Full Stack = Smart Contracts（backend）+ HTML / Javascript / Website stuff (front e   nd)

## 0x01 Hardhat setup
参考：https://github.com/smartcontractkit/full-blockchain-solidity-course-js#lesson-9-hardhat-smart-contract-lottery
{% highlight ruby %} 
1 $ mkdir hh-contract-lottery-fcc
2 $ cd hh-contract-lottery-fcc
3 $ code .
4 $ yarn add --dev hardhat 
5 $ yarn hardhat 选择空模板创建项目
6 安装所有依赖
$ yarn add --dev @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers \
ethers @nomiclabs/hardhat-etherscan @nomiclabs/hardhat-waffle chai \
ethereum-waffle hardhat hardhat-contract-sizer hardhat-deploy \
hardhat-gas-reporter prettier prettier-plugin-solidity solhint \
solidity-coverage dotenv
{% endhighlight %}

### Write Contract Code

{% highlight ruby %} 
1 在根目录 mkdir contracts 目录
2 Raffle.sol

Event 参考：https://www.youtube.com/watch?v=KDYJC85eS5M
{% endhighlight %}

### Tips
{% highlight ruby %} 
1 external 比 public 更省 gas
2 带 virtual 方法表示期望被 override
{% endhighlight %}

## 0x02 Chainlink VRF (Randomness in Web3)
{% highlight ruby %} 
Chainlink VRF 文档 https://docs.chain.link/vrf/v2/subscription/examples/get-a-random-number
Open subscription Manager https://vrf.chain.link/?_ga=2.214098708.2047585917.1669966594-236993336.1663668981
{% endhighlight %}

### Create Subscription 链接钱包
![](/assets/images/web3-full/vrf-01.png)

### Add Funds 输入 10，创建 10 个连接
![](/assets/images/web3-full/vrf-02.png)


{% highlight ruby %} 
1 import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";
2 $ yarn add --dev @chainlink/contracts
3 继承 VRFConsumerBaseV2，contract Raffle is VRFConsumerBaseV2 { }
{% endhighlight %}

### Hardhat Shorthand 简化输入的命令
{% highlight ruby %} 
1 安装 hardhat-shorthand
$ yarn global add hardhat-shorthand

2 $ hh compile 等于 $ yarn hardhat compile
{% endhighlight %}

### 实现 VRF Request
{% highlight ruby %} 
https://vrf.chain.link/?_ga=2.218722074.2047585917.1669966594-236993336.1663668981
get subscriptionId 等一些参数

VRF 获取随机数代码
    // 已经产生 Winner
    // 实际是 Chainlink 调用这个方法
    function fulfillRandomWords(
        uint256 /* requestId 用不到参数可以注释掉，只声明类型 */,
        uint256[] memory randomWords
    ) internal override {
        uint256 indexOfWinner = randomWords[0] % s_players.length;
        address payable recentWinner = s_players[indexOfWinner];
        s_recentWinner = recentWinner;
        s_raffleState = RaffleState.OPEN;
        s_players = new address payable[](0);
        s_lastTimeStamp = block.timestamp;
        (bool success, ) = recentWinner.call{value: address(this).balance}("");
        //require(success, "");
        if (!success) {
            revert Raffle__TransferFailed();
        }
        emit WinnerPicked(recentWinner);
    }
{% endhighlight %}

## 0x03 Chainlink Automation（以前叫 Chainlink Keeper）
* 用于自动触发合约 https://docs.chain.link/chainlink-automation/compatible-contracts/
* Sample https://remix.ethereum.org/#url=https://docs.chain.link/samples/Automation/AutomationCounter.sol&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.7+commit.e28d00a7.js
* checkUpkeep 函数表示是时候得到一个随机数了么 ？

### Chainlink Automation 代码
{% highlight ruby %} 
    /**
     * @dev This is the function that the Chainlink Keeper nodes call
     * they look for the `performUpkeep` to return true
     * if checkUpkeep return true means need a random number
     * The following should be true in order to return true:
     * 1. Our time interval should have passed
     * 2. The lottery should have at least 1 player, and have some ETH
     * 3. Our subscription is funded with LINK
     * 4. The lottery should be in an "open" state.
     */
    // performData 允许任何想要东西，即我们可以调用其他方法做更高级的事
    function checkUpkeep(
        bytes memory /* checkData */
    ) public view override returns (bool upkeepNeeded, bytes memory /* performData */) {
        // We don't use the checkData in this  example. The checkData is defined when the Upkeep was registered.
        bool isOpen = (RaffleState.OPEN == s_raffleState);
        bool timePassed = ((block.timestamp - s_lastTimeStamp) > i_interval);
        bool hasPlayers = (s_players.length > 0);
        bool hasBalance = (address(this).balance > 0);
        // 当条件满足触发 `performUpkeep` 去抽奖
        upkeepNeeded = (isOpen && timePassed && hasPlayers && hasBalance);
    }

    // external 比 public 更省 gas
    // 请求获得 Winner
    // 实际是 Chainlink 调用这个方法
    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function

        // Request the random number
        // Once we get it, do something with it
        // 2 transaction process
        // 随机数请求函数，使用 chainlink 随机数决定获胜者

        /* fix compile error for checkUpkeep("")
         * 字符串 不适用于 calldata，所以要改成 memory
         */
        (bool upkeepNeeded, ) = checkUpkeep("");
        if (!upkeepNeeded) {
            revert Raffle__UpkeepNotNeeded(
                address(this).balance,
                s_players.length,
                uint256(s_raffleState)
            );
        }

        s_raffleState = RaffleState.CALCULATING;

        uint256 requestId = i_vrfCoordinator.requestRandomWords(
            i_gasLane, // gasLane
            i_subscriptionId,
            REQUEST_CONFIRMATIONS, // 等待区块数量
            i_callbackGasLimit,
            NUM_WORDS
        );
        emit RequestedRaffleWinner(requestId);
    }
{% endhighlight %}

## 0x04 Unit Tests
{% highlight ruby %} 
$ hh test --grep "updates the raffle state"


编辑 hardhat.config.js 添加如下
    mocha: {
        timeout: 200000, // 200 seconds max
    },
{% endhighlight %}
## 0x05 Staging Tests
