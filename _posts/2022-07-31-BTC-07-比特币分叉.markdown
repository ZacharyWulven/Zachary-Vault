---
layout: post
title: BTC-07-比特币分叉
date: 2022-07-31 16:45:30.000000000 +09:00
tag: 区块链
---

## 0x01 产生分叉 fork 的原因
1. state fork：即对区块链状态有意见分歧而导致的分叉，比如当两个矿工同时挖到矿，forking attack 也属于 state fork，只不过 forking attack 是人为的，
forking attack 也叫 deliberate fork

2. 因为协议改变而分叉 Protocol fork
*  比如比特币协议的修改，修改协议就需要升级软件，不能保证所有节点同时都升级，假设大部分节点升级了软件，有些节点可能来不及升级或节点（所在社区）不同意对协议的修改

根据对协议修改的内容不同又分成
* 硬分叉
* 软分叉

## 0x02 硬分叉（hard fork）
* 即新增了一些 feature 导致与旧的不兼容，而旧的不认可新的协议

### 经典的例子是区块大小 block size limit

一个交易大约 250 字节，而 1M 大约有 4000 个交易
{% highlight ruby %}
4000 / (60 * 10分钟) = 7 tx/sec，每秒处理 7 笔交易
{% endhighlight %}

所以有人提出了增加区块大小

比如，区块大小增加到 4 M，这时大部分算力高的节点都升级了，而少部分节点没有升级，当升级的节点挖到块时可能块大小是 4M，这时没有升级的节点认为是不合法的，
不会沿着升级的节点刚挖出的块继续挖，会还是沿着之前的块挖，这样就导致了分叉，只要少部分节点不升级那么这个分叉就一直存在，因为没有升级的节点不认可区块大小是
4M 的链是合法的。

注：新节点认为区块大小小于等于 4M 就是合法的，只是旧节点认为新节点的新区块不是合法的

块大小不是越大越好，因为比特币底层使用 P2P 传输，泛洪同步，对带宽消耗比较大，带宽是瓶颈

{% highlight ruby %}
硬分叉后两个链都合法，新链上会有新的加密货币产生，各自有自己的加密货币
分叉之前的币，应该变成上下俩链都认可，一个币拆成俩个

{% endhighlight %}

另一个典型的例子是 ETH 和 ETC，ETC 才是最早的以太坊协议，分叉后有个真实案例，是在一条链交易，在另一条链回放，
比如在一条链交易 B 买东西转个 C 钱 (B->C)，后来退钱不买了(C->B)，这时在另一条链回放 C->B，
由于这个问题后来每个链增加了 chainID 把各自分开，现在以太坊链已经没有问题了

![](/assets/images/btc/hard_fork.png)



## 0x03 软分叉（soft fork）
* 定义：如果对协议增加一些限制，导致增加限制后，原来合法的区块和交易变成了不合法的就会引起软分叉

* 还是以区块大小为例，比如把区块大小改为 0.5M (只是为了说明软分叉这个例子，实际不会这么干，因为 1M 已经很小了)

注：旧节点认为新节点的新区块和自己挖的块都是合法的，但新节点只认新节点的块，
* 所以旧节点会沿着两条链挖，但有可能挖出 1M 的块白挖了，因为新节点算力更强，产生合法链概率更高
* 所以旧节点不更新软件会生活的比较抑郁😂

* 但系统不会有永久的分叉，这就是软分叉

![](/assets/images/btc/soft_fork.png)


### 产生软分叉的情况
1. 给某些目前协议中没有规定的域增加新的含义，赋予它们新的规则
* 比如 coinbase transaction 的 coinbase 域（

{% highlight ruby %}
之前讲过 coinbase 可以作为 extra nonce 调整挖矿难度
因为 nonce 4 个字节，是 2^32 搜索空间不够大
可以把 coinbase 前 8 字节用于 extra nonce，这样这里合在一起范围扩大到 2^96

但 coinbase 阈不止 8 个字节后边还有好多

{% endhighlight %}

有人提出把 coinbase 后边位用来存 UTXO 集合的根 hash 值，目前 UTXO 的根 hash 值的集合是全节点在内存中维护，
主要为了快速查找判断交易是否是双花，
* 但这个集合的内容并没有写入区块链中
* 这和 merkle proof（证明某个交易是否在这个区块中，全节点返回 merkle proof 给轻节点进行验证） 不同
* 但如果想知道每个账户有多少钱，只有全节点才能算，但轻节点如果问全节点，轻节点怎么验证全节点返回的是对的，
所以有了往 coinbase 里存 UTXO 集合的根 hash 值，这样算 merkle root 哈希时 UTXO 合集根 hash 也参与计算，
之后 merkle proof 就能证明出来


如何区分硬分叉和软分叉
{% highlight ruby %}
如果一个分叉，新节点不认，而旧节点认新的链和之前的链那么就是软分叉，反之是硬分叉
{% endhighlight %}

比特币历史上比较著名的软分叉例子是 P2SH，通过软分叉加入 P2SH 功能
* phase1 先验证 input/output script 中的 redeem script hash 是对的上的
* phase2 再执行验证 redeem script 验证 input script 给的签名是合法的
* 这样旧节点只会验证第一阶段，而新节点会验证俩个阶段


## 0x04 小结
* soft fork 特点：只要系统中有半数以上算力节点更新了软件，就不会出现永久的分叉，分叉是暂时的
* hard fork 特点：必须所有节点都升级软件，才不会产生永久的分叉


## 0x05 问答
1. 转账时候对方不在线怎么办？
* 转账不需要对方在线，转账不过是做些记录，把我的账户的钱转给别人

2. 全节点收到转账交易，是否可能收到新的公钥地址
* 可能

3. 如果私钥丢失了怎么办？
* 没有办法，这个账户的钱变成了死钱，取不出来
* 但加密货币交易所是一个中心化机构，你开户会存你的私钥，可能还有 Google 二次验证，但交易所受监管少，跟股票交易所受管制程度完全不同，
如果是交易所这种，可以找回私钥
* 一个例子是 Mt.Gox，中文翻译成门头沟

4. 私钥泄露了怎么办
* 尽快把账户的钱转到另外一个安全的账户
* 私钥改不了

5. 如果转账时写错了地址怎么办
* 没有办法 😂

6. 节点是否能偷 nonce？比如一个节点挖到矿，然后另一个节点偷 nonce 组装一个区块发布？
* 不行，因为 coinbase ttransaction 里的收款人地址是挖到矿的人的，如果想偷需要改这个收款地址，导致 merkle tree root hash 会变，
这时偷到的 nonce 就不对上了

7. 交易费怎么知道给哪个矿工，怎么知道哪个矿工会挖到矿？
* 事先不需要知道是哪个矿工
* 交易费 = total inputs - total outputs，挖到矿的矿工只要把自己区块里所有交易费都收集了就行了


{% highlight ruby %}
地址是通过公钥 hash 得到的，但有些地址不是通过公钥 hash 得到的，比如 digital commitment 和 Proof of Burn，它们没有私钥
{% endhighlight %}
