---
layout: post
title: BRC-20
date: 2023-10-24 16:45:30.000000000 +09:00
categories: [BTC, BRC20]
tags: [BTC, BRC20]
---


# 0x01 基础原理

> 1 BTC = 10^8 sat(聪)
{: .prompt-info }

* 序号按照它们被开采的顺序分配给 satoshis。第一个区块中的第一个聪的序号为 0，第二个聪的序号为 1，第一个区块的最后一个聪的序号为 `4,999,999,999`。
* satoshis 存在与输出中，但交易会破坏输出创建新的输出。隐藏序数理论使用一种算法来确定 satoshis 如何聪交易输入跳到其输出
* 相当于一个聪就是一个 NFT，每一个聪都有自己的编号

## 隔离见证
* 近些年，一些扩容技术（隔离见证等），可以让一个聪里边增加一段铭文的信息，就像是转账的附言，是用脚本的方式去实现的
* 这样就可以使一个区块大小额外增加 4M，这个区域叫隔离见证区
* 但 `UTXO` 信息还是放原来的 1M 中，只是可以额外附加一些信息了
* 这个技术为后来的 BRC20 带来了基础设施，这就形成了后来铭文的概念


## 0x02 Ordinal 序数起源
* 2022 年 12 月，比特币开发者 Casey Rodarmor 发布了名为 [ORD](https://github.com/casey/ord) 的开源软件
* 该软件在 BitCoin Core 全节点上运行
* 该软件允许用户将计算机文件编码为十六进制数据，存储在比特币交易（的铭文）中，并将该发布数据绑定到一个单独的聪上，从而有效的创建一个 NFT
* 这种技术仅仅是给聪打上了一个铭文，而并不像 `ERC-20` 是部署一个智能合约
* 转账时候再打一个转账的铭文



## BRC-20 具体内容

* BRC-20 铭文 json 格式

```
{
  "p": "brc-20",     // 协议
  "op": "deploy",    // 操作，这里是部署
  "tick": "ordi",    // 部署的这个 brc-20 协议的名字叫 ordi，类似 bayc
  "max": "21000000", // 总量是 21000000，只有整数，最小单位就是 1 
  "lim": "1000"      // 每次转账最多转 1000 个
}
```

* BRC-20 的 max 是总量字段
  * 定义好后，不能增发
  * 需要自己 `mint` 才行
  * 任何人都可以 `mint`，例如对 `ordi` 进行 `mint`（如果没有达到上限的话），每次 `mint` 最大 1000 个


* 铭文在比特币脚本中表示

```
OP_FALSE
OP_IF
  OP_PUSH "ord"
  OP_1
  OP_PUSH "text/plain;charset=utf-8"
  OP_0
  OP_PUSH "上边的 json 铭文内容"
OP_ENDIF
```


## 0x03 BRC-20 VS ERC-20

* BRC-20 
  * 纯链上记录
  * 无智能合约
  * 链外索引（中心化）
    * 例如：mint 一个超过上限的，因为没有智能合约，比特币脚本依然可以通过，但链外索引时候，人家可以不认
  * BRC-20 每个 Token 都需要 mint
  * 难以防止双花
    * 可能因为序号错误，导致两方都能收到 sats

* ERC-20 
  * 智能合约驱动
  * 逻辑自由但有风险
  * 链上索引，更加精确
  * 有效防止双花
  
  
  
  

<!-->-->
<!--{: .prompt-info }-->


