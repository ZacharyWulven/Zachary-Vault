---
layout: post
title: ReactGuide-03
date: 2023-11-07 16:45:30.000000000 +09:00
categories: [Web, React, 入门]
tags: [Web, React]
---


# React 脚手架

## 简介
* 脚手架时用来帮助开发者快速创建一个基于某个库的模板项目，这里的脚手架是用 `webpack` 搭建的
* react 提供了一个用于创建 react 项目的脚手架库：`create-react-app`
* 项目的整体技术框架为：`react + webpack + es6 + eslint`

## 安装

```shell
$ npm i -g create-react-app

# create-react-app [项目名称]
$ create-react-app hello-react
```

> 如果是 M1 芯片 Mac，可能需要执行命令 `sudo chown -R 501:20 "/Users/{your name}/.npm"`
{: .prompt-info }


## 基本命令

```shell
# 启动项目，查看开发效果
# 通过 webpack-dev-server 开启 http://localhost:3000 进行访问
$ yarn start

# 将项目打包，生成静态文件，准备部署
$ yarn build

# React 会把 webpack 文件全部隐藏
# 此命令会把所有 webpack 都暴露出来，此命名不可逆
$ yarn eject
```

> `package.json` 为包配置文件
{: .prompt-info }

## 项目结构介绍

* 如图

![image](/assets/images/react/guide/app_dir.png)

### `public` 目录（不能改名）：一般存储静态资源文件，例如页面、样式、图片等
* 1 `favicon.ico`
* 2 `index.html`：主页面（开发中只有这一个页面）
  * React/Vue 开发是单页面应用（SPA）
    
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <!-- 指定网页页签的图标，用 link 方式引入 -->
    <!-- %PUBLIC_URL% 表示 public 目录的路径 -->
    <!-- <link rel="icon" href="%PUBLIC_URL%/favicon.ico" /> -->
    <!-- 也可以用相对路径写 -->
    <link rel="icon" href="./favicon.ico" />

    <!-- 用于移动端网页适配 -->
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- 用于配置浏览器页签+地址栏的颜色（只支持于 Android 手机平台，很少用） -->
    <meta name="theme-color" content="#000000" />

    <!-- 描述网页信息 -->
    <meta
      name="description"
      content="Web site created using create-react-app"
    />

    <!-- Apple 手机添加网页到主屏后的图标  -->
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />

    <!-- manifest.json 用于应用加壳的配置文件，兼容性不好，不加壳可以忽略  -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />

    <title>React App</title>
  </head>
  <body>
    <!-- 若浏览器不支持 js 则展示标签中的内容 -->
    <noscript>You need to enable JavaScript to run this app.</noscript>
    
    <!-- App 组件放到 root 节点中 -->
    <div id="root"></div>
  </body>
</html>
```

* 3 `robots.txt`：爬虫规则文件，什么可爬，什么不可爬


### `src` 目录（不能改名）：
* `App.js`：即 `App` 组件
* `App.css`：组件 `App` 的样式
* `App.test.js`：用于测试 `App` 的，但很少用，一般之间运行进行测试
* `index.css`：通用的样式
* `index.js`：入口文件，在这个文件引入 `react`、`react-dom`
  * `<React.StrictMode>` 可以检查 `<App />` 中的代码是否合理
  * `reportWebVitals` 用于记录页面性能，使用了 `web-vitals` 库

```javascript
import React from "react";
import ReactDOM from "react-dom/client";
import "./index.css";
import App from "./App";
import reportWebVitals from "./reportWebVitals";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
```

* `setupTests.js`：用于应用整体测试，组件测试，使用了 `jest-dom` 库

### 启动流程
1. `index.js` 开始 `render` 组件 `App`
2. 去 `index.html` 中找 `root` 容器
  * `index.html` 名字不能改，是 React 底层写死的


> 重要的文件 `index.html`(主页面)、`App.js`（组件）、`index.js`（入口文件）
{: .prompt-info }


## Hello Demo

### `js` 的两种目录结构编程风格：
1. `src/component/Hello/Hello.js`：
  * 优点：查看直观，方便查找
  * 缺点：引入时，啰嗦，`import Hello from "./components/Hello/Hello"`
  
2. `src/component/Welcome/index.js`：
  * 优点：引入时简便，`import Welcome from "./components/Welcome"` 即找 `Welcome` 目录下的 `index.js` 引入
  * 缺点：查看代码是可能不能直观的告你开发者是哪个 `index`

```javascript
/*
  两种目录结构
  src/component/Hello/Hello.js
  src/component/Welcome/index.js
*/
import Hello from "./components/Hello/Hello";
import Welcome from "./components/Welcome";
```

### css 模块化

```javascript
import React, { Component } from "react";
/*
  css 模块化
  1 将 css 文件定义为 index.module.css
  2 import welcome from "./index.module.css";
  3 标签中 className={welcome.demo}
*/
import welcome from "./index.module.css";

export default class Welcome extends Component {
  render() {
    return <h2 className={welcome.demo}>Welcome!</h2>;
  }
}
```

### 插件安装
* 在 VSCode 中搜 `ES7+ React/Redux/React-Native snip`，安装它
  * 在 `js` 或 `jsx` 文件中：
    * 输入 `rcc`，即可定义类组件模板
    * 输入 `rfc`，即可定义函数组件模板


### Hello 结构

![image](/assets/images/react/guide/hello.png)


* index.js

```javascript
// 引入 React 核心库
import React from "react";
// 引入 ReactDOM 核心库
import ReactDOM from "react-dom";
import "./index.css";
// 引入 App 组件
import App from "./App";
import reportWebVitals from "./reportWebVitals";

// 渲染 App 组件到页面
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

reportWebVitals();
```


* App.js

```javascript
/*
    import React, { Component } 这么引入说明 react 中有默认暴露，和部分暴露
    { Component } 将部分暴露的 Component 引入
    React 为默认暴露
 */
import React, { Component } from "react";
import Hello from "./components/Hello/Hello";
import Welcome from "./components/Welcome";

// 暴露并定义 App 组件
export default class App extends Component {
  render() {
    return (
      <div>
        <Hello />
        <Welcome />
      </div>
    );
  }
}
```

* src/components/Welcome.index.js

```javascript

import React, { Component } from "react";
/*
  css 模块化
  1 将 css 文件定义为 index.module.css
  2 import welcome from "./index.module.css";
  3 标签中 className={welcome.demo}
*/
import welcome from "./index.module.css";

export default class Welcome extends Component {
  render() {
    return <h2 className={welcome.demo}>Welcome!</h2>;
  }
}
```

* src/components/index.module.css

```css
.demo {
  background-color: pink;
}
```

> Note：文件名大写开头的 `js` 文件为组件，可将其改为 `jsx` 结尾。React 中引入时 `js`、`jsx` 可以省略结尾。
{: .prompt-info }


# ToDoList Demo

> 如果没有 `node_modules` 目录，可以执行命令 `yarn start` 安装依赖
{: .prompt-info }


[TODO_List_Demo](https://github.com/ZacharyWulven/ReactGuide/tree/master/app/todo_list_demo_m1)


# React ajax

* React 本身只关注界面，并不包含发生 `ajax` 请求代码。React 中需要集成第三方 `ajax` 库或自己封装

## 常用的 `ajax` 库
1. `jQuery`：比较重，不建议使用
2. `axios`：轻量级，建议使用
  * 封装 `XmlHttpRequest` 对象的 `ajax`
  * `promise` 风格
  * 可以用在浏览器端和 node 服务器端运行


### 安装 `axios`

```shell
$ yarn add axios
```

## 启动本地 node server

```shell
$ yarn add express
$ node server1.js
```

* server1.js

```javascript
const express = require("express");
const app = express();

app.use((request, response, next) => {
  console.log("有人请求了 server 1");
  next();
});

app.get("/students", (request, response) => {
  const students = [
    { id: "001", name: "tom", age: 18 },
    { id: "002", name: "jerry", age: 28 },
    { id: "003", name: "tony", age: 35 },
  ];
  response.send(students);
});

app.listen(5000, (err) => {
  if (!err) {
    console.log(
      "server 1 启动成功了，请求学生信息地址为 http://localhost:5000/students"
    );
  }
});
```

## React 中开始代理两种方式：

* 试想一下页面位于 `http://localhost:3000`，但是请求的数据位于 `http://localhost:5000`，当请求时会发生 Access-Control-Allow-Origin 问题表示跨域问题
  * 情况如下：
    - 本来网页位置是 ，但想给 http://localhost:5000 发请求 
    - 但 `ajax` 库能发送，但数据回不来
* 在 react 中可通过代理来解决，因为 `ajax 不能跨域`，但中间代理是没有 `ajax` 所以可以接收 5000 端口的数据


### 方法一
1. 编辑 React 项目中 `package.json` 在最后添加 `proxy` 字段，然后重启项目 `yarn start`
2. 将请求由 http://localhost:5000/students 改为 http://localhost:3000/students


```json
// package.json
  "proxy": "http://localhost:5000/"
```


```javascript
import React, { Component } from "react";
import "./App.css";
import axios from "axios";

export default class App extends Component {

  getStudentData = () => {
    axios.get("http://localhost:3000/students").then(
      (response) => {
        console.log("成功了：", response.data);
      },
      (err) => {
        console.log("失败了：", err);
      }
    );
  };

  render() {
    return (
      <div>
        <button onClick={this.getStudentData}>点我获取学生数据</button>
        <button onClick={this.getCarData}>点我获取汽车数据</button>

      </div>
    );
  }
}
```

* 优点：配置简单，前端请求资源时可以不加任何前缀
* 缺点：不能配置多个代理
* 工作方式：当请求了 3000 下没有的资源时，才会将请求转发给 5000


### 方法二
1. 在 `src` 目录下新建 `setupProxy.js`
2. 以下为代理样例

```javascript
// `setupProxy.js`

// Note: 这个文件不能用 ES6 js，要用 CJS 方式

// react 脚手架初始化时候已经下载好 http-proxy-middleware 库
const { createProxyMiddleware } = require("http-proxy-middleware");

/*
    凡是带 /api1 的都会走代理，(下边 /api2 的同理)
    changeOrigin 让服务器知道请求是从哪里发出的
        true 时，
    pathRewrite: { "^/api1": "" } 让 /api1 替换为空字符串
      即 url=http://localhost:3000/api1/students 变为 url=http://localhost:3000/students
*/
module.exports = function (app) {
  app.use(
    createProxyMiddleware("/api1", {
      // 遇见 /api1 前缀的请求，就会触发该代理配置
      target: "http://localhost:5000", // 请求转发给谁
      /*
        控制服务器收到的请求头中 Host 字段的值
        changeOrigin: true 可以欺骗服务器让其认为是来自 localhost:5000，
        否则显示 Host 为 localhost:3000
        可以不写，但最好设置为 true
       */
      changeOrigin: true,
      /*
        重写请求路径，这个必须写
        将 http://localhost:5000/api1/students 改为 http://localhost:5000/students 
      */
      pathRewrite: { "^/api1": "" },
    }),
    createProxyMiddleware("/api2", {
      target: "http://localhost:5002", // 请求转发给谁
      changeOrigin: true,
      pathRewrite: { "^/api2": "" },
    })
  );
};
```

> 此方法可配置多个代理。修改 `setupProxy.js` 内容后需要重启 React 脚手架（即 `yarn start`）
{: .prompt-info }


[如何使用代理Demo](https://github.com/ZacharyWulven/ReactGuide/tree/master/app/ajax-demo)


## ajax 案例

### 知识点：连续结构赋值

```javascript
    /*  
        知识点：
        连续结构赋值，并重命名为 keyWord
        keyWordElement 是 this 的属性
        keyWord 是对 value 的重命名
    */
    const {
      keyWordElement: { value: keyWord },
    } = this;
    console.log(keyWord);
```

### 消息订阅与发布机制，PubsubJS 的使用（子组件间相互通信）

* 安装第三方库

```shell
$ yarn add axios

# 安装 PubsubJS
$ yarn add pubsub-js
```

[PubSubJS-Github](https://github.com/mroderick/PubSubJS)

* 如何使用 PubsubJS ?
  1. 在需要接收数据的组件里订阅消息，定义好定义消息名称
  2. 如果有人发布你订阅的消息，那么订阅消息时传入的回调就会被调用，回调会有俩参数：
    - 参数一：消息名称
    - 参数二：发布者发布的数据
    
    
* 订阅组件

```javascript
import PubSub from "pubsub-js";

export default class List extends Component {
  /*
    初始化状态
  */
  state = {
    isFirst: true, // 是否第一次打开页面
    users: [], // 搜索的用户为数组
    isLoading: false, // 是否正在加载数据
    err: "", // 存储请求相关的错误信息
  };

  componentDidMount() {
    // 初始化订阅
    this.token = PubSub.subscribe("searchUser", (_, stateObj) => {
      console.log("List receive subscribe: ", stateObj);
      this.setState(stateObj);
    });
  }

  componentWillUnmount() {
    PubSub.unsubscribe(this.token);
  }
}
```

* 发布消息组件

```javascript
import PubSub from "pubsub-js";

PubSub.publish("searchUser", { isFirst: false, isLoading: true });
```


[PubSubJS-Demo](https://github.com/ZacharyWulven/ReactGuide/commit/33f4b6b9ddd8e6523c520451fad93ca28201d228)


### fetch 发送请求（关注分离的设计模式）

* 发 ajax 请求的几种方式
1. xhr（XmlHttpRequest）：window 上的 http request 对象，用起来麻烦
2. jQuery：有回调嵌套太多问题
3. axios：Promise 风格

> 前端中 jQuery axios 都是对 xhr 的封装
{: .prompt-info }

* fetch（现在开发中用的不多）：内置的，非第三方库，可直接使用，与 xhr 同级别，Promise 风格，不是对 xhr 的封装


[fetch 文章](https://segmentfault.com/a/1190000003810652)


```javascript
  search = async () => {
    // 获取用户输入
    /*  
        知识点：
        连续结构赋值，并重命名为 keyWord
        keyWordElement 是 this 的属性
        keyWord 是对 value 的重命名
    */
    const {
      keyWordElement: { value: keyWord },
    } = this;
    console.log(keyWord);

    // 发送请求前告诉 List 更新 state
    PubSub.publish("searchUser", { isFirst: false, isLoading: true });

    /*
      使用 axios 发送请求：
    */
    // axios.get(`https://api.github.com/search/users?q=${keyWord}`).then(
    //   (response) => {
    //     // console.log("成功了：", response.data);
    //     PubSub.publish("searchUser", {
    //       users: response.data["items"],
    //       isLoading: false,
    //     });
    //   },
    //   (err) => {
    //     // console.log("失败了：", err);
    //     PubSub.publish("searchUser", { err: err.message, isLoading: false });
    //   }
    // );

    // 使用 fetch 发送请求
    /*  
        Promise 回顾
        Promise 才能 .then 调用
        如果 .then 指定的成功回调的返回值是一个 Promise 对象，就会把该 Promise 对象作为该 .then 的返回值了

        如果 .then 指定的成功的回调 (response) {} 或失败的回调 (error) {} 其中之一的返回值
          1 返回是非 Promise 值，那么外层 .then 返回的 Promise 实例状态就为成功的，值就为你返回的非 Promise 值
          2 返回是 Promise 值，就把这个 Promise 值作为外层 .then 的 Promise 实例的值了    
            如果返回是成功的 Promise 实例，数据为 1，则外层 .then 返回的 Promise 状态就为成功，值就为 1
            如果返回 Pending 的 Promise，则外层 .then 返回的也是 Pending 的 Promise
            如果成功回调中抛出了异常，则外层 .then 返回的 Promise 就是失败的，失败的原因就为抛出的异常

    */
    
    // 未优化版本
    // fetch(`https://api.github.com/search/users?q=${keyWord}`)
    //   .then(
    //     (response) => {
    //       // console.log("联系成功了", response);
    //       /*
    //         response.json() 返回 Promise
    //         如果获取数据成功则 Promise 也变成成功的状态，并保存数据
    //         如果获取数据失败了则 Promise 也变成失败的状态，并保存着失败原因
    //     */
    //       console.log("联系成功了: ");
    //       return response.json();
    //     },
    //     (error) => {
    //       console.log("联系失败了", error);
    //       /*
    //         return new Promise(() => {}); 用于中断 Promise 链
    //         如果断网了就走到这里，如果不 return new Promise(); 会返回 undefined，
    //         此时外层 .then 返回 Promise 但值是 undefined，这样到下一个 .then 就会
    //         走到成功的回调，这不是我们想要看到的
    //         通过 new Promise(() => {}) 这样就中断了 Promise 链使其不会往下走
    //        */
    //       return new Promise(() => {});
    //     }
    //   )
    //   .then(
    //     (response) => {
    //       console.log("获取数据成功了", response);
    //     },
    //     (error) => {
    //       console.log("获取数据失败了", error);
    //     }
    //   );

    // 优化 1 版本
    // fetch(`https://api.github.com/search/users?q=${keyWord}`)
    //   .then((response) => {
    //     console.log("联系成功了: ");
    //     return response.json();
    //   })
    //   .then((response) => {
    //     console.log("获取数据成功了", response);
    //   })
    //   .catch((error) => {
    //     console.log("请求出错了", error);
    //   });

    // 优化 2 版本
    try {
      const response = await fetch(
        `https://api.github.com/search/users?q=${keyWord}`   // 先看连接是否成功
      );
      const data = await response.json();                    // 再获取数据
      PubSub.publish("searchUser", {
        users: data["items"],
        isLoading: false,
      });
      console.log(data);
    } catch (error) {
      console.log(error);
      PubSub.publish("searchUser", { err: error.message, isLoading: false });
    }
  };
```

> `fetch` 了解即可，使用率不高，因为有兼容性问题，老版本浏览器可能不支持。它不使用 `XmlHttpRequest` 对象提交 `ajax` 请求
{: .prompt-info }


# 对 SPA 应用的理解

