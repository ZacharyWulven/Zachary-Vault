---
layout: post
title: RustGuide-12
date: 2023-04-01 16:45:30.000000000 +09:00
categories: [Rust]
tags: [Rust]
---

# 15 智能指针
* Rust 中最常见的指针就是 `引用`
* 引用
1. 使用 & 符号
2. 会借用它指向的值
3. 没有其余的开销
4. 最常见的指针类型

## 智能指针
* 智能指针是这样的一些数据结构
1. 行为与指针相似
2. 有额外的元数据和功能

## 引用计数（reference counting）智能指针类型
* 通过记录所有者的数量，使一份数据被多个所有者同时持有
* 并且在没有任何所有者时自动清理数据
* 像 OC 的 ARC

* 引用和智能指针的区别
1. 引用：只借用数据
2. 智能指针：很多时候都拥有它所指向的数据

### 智能指针的例子
* String 和 `Vec<T>`
1. 都拥有一片内存区域，并且允许用户对其操作
2. 还拥有元数据（例如容量等）
3. 还提供额外的功能和保障（String 保障其数据是合法的 UTF-8 编码）

### 智能指针的实现
* 通常使用 struct 实现，并且实现了 `Deref` 和 `Drop` 这两个 trait
* `Deref` trait：允许智能指针 struct 的实例像引用一样使用，这样就能同时用于引用和智能指针
* `Drop` trait：允许你自定义当智能指针实例走出作用域时的代码


### 标准库中常见的智能指针
* `Box<T>` 在 heap 内存上分配值
* `Rc<T>` 启用多重所有权的引用计数类型
* `Ref<T>` 和 `RefMut<T>`，通过 RefCell<T> 访问的：在运行时而不是编译时强制借用规则的类型
* 内部可变模式（interior mutability pattern）：这个模式不可变类型可暴露出可修改其内部值的 API（像 swift 的 mutating）


## 使用 `Box<T>` 来指向 Heap 上的数据
* `Box<T>` 是一种最简单的智能指针
* 允许你再 heap 上存储数据（而不是在 stack 上）
* stack 上是指向 heap 数据的指针
* 没有性能开销，没有其他额外功能
* 实现了 `Deref` 和 `Drop` 这两个 trait


![image](/assets/images/rust/box.png)


### `Box<T>` 常用的场景
* 在编译时，某类型的大小无法确定，但使用该类型时，上下文却需要知道它确切的大小
* 或当你有大量数据，想移交所有权，但需要确保在操作时数据不会被复制
* 在使用某个值时，你只关心它是否实现了特定的 trait，而不关心它的具体类型


### 使用 `Box<T>` 在 heap 上存储数据

```rust
fn main() {
    println!("Hello, world!");
    /*
        5 存储在 heap 上
        b 走完 main 函数作用域会被释放
        会释放 stack 上的指针和存在 heap 上的数据
     */
    let b = Box::new(5);
    println!("b = {}", b);
}
```

### 使用 `Box<T>` 赋能递归类型

> 在编译时 Rust 需要知道每一个类型所占的空间大小。而递归类型无法再编译时确定大小。但 Box 类型的大小确定，所以可以在递归类型中使用 Box 解决。
{: .prompt-info }

* 函数式语言中叫 Cons List


![image](/assets/images/rust/digui.png)

### 关于 Cons List
* Cons List 是来自 Lisp 语言的一种数据结构
* Cons List 里每个成员由两个成员组成，与上图相似
1. 当前项的值
2. 下一个元素
* Cons List 里最后一个成员只包含一个 Nil 值（一个终止标记），没有下一个元素
* Cons List 并不是 Rust 里的常用集合
* 通常情况下， `Vec<T>` 是更好的选择


```rust
// 编译时确定枚举里最大存储空间为其需要的存储空间大小
enum Message {
    Quit,  // 不需要空间
    Move {x: i32, y: i32}, // 需要两个 i32 空间
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

### 使用 Box 来获的确定大小的递归类型
* `Box<T>` 是一个指针，Rust 知道它需要多少空间，因为
1. 指针的大小不会基于它指向的数据大小变化而变化

```rust
use crate::List:: {Cons, Nil};
fn main() {
    let list = Cons(1, 
        Box::new(Cons(2,
             Box::new(Cons(3,
                 Box::new(Nil))))));
    println!("{:#?}", list);
}

#[derive(Debug)]
enum List {
    Cons(i32, Box<List>),
    Nil,
}
```

* `Box<T>` 
1. 只提供了 “间接” 存储和 heap 内存分配的功能
2. 没有其他额外功能
3. 没有性能开销
4. 适用与需要 “间接” 存储的场景，例如 Cons List
5. 实现了 `Deref` trait 就允许将 Box 的值当成引用来处理
6. 实现了 `Drop` trait 就是当 Box 离开作用域时，它指向的 heap 上数据以及 stack 上的指针数据都会被清理


## Deref Trait
* Deref 就是解引用的意思
* 实现了 Deref Trait 使我们可以自定义解引用运算符 `*` 的行为
* 通过实现 Deref Trait，智能指针可以像常规引用一样来处理，即处理引用的代码可以不加修改的处理这个智能指针


### 解引用运算符
* 常规引用也是一种指针

```rust
    let x = 5;
    let y = &x;
    assert_eq!(5, x);
    assert_eq!(5, *y); // * 即解引用，取出 y 的值与 5 进行比较
    assert_eq!(5, y);  // 这样会报错，因为没有实现 integer 与 &integer 的比较
```

### 把 `Box<T>` 当作引用来使用
* `Box<T>` 可以代替上例中的引用

```rust
    let x = 5;
    //let y = &x;
    let y = Box::new(x);  // 即 `Box<T>` 可以当作引用来使用
    assert_eq!(5, x);
    assert_eq!(5, *y); 
```

### 定义自己的智能指针
* `Box<T>` 被定义成拥有一个元素的 tuple struct 

* 实现 Deref Trait
1. 标准库中的 Deref Trait 要求我们实现一个 deref 方法
2. deref 方法会借用 self，并返回一个指向内部数据的引用

```rust
use std::ops::Deref;

// 一个 tuple struct，即一个有名称的元组
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

impl<T> Deref for MyBox<T> {
    // 定义了 Deref trait 的关联类型
    type Target = T;

    fn deref(&self) -> &T {
        &self.0
    }

}

fn main() {
    let x = 5;
    //let y = &x;
    let y = MyBox::new(x);
    assert_eq!(5, x);
    /*
        如果 MyBox 没实现 Deref trait，这里会报错
        *y 相当于 *(y.deref())，Rust 会隐式展开为 *(y.deref())
     */
    assert_eq!(5, *y);
}
```

### 函数和方法隐式解引用转化（Deref Coercion）
* 隐式解引用转化（Deref Coercion）是为函数和方法提供的一种便捷特性
* 原理：
1. 假设 T 实现了 Deref trait

